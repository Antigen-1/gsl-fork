@node High Level Root Finding Functions
@section High Level Root Finding Functions
@cindex root finding, high level functions

GSL provides three high level root finding functions. They are simple to
use, robust, and adequate for most tasks, but certain situations require
more control than the high level root finding functions provide.

@menu
* Root Finder Exit Values::           How to tell if an error occured and
                                      how the root location is returned
* Providing the Function to Search::  How to provide a function for the
                                      root finder to operate on
* Automatic Control Decisions::       How high level root finders set
                                      parameters such as tolerance
* High Level Functions::              Names and arguments of the high
                                      level root finding functions
@end menu


@node Root Finder Exit Values
@subsection Root Finder Exit Values

Since the return value of GSL root finding functions is reserved for the
error status, you must provide storage for the location of the found
root. 

@deftypevr {Function Argument} {double *} root
@vindex @r{root finding,} root @r{(function argument)}
A pointer to a place for the GSL root finder to store the location of
the found root. This must be a valid pointer; GSL root finders will not
allocate any memory for you.
@end deftypevr

If a GSL root finder succeeds, it will return @code{0} and store the
location of the found root in @w{@code{*root}}.

If a GSL root finder fails, it will return @code{-1} and set
@w{@code{gsl_errno}} to a diagnostic value. @xref{Root Finder Error
Handling}, for a discussion of possible error codes. Nothing useful will
be stored in @w{@code{*root}} if the function failed.


@node Providing the Function to Search
@subsection Providing the Function to Search
@cindex root finding, providing a function to search

You must provide a continous function of one variable for GSL root
finder(s) to operate on, and, sometimes, its first derivative.

Recall that when passing pointers to functions, you give the name of the
function you are passing. For example:

@smallexample
foo = i_take_a_function_pointer(my_function);
@end smallexample

@deftypevr {Function Argument} double {@t{(*} f@t{)(double)}}
@vindex @r{root finding,} f @r{(function argument)}
A pointer to the function whose root you are searching for. It is called
by the root finding function many times during its search. It must be
continous within the region of interest.

Here is an example function which you could pass to a GSL root finder:

@smallexample
@group
double
my_f (double x) @{
   return sin (2 * x) + 2 * cos (x);
@}
@end group
@end smallexample

@end deftypevr

@deftypevr {Function Argument} double {@t{(*} df@t{)(double)}}
@vindex @r{root finding,} df @r{(function argument)}
A pointer to the first derivative of the function whose root you are
searching for.

If we were looking for a root of the function in the previous example,
this is what we would use for @code{df}:

@smallexample
@group
double
my_df (double x) @{
   return 2 * cos (2 * x) - 2 * sin (x);
@} 
@end group
@end smallexample

@end deftypevr

@deftypevr {Function Argument} void {@t{(*} fdf@t{)(double *, double *,
double, int, int)}}
A pointer to a function which calculates both the value of the function
under search and the value of its first derivative. Because many terms
of a function and its derivative are the same, it is often faster to use
this method as opposed to providing @math{f(x)} and @math{f'(x)}
separately. However, it is more complicated.

It stores @math{f(x)} in its first argument and @math{f'(x)} in its
second.

Here's an example where @math{f(x) = 2\sin(2x)\cos(x)}:

@smallexample
@group
void
my_fdf (double * y, double * yprime, double x,
        int y_wanted, int yprime_wanted) @{
   double sin2x, cosx;

   sin2x = sin (2 * x);
   cosx = cos (x);

   if (y_wanted)
      *y = 2 * sin2x * cos (x);
   if (yprime_wanted)
      *yprime = 2 * sin2x * -sin (x) + 2 * cos (2 * x) * cosx);
@}
@end group
@end smallexample

@end deftypevr


@node Automatic Control Decisions
@subsection Automatic Control Decisions
@cindex root finding, high level automatic control
@cindex root finding, control (high level)

@strong{FIXME: Coming soon...}


@node High Level Functions
@subsection High Level Functions
@cindex root finding, high level functions
@cindex root finding, hybrid algorithms
@cindex root finding, high level algorithms

@strong{FIXME: Coming soon...}
