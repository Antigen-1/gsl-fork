@cindex nonlinear least squares
@cindex least squares, nonlinear

This chapter describes functions for multidimensional nonlinear
least-squares fitting.  There are generally two classes of
algorithms for solving nonlinear least squares problems, which
fall under line search methods and trust region methods.
GSL currently implements only trust region methods and
provides the user with
full access to intermediate steps of the iteration. The user
also has the ability to tune a number of parameters which affect
low-level aspects of the algorithm which can help to accelerate
convergence for the specific problem at hand.

The header file @file{gsl_multifit_nlinear.h} contains prototypes for the
multidimensional nonlinear fitting functions and related declarations.

@menu
* Nonlinear Least-Squares Overview::
* Nonlinear Least-Squares TRS Overview::
* Nonlinear Least-Squares Weighted Overview::
* Nonlinear Least-Squares Tunable Parameters::
* Nonlinear Least-Squares Initialization::
* Nonlinear Least-Squares Function Definition::
* Nonlinear Least-Squares Iteration::
* Nonlinear Least-Squares Testing for Convergence::
* Nonlinear Least-Squares High Level Driver::
* Nonlinear Least-Squares Minimization Algorithms Using Derivatives::
* Nonlinear Least-Squares Covariance Matrix::
* Nonlinear Least-Squares Large Systems::
* Nonlinear Least-Squares Troubleshooting::
* Nonlinear Least-Squares Examples::
* Nonlinear Least-Squares References and Further Reading::
@end menu

@node Nonlinear Least-Squares Overview
@section Overview
@cindex nonlinear least squares, overview

The problem of multidimensional nonlinear least-squares fitting requires
the minimization of the squared residuals of @math{n} functions,
@math{f_i}, in @math{p} parameters, @math{x_i},
@tex
\beforedisplay
$$
\Phi(x)  = {1 \over 2} || f(x) ||^2
         = {1 \over 2} \sum_{i=1}^{n} f_i (x_1, \dots, x_p)^2
$$
\afterdisplay
@end tex
@ifinfo

@example
\Phi(x) = (1/2) || f(x) ||^2
        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
@end example

@end ifinfo
@noindent
In trust region methods, the objective (or cost) function @math{\Phi(x)} is approximated
by a model function @math{m_k(\delta)} in the vicinity of some point @math{x_k}. The
model function is often simply a second order Taylor series expansion around the
point @math{x_k}, ie:
@tex
\beforedisplay
$$
\Phi(x_k + \delta) \approx m_k(\delta) = \Phi(x_k) + g_k^T \delta + {1 \over 2} \delta^T B_k \delta
$$
\afterdisplay
@end tex
@ifinfo

@example
\Phi(x_k + \delta) ~=~ m_k(\delta) = \Phi(x_k) + g_k^T \delta + 1/2 \delta^T B_k \delta
@end example

@end ifinfo
where @math{g_k = \nabla \Phi(x_k) = J^T f} is the gradient vector at the point @math{x_k},
@math{B_k = \nabla^2 \Phi(x_k)} is the Hessian matrix at @math{x_k}, or some
approximation to it, and @math{J} is the @math{n}-by-@math{p} Jacobian matrix
@c{$J_{ij} = \partial f_i / \partial x_j$}
@math{J_@{ij@} = d f_i / d x_j}.
In order to find the next step @math{\delta}, we minimize the model function
@math{m_k(\delta)}, but search for solutions only within a region where
we trust that @math{m_k(\delta)} is a good approximation to the objective
function @math{\Phi(x_k + \delta)}. In other words,
we seek a solution of the trust region subproblem (TRS)
@tex
\beforedisplay
$$
\min_{\delta \in R^p} m_k(\delta) = \Phi(x_k) + g_k^T \delta + {1 \over 2} \delta^T B_k \delta, \qquad\hbox{s.t.}\quad || D_k \delta || \le \Delta_k
$$
\afterdisplay
@end tex
@ifinfo

@example
\min_(\delta \in R^p) m_k(\delta), s.t. || D_k \delta || <= \Delta_k
@end example

@end ifinfo
where @math{\Delta_k > 0} is the trust region radius and @math{D_k} is
a scaling matrix. If @math{D_k = I}, then the trust region is a ball
of radius @math{\Delta_k} centered at @math{x_k}. In some applications,
the parameter vector @math{x} may have widely different scales. For
example, one parameter might be a temperature on the order of
@math{10^3} K, while another might be a length on the order of
@math{10^{-6}} m. In such cases, a spherical trust region may not
be the best choice, since if @math{\Phi} changes rapidly along
directions with one scale, and more slowly along directions with
a different scale, the model function @math{m_k} may be a poor
approximation to @math{\Phi} along the rapidly changing directions.
In such problems, it may be best to use an elliptical trust region,
by setting @math{D_k} to a diagonal matrix whose entries are designed
so that the scaled step @math{D_k \delta} has entries of approximately the same
order of magnitude.

The trust region subproblem above normally amounts to solving a
linear least squares system (or multiple systems) for the step
@math{\delta}. Once @math{\delta} is computed, it is checked whether
or not it reduces the objective function @math{\Phi(x)}. A useful
statistic for this is to look at the ratio
@tex
\beforedisplay
$$
\rho_k = { \Phi(x_k) - \Phi(x_k + \delta_k) \over m_k(0) - m_k(\delta_k) }
$$
\afterdisplay
@end tex
@ifinfo

@example
\rho_k = ( \Phi(x_k) - \Phi(x_k + \delta_k) / ( m_k(0) - m_k(\delta_k) )
@end example

@end ifinfo
where the numerator is the actual reduction of the objective function
due to the step @math{\delta_k}, and the denominator is the predicted
reduction due to the model @math{m_k}. If @math{\rho_k} is negative,
it means that the step @math{\delta_k} increased the objective function
and so it is rejected. If @math{\rho_k} is positive,
then we have found a step which reduced the objective function and
it is accepted. Furthermore, if @math{\rho_k} is close to 1,
then this indicates that the model function is a good approximation
to the objective function in the trust region, and so on the next
iteration the trust region is enlarged in order to take more ambitious
steps. When a step is rejected, the trust region is made smaller and
the TRS is solved again. An outline for the general trust region method
used by GSL can now be given.

@noindent
@b{Trust Region Algorithm}
@enumerate

@item Initialize: given @math{x_0}, construct @math{m_0(\delta)}, @math{D_0} and @math{\Delta_0 > 0}

@item For k = 0, 1, 2, ...

@enumerate a

@item If converged, then stop

@item Solve TRS for trial step @math{\delta_k}

@item Evaluate trial step by computing @math{\rho_k}

@enumerate
@item if step is accepted, set @math{x_{k+1} = x_k + \delta_k} and increase radius, @math{\Delta_{k+1} = \alpha \Delta_k}
@item if step is rejected, set @math{x_{k+1} = x_k} and decrease radius, @math{\Delta_{k+1} = {\Delta_k \over \beta}}; goto 2(b)
@end enumerate

@item Construct @math{m_{k+1}(\delta)} and @math{D_{k+1}}

@end enumerate

@end enumerate

@noindent
GSL offers the user a number of different algorithms for solving the trust
region subproblem in 2(b), as well as different choices of scaling matrices
@math{D_k} and different methods of updating the trust region radius
@math{\Delta_k}. Therefore, while reasonable default methods are provided,
the user has a lot of control to fine-tune the various steps of the
algorithm for their specific problem.

@noindent
Note that the model parameters are denoted by @math{x} in this chapter
since the non-linear least-squares algorithms are described
geometrically (i.e. finding the minimum of a surface).  The
independent variable of any data to be fitted is denoted by @math{t}.

@node Nonlinear Least-Squares TRS Overview
@section Solving the Trust Region Subproblem (TRS)

@menu
* Nonlinear Least-Squares TRS Levenberg-Marquardt::
* Nonlinear Least-Squares TRS Dogleg::
* Nonlinear Least-Squares TRS Double Dogleg::
* Nonlinear Least-Squares TRS 2D Subspace::
* Nonlinear Least-Squares TRS Steihaug-Toint Conjugate Gradient::
@end menu

Below we describe the methods available for solving the trust region
subproblem. The methods available provide either exact or approximate
solutions to the trust region subproblem. In all algorithms below,
the Hessian matrix @math{B_k} is approximated as @math{B_k \approx J_k^T J_k},
where @math{J_k = J(x_k)}.

@node Nonlinear Least-Squares TRS Levenberg-Marquardt
@subsection Levenberg-Marquardt
@cindex Levenberg-Marquardt algorithm
@cindex nonlinear least squares, levenberg-marquardt

There is a theorem which states that if @math{\delta_k} is a solution
to the trust region subproblem given above, then there exists
@math{\mu_k \ge 0} such that
@tex
\beforedisplay
$$
\left( B_k + \mu_k D_k^T D_k \right) \delta_k = -g_k
$$
\afterdisplay
@end tex
@ifinfo

@example
( B_k + \mu_k D_k^T D_k ) \delta_k = -g_k
@end example

@end ifinfo
with @math{\mu_k (\Delta_k - ||D_k \delta_k||) = 0}. This
forms the basis of the Levenberg-Marquardt algorithm, which controls
the trust region size by adjusting the parameter @math{\mu_k}
rather than the radius @math{\Delta_k} directly. For each radius
@math{\Delta_k}, there is a unique parameter @math{\mu_k} which
solves the TRS, and they have an inverse relationship, so that large values of
@math{\mu_k} correspond to smaller trust regions, while small
values of @math{\mu_k} correspond to larger trust regions.

@noindent
With the approximation @math{B_k \approx J_k^T J_k}, on each iteration,
in order to calculate the step @math{\delta_k},
the following linear least squares problem is solved:
@tex
\beforedisplay
$$
\left[
\matrix{
J_k \cr
\sqrt{\mu_k} D_k
}
\right]
\delta_k =
-
\left[
\matrix{
f_k \cr
0
}
\right]
$$
\afterdisplay
@end tex
@ifinfo

@example
[J_k; sqrt(mu_k) D_k] \delta_k = - [f_k; 0]
@end example

@end ifinfo
@noindent
If the step @math{\delta_k} is accepted, then
@math{\mu_k} is decreased on the next iteration in order
to take a larger step, otherwise it is increased to take
a smaller step. The Levenberg-Marquardt algorithm provides
an exact solution of the trust region subproblem, but
typically has a higher computational cost per iteration
than the approximate methods discussed below, since it
may need to solve the least squares system above several
times for different values of @math{\mu_k}.

@node Nonlinear Least-Squares TRS Dogleg
@subsection Dogleg
@cindex Dogleg algorithm
@cindex nonlinear least squares, dogleg

This is Powell's dogleg method, which finds an approximate
solution to the trust region subproblem, by restricting
its search to a piecewise linear ``dogleg'' path,
composed of the origin, the Cauchy point which represents
the model minimizer along the steepest descent direction,
and the Gauss-Newton point, which is the overall minimizer
of the unconstrained model. The Gauss-Newton step is calculated by
solving
@tex
\beforedisplay
$$
J_k \delta_{gn} = -f_k
$$
\afterdisplay
@end tex
@ifinfo

@example
J_k \delta_gn = -f_k
@end example

@end ifinfo
which is the main computational task for each iteration,
but only needs to be performed once per iteration. If
the Gauss-Newton point is inside the trust region, it is
selected as the step. If it is outside, the method then
calculates the Cauchy point, which is located along the
gradient direction. If the Cauchy point is also outside
the trust region, the method assumes that it is still far
from the minimum and so proceeds along the gradient
direction, truncating the step at the trust region
boundary. If the Cauchy point is inside the trust region,
with the Gauss-Newton point outside, the method
uses a dogleg step, which is a linear combination of the
gradient direction and the Gauss-Newton direction, stopping at the trust
region boundary.

@node Nonlinear Least-Squares TRS Double Dogleg
@subsection Double Dogleg
@cindex double Dogleg algorithm
@cindex Dogleg algorithm, double
@cindex nonlinear least squares, double dogleg

This method is an improvement over the classical dogleg
algorithm, which attempts to include information about
the Gauss-Newton step while the iteration is still far from
the minimum. When the Cauchy point is inside the trust region
and the Gauss-Newton point is outside, the method computes
a scaled Gauss-Newton point and then takes a dogleg step
between the Cauchy point and the scaled Gauss-Newton point.
The scaling is calculated to ensure that the reduction
in the model @math{m_k} is about the same as the reduction
provided by the Cauchy point.

@node Nonlinear Least-Squares TRS 2D Subspace
@subsection Two Dimensional Subspace

The dogleg methods restrict the search for the TRS solution
to a 1D curve defined by the Cauchy and Gauss-Newton points.
An improvement to this is to search for a solution using
the full two dimensional subspace spanned by the Cauchy
and Gauss-Newton directions. The dogleg path is of course
inside this subspace, and so this method solves the TRS
at least as accurately as the dogleg methods. Since this
method searches a larger subspace for a solution, it can
converge more quickly than dogleg on some problems. Because
the subspace is only two dimensional, this method is
very efficient and the main computation per iteration is
to determine the Gauss-Newton point.

@node Nonlinear Least-Squares TRS Steihaug-Toint Conjugate Gradient
@subsection Steihaug-Toint Conjugate Gradient

One difficulty of the dogleg methods is calculating the
Gauss-Newton step when the Jacobian matrix is singular. The
Steihaug-Toint method also computes a generalized dogleg
step, but avoids solving for the Gauss-Newton step directly,
instead using an iterative conjugate gradient algorithm. This
method performs well at points where the Jacobian is singular,
and is also suitable for large-scale problems where factoring
the Jacobian matrix could be prohibitively expensive.

@node Nonlinear Least-Squares Weighted Overview
@section Weighted Nonlinear Least-Squares

Weighted nonlinear least-squares fitting minimizes the function
@tex
\beforedisplay
$$
\Phi(x)  = {1 \over 2} || f ||_W^2
         = {1 \over 2} \sum_{i=1}^{n} w_i f_i (x_1, \dots, x_p)^2
$$
\afterdisplay
@end tex
@ifinfo

@example
\Phi(x) = (1/2) || f(x) ||_W^2
        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
@end example

@end ifinfo
where @math{W = diag(w_1,w_2,...,w_n)} is the weighting matrix,
and @math{||f||_W^2 = f^T W f}.
The weights @math{w_i} are commonly defined as @math{w_i = 1/\sigma_i^2},
where @math{\sigma_i} is the error in the @math{i}th measurement.
A simple change of variables @math{\tilde{f} = W^{1 \over 2} f} yields
@math{\Phi(x) = {1 \over 2} ||\tilde{f}||^2}, which is in the
same form as the unweighted case. The user can either perform this
transform directly on their function residuals and Jacobian, or use
the @code{gsl_multifit_nlinear_winit} interface which automatically
performs the correct scaling. To manually perform this transformation,
the residuals and Jacobian should be modified according to
@tex
\beforedisplay
$$
\eqalign{
\tilde{f}_i & = \sqrt{w_i} f_i = {f_i \over \sigma_i} \cr
\tilde{J}_{ij} & = \sqrt{w_i} { \partial f_i \over \partial x_j } = { 1 \over \sigma_i} { \partial f_i \over \partial x_j }
}
$$
\afterdisplay
@end tex
@ifinfo

@example
f~_i = f_i / \sigma_i
J~_ij = 1 / \sigma_i df_i/dx_j
@end example

@end ifinfo

@node Nonlinear Least-Squares Tunable Parameters
@section Tunable Parameters

@noindent
The user can tune nearly all aspects of the iteration by using the
@code{gsl_multifit_nlinear_parameters} structure, which is
defined as follows:

@example
typedef struct
@{
  const gsl_multifit_nlinear_scale *scale;    /* scaling method */
  const gsl_multifit_nlinear_solver *solver;  /* solver method */
  gsl_multifit_nlinear_fdtype fdtype;         /* finite difference method */
  double factor_up;                           /* factor for increasing trust region */
  double factor_down;                         /* factor for decreasing trust region */
  int accel;                                  /* use geodesic acceleration */
  double avmax;                               /* max allowed |a|/|v| */
  double h_df;                                /* J finite difference step */
  double h_fvv;                               /* fvv finite difference step */
@} gsl_multifit_nlinear_parameters;
@end example

@noindent
Each of these parameters is discussed in further detail below.

@deftypevr {Parameter} {gsl_multifit_nlinear_scale *} scale

This parameter determines the diagonal scaling matrix @math{D} and
may be selected from the following choices,

@defvr {Default} gsl_multifit_nlinear_scale_more
This damping strategy was suggested by Mor@'e, and
corresponds to @math{D^T D = } max(diag(@math{J^T J})),
in other words the maximum elements of
diag(@math{J^T J}) encountered thus far in the iteration.
This choice of @math{D} makes the problem scale-invariant,
so that if the model parameters @math{x_i} are each scaled
by an arbitrary constant, @math{\tilde{x}_i = a_i x_i}, then
the sequence of iterates produced by the algorithm would
be unchanged. This method can work very well in cases
where the model parameters have widely different scales
(ie: if some parameters are measured in nanometers, while others
are measured in degrees Kelvin). This strategy has been proven
effective on a large class of problems and so it is the library
default, but it may not be the best choice for all problems.
@end defvr

@defvr {Option} gsl_multifit_nlinear_scale_levenberg
This damping strategy was originally suggested by Levenberg, and
corresponds to @math{D^T D = I}. This method has also proven
effective on a large class of problems, but is not scale-invariant.
However, some authors (e.g. Transtrum and Sethna 2012) argue
that this choice is better for problems which are susceptible
to parameter evaporation (ie: parameters go to infinity)
@end defvr

@defvr {Option} gsl_multifit_nlinear_scale_marquardt
This damping strategy was suggested by Marquardt, and
corresponds to @math{D^T D = } diag(@math{J^T J}). This
method is scale-invariant, but it is generally considered
inferior to both the Levenberg and Mor@'e strategies, though
may work well on certain classes of problems.
@end defvr

@end deftypevr

@deftypevr {Parameter} {const gsl_multifit_nlinear_solver *} solver

@noindent
Solving the trust region subproblem on each iteration almost always
requires the solution of the following linear least squares system
@tex
\beforedisplay
$$
\left[
\matrix{
J \cr
\sqrt{\mu} D
}
\right]
\delta =
-
\left[
\matrix{
f \cr
0
}
\right]
$$
\afterdisplay
@end tex
@ifinfo

@example
[J; sqrt(mu) D] \delta = - [f; 0]
@end example

@end ifinfo

The @var{solver} parameter determines how the system is
solved and can be selected from the following choices:

@defvr {Default} gsl_multifit_nlinear_solver_qr
This method solves the system using a rank revealing QR
decomposition of the Jacobian @math{J}. This method will
produce reliable solutions in cases where the Jacobian
is rank deficient or near-singular but does require about
twice as many operations as the Cholesky method discussed
below.
@end defvr

@defvr {Option} gsl_multifit_nlinear_solver_cholesky
This method solves the alternate normal equations problem
@tex
\beforedisplay
$$
\left( J^T J + \mu D^T D \right) \delta = -J^T f
$$
\afterdisplay
@end tex
@ifinfo

@example
( J^T J + \mu D^T D ) \delta = -J^T f
@end example

@end ifinfo

by using a Cholesky decomposition of the matrix
@math{J^T J + \mu D^T D}. This method is faster than the
QR approach, however it is susceptible to numerical instabilities
if the Jacobian matrix is rank deficient or near-singular. In
these cases, an attempt is made to reduce the condition number
of the matrix using Jacobi preconditioning, but for highly
ill-conditioned problems the QR approach is better. If it is
known that the Jacobian matrix is well conditioned, this method
is accurate and will perform faster than the QR approach.
@end defvr

@defvr {Default} gsl_multifit_nlinear_solver_svd
This method solves the system using a singular value
decomposition of the Jacobian @math{J}. This method will
produce the most reliable solutions for ill-conditioned Jacobians
but is also the slowest solver method.
@end defvr

@end deftypevr

@deftypevr {Parameter} {gsl_multifit_nlinear_fdtype} fdtype

This parameter specifies whether to use forward or centered
differences when approximating the Jacobian. This is only
used when an analytic Jacobian is not provided to the solver.
This parameter may be set to one of the following choices.

@defvr {Default} GSL_MULTIFIT_NLINEAR_FWDIFF
This specifies a forward finite difference to approximate
the Jacobian matrix. The Jacobian matrix will be calculated as
@tex
\beforedisplay
$$
J_{ij} = {1 \over \Delta_j} \left( f_i(x + \Delta_j e_j) - f_i(x) \right)
$$
\afterdisplay
@end tex
@ifinfo

@example
J_ij = 1 / \Delta_j ( f_i(x + \Delta_j e_j) - f_i(x) )
@end example

@end ifinfo
where @math{\Delta_j = h |x_j|} and @math{e_j} is the standard
@math{j}th Cartesian unit basis vector so that
@math{x + \Delta_j e_j} represents a small (forward) perturbation of
the @math{j}th parameter by an amount @math{\Delta_j}. The perturbation
@math{\Delta_j} is proportional to the current value @math{|x_j|} which
helps to calculate an accurate Jacobian when the various parameters have
different scale sizes. The value of @math{h} is specified by the @code{h_df}
parameter. The accuracy of this method is @math{O(h)}, and evaluating this
matrix requires an additional @math{p} function evaluations.
@end defvr

@defvr {Option} GSL_MULTIFIT_NLINEAR_CTRDIFF
This specifies a centered finite difference to approximate
the Jacobian matrix. The Jacobian matrix will be calculated as
@tex
\beforedisplay
$$
J_{ij} = {1 \over \Delta_j} \left( f_i(x + {1 \over 2} \Delta_j e_j) - f_i(x - {1 \over 2} \Delta_j e_j) \right)
$$
\afterdisplay
@end tex
@ifinfo

@example
J_ij = 1 / \Delta_j ( f_i(x + 1/2 \Delta_j e_j) - f_i(x - 1/2 \Delta_j e_j) )
@end example

@end ifinfo
See above for a description of @math{\Delta_j}. The accuracy of this
method is @math{O(h^2)}, but evaluating this
matrix requires an additional @math{2p} function evaluations.
@end defvr

@end deftypevr

@deftypevr {Parameter} {double} factor_up

When a step is accepted, the trust region radius will be increased
by this factor. The default value is @math{3}.

@end deftypevr

@deftypevr {Parameter} {double} factor_down

When a step is rejected, the trust region radius will be decreased
by this factor. The default value is @math{2}.

@end deftypevr

@deftypevr {Parameter} {int} accel

This parameter toggles the use of the so-called geodesic
acceleration correction to the standard Levenberg-Marquardt
step @math{\delta} (Transtrum et al...). By interpreting
@math{\delta} as a first order step along a geodesic in the
model parameter space (ie: a velocity @math{\delta = v}), the geodesic
acceleration @math{a} is a second order correction along the
geodesic which is determined by solving the linear least squares system
@tex
\beforedisplay
$$
\left[
\matrix{
J \cr
\sqrt{\mu} D
}
\right]
a =
-
\left[
\matrix{
f_{vv} \cr
0
}
\right]
$$
\afterdisplay
@end tex
@ifinfo

@example
[J; sqrt(mu) D] \delta = - [f_vv; 0]
@end example

@end ifinfo

where @math{f_{vv}} is the second directional derivative of
the residual vector in the velocity direction @math{v},
@math{f_{vv}(x) = D_v^2 f = \sum_{\alpha\beta} v_{\alpha} v_{\beta} \partial_{\alpha} \partial_{\beta} f(x)},
where @math{\alpha} and @math{\beta} are summed over the @math{p}
parameters. The new total step is then @math{\delta' = v + {1 \over 2}a}.
The second order correction @math{a} can be calculated with a modest additional
cost, and has been shown to dramatically reduce the number of iterations
(and expensive Jacobian evaluations) required to reach convergence on a variety
of different problems. In order to utilize the geodesic acceleration, the user must supply a
function which provides the second directional derivative vector
@math{f_{vv}(x)}, or alternatively the library can use a finite
difference method to estimate this vector with one additional function
evaluation of @math{f(x + h v)} where @math{h} is a tunable step size
(see the @code{h_fvv} parameter description). The user may enable
geodesic acceleration by setting @code{accel} to 1. It is disabled
by default.

@end deftypevr

@deftypevr {Parameter} {double} avmax

When using geodesic acceleration to solve a nonlinear least squares problem,
an important parameter to monitor is the ratio of the acceleration term
to the velocity term,
@tex
\beforedisplay
$$
{ ||a|| \over ||v|| }
$$
\afterdisplay
@end tex
@ifinfo

@example
|a| / |v|
@end example

@end ifinfo

If this ratio is small, it means the acceleration correction
is contributing very little to the step. This could be because
the problem is not ``nonlinear'' enough to benefit from
the acceleration. If the ratio is large (@math{> 1}) it
means that the acceleration is larger than the velocity,
which shouldn't happen since the step represents a truncated
series and so the second order term @math{a} should be smaller than
the first order term @math{v} to guarantee convergence.
Therefore any steps with a ratio larger than the parameter
@var{avmax} are rejected. @var{avmax} is set to 0.75 by default.
For problems which experience difficulty converging, this threshold
could be lowered.

@end deftypevr

@deftypevr {Parameter} {double} h_df

This parameter specifies the step size for approximating the
Jacobian matrix with finite differences. It is set to
@math{\sqrt{\epsilon}} by default, where @math{\epsilon}
is @code{GSL_DBL_EPSILON}.

@end deftypevr

@deftypevr {Parameter} {double} h_fvv

When using geodesic acceleration, the user must either supply
a function to calculate @math{f_{vv}(x)} or the library
can estimate this second directional derivative using a finite
difference method. When using finite differences, the library
must calculate @math{f(x + h v)} where @math{h} represents
a small step in the velocity direction. The parameter
@var{h_fvv} defines this step size and is set to 0.01 by
default.

@end deftypevr

@node Nonlinear Least-Squares Initialization
@section Initializing the Solver

@deftypefun {gsl_multifit_nlinear_workspace *} gsl_multifit_nlinear_alloc (const gsl_multifit_nlinear_type * @var{T}, const gsl_multifit_nlinear_parameters * @var{params}, const size_t @var{n}, const size_t @var{p})
@tindex gsl_multifit_nlinear_alloc
@tindex gsl_multifit_nlinear_type
This function returns a pointer to a newly allocated instance of a
derivative solver of type @var{T} for @var{n} observations and @var{p}
parameters. The @var{params} input specifies a tunable set of
parameters which will affect important details in each iteration
of the Levenberg-Marquardt algorithm. It is recommended to start
with the suggested default parameters (see
@code{gsl_multifit_nlinear_default_parameters}) and then tune
the parameters once the code is working correctly. See
@ref{Nonlinear Least-Squares Tunable Parameters}
for descriptions of the various parameters.
For example, the following code creates an instance of a
Levenberg-Marquardt solver for 100 data points and 3 parameters,
using suggested defaults:

@example
const gsl_multifit_nlinear_type * T 
    = gsl_multifit_nlinear_lm;
gsl_multifit_nlinear_parameters params
    = gsl_multifit_nlinear_default_parameters();
gsl_multifit_nlinear_workspace * w 
    = gsl_multifit_nlinear_alloc (T, &params, 100, 3);
@end example

@noindent
The number of observations @var{n} must be greater than or equal to
parameters @var{p}.

If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of @code{GSL_ENOMEM}.
@end deftypefun

@deftypefun gsl_multifit_nlinear_parameters gsl_multifit_nlinear_default_parameters (void)
This function returns a set of recommended default parameters
for use in solving nonlinear least squares problems. The user
can tune each parameter to improve the performance on their
particular problem, see
@ref{Nonlinear Least-Squares Tunable Parameters}.
@end deftypefun

@deftypefun int gsl_multifit_nlinear_init (const gsl_vector * @var{x}, gsl_multifit_nlinear_fdf * @var{fdf}, gsl_multifit_nlinear_workspace * @var{w})
@deftypefunx int gsl_multifit_nlinear_winit (const gsl_vector * @var{x}, const gsl_vector * @var{wts}, gsl_multifit_nlinear_fdf * @var{fdf}, gsl_multifit_nlinear_workspace * @var{w})
These functions initialize, or reinitialize, an existing workspace @var{w}
to use the system @var{fdf} and the initial guess
@var{x}. See @ref{Nonlinear Least-Squares Function Definition}
for a description of the @var{fdf} structure.

Optionally, a weight vector @var{wts} can be given to perform
a weighted nonlinear regression. Here, the weighting matrix is
@math{W = diag(w_1,w_2,...,w_n)}.
@end deftypefun

@deftypefun void gsl_multifit_nlinear_free (gsl_multifit_nlinear_workspace * @var{w})
This function frees all the memory associated with the workspace @var{w}.
@end deftypefun

@deftypefun {const char *} gsl_multifit_nlinear_name (const gsl_multifit_nlinear_workspace * @var{w})
This function returns a pointer to the name of the solver.  For example,

@example
printf ("w is a '%s' solver\n", 
        gsl_multifit_nlinear_name (w));
@end example

@noindent
would print something like @code{w is a 'lm' solver}.
@end deftypefun

@node Nonlinear Least-Squares Function Definition
@section Providing the Function to be Minimized

The user must provide @math{n} functions of @math{p} variables for the
minimization algorithm to operate on.  In order to allow for
arbitrary parameters the functions are defined by the following data
types:

@deftp {Data Type} gsl_multifit_nlinear_fdf
This data type defines a general system of functions with arbitrary parameters,
the corresponding Jacobian matrix of derivatives, and optionally the
second directional derivative of the functions for geodesic acceleration

@table @code
@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
This function should store the @math{n} components of the vector
@c{$f(x)$}
@math{f(x)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
returning an appropriate error code if the function cannot be computed.

@item int (* df) (const gsl_vector * @var{x}, void * @var{params}, gsl_matrix * @var{J})
This function should store the @var{n}-by-@var{p} matrix result
@c{$J_{ij} = \partial f_i(x) / \partial x_j$}
@math{J_ij = d f_i(x) / d x_j} in @var{J} for argument @var{x} 
and arbitrary parameters @var{params}, returning an appropriate error code if the
matrix cannot be computed. If an analytic Jacobian is unavailable, or too expensive
to compute, this function pointer may be set to NULL, in which
case the Jacobian will be internally computed using finite difference approximations
of the function @var{f}.

@item int (* fvv) (const gsl_vector * @var{x}, const gsl_vector * @var{v}, void * @var{params}, gsl_vector * @var{fvv})
When geodesic acceleration is enabled, this function should store the
@math{n} components of the vector
@math{f_{vv}(x) = \sum_{\alpha\beta} v_{\alpha} v_{\beta} {\partial \over \partial x_{\alpha}} {\partial \over \partial x_{\beta}} f(x)},
representing second directional derivatives of the function to be minimized,
into the output @var{fvv}. The parameter vector is provided in @var{x} and
the velocity vector is provided in @var{v}, both of which have @math{p}
components. The arbitrary parameters are given in @var{params}. If
analytic expressions for @math{f_{vv}(x)} are unavailable or too difficult
to compute, this function pointer may be set to NULL, in which case
@math{f_{vv}(x)} will be computed internally using a finite difference
approximation.

@item size_t n
the number of functions, i.e. the number of components of the
vector @var{f}.

@item size_t p
the number of independent variables, i.e. the number of components of
the vector @var{x}.

@item void * params
a pointer to the arbitrary parameters of the function.

@item size_t nevalf
This does not need to be set by the user. It counts the number of
function evaluations and is initialized by the @code{_init} function.

@item size_t nevaldf
This does not need to be set by the user. It counts the number of
Jacobian evaluations and is initialized by the @code{_init} function.

@item size_t nevalfvv
This does not need to be set by the user. It counts the number of
@math{f_{vv}(x)} evaluations and is initialized by the @code{_init} function.
@end table
@end deftp

@noindent
Note that when fitting a non-linear model against experimental data,
the data is passed to the functions above using the
@var{params} argument and the trial best-fit parameters through the
@var{x} argument.

@node Nonlinear Least-Squares Iteration
@section Iteration

The following functions drive the iteration of each algorithm.  Each
function performs one iteration to update the state of any solver of the
corresponding type.  The same functions work for all solvers so that
different methods can be substituted at runtime without modifications to
the code.

@deftypefun int gsl_multifit_nlinear_iterate (gsl_multifit_nlinear_workspace * @var{w})
This function performs a single iteration of the solver @var{w}.  If
the iteration encounters an unexpected problem then an error code will
be returned.  The solver workspace maintains a current estimate of the
best-fit parameters at all times. 
@end deftypefun

@noindent
The solver workspace @var{w} contains the following entries, which can
be used to track the progress of the solution:

@table @code
@item gsl_vector * x
The current position, length @math{p}.

@item gsl_vector * f
The function residual vector at the current position @math{f(x)}, length
@math{n}.

@item gsl_matrix * J
The Jacobian matrix at the current position @math{J(x)}, size
@math{n}-by-@math{p}.

@item gsl_vector * dx
The difference between the current position and the previous position,
i.e. the last step @math{\delta}, taken as a vector, length @math{p}.

@end table

@noindent
These quantities can be accessed with the following functions,

@deftypefun {gsl_vector *} gsl_multifit_nlinear_position (const gsl_multifit_nlinear_workspace * @var{w})
This function returns the current position @math{x} (i.e. best-fit
parameters) of the solver @var{w}.
@end deftypefun

@deftypefun {gsl_vector *} gsl_multifit_nlinear_residual (const gsl_multifit_nlinear_workspace * @var{w})
This function returns the current residual vector @math{f(x)} of the
solver @var{w}.  For weighted systems, the residual vector includes the
weighting factor @math{\sqrt{W}}.
@end deftypefun

@deftypefun {gsl_matrix *} gsl_multifit_nlinear_jac (const gsl_multifit_nlinear_workspace * @var{w})
This function returns a pointer to the @math{n}-by-@math{p} Jacobian matrix for the
current iteration of the solver @var{w}.
@end deftypefun

@deftypefun size_t gsl_multifit_nlinear_niter (const gsl_multifit_nlinear_workspace * @var{w})
This function returns the number of iterations performed so far.
The iteration counter is updated on each call to the
@code{_iterate} functions above, and reset to 0 in the
@code{_init} functions.
@end deftypefun

@deftypefun int gsl_multifit_nlinear_rcond (double * @var{rcond}, gsl_multifit_nlinear_workspace * @var{w})
This function computes the reciprocal condition number
of the Jacobian at the current position @math{x} and
stores it in @var{rcond}. It is computed by calculating
the eigenvalues @math{\gamma} of @math{J(x)^T J(x)} and setting
@var{rcond} = @math{\sqrt{\gamma_{min} / \gamma_{max}}}. If
the eigenvalue decomposition fails, an error is returned.
@end deftypefun

@node Nonlinear Least-Squares Testing for Convergence
@section Testing for Convergence
@cindex nonlinear fitting, stopping parameters, convergence

A minimization procedure should stop when one of the following conditions is
true:

@itemize @bullet
@item
A minimum has been found to within the user-specified precision.

@item
A user-specified maximum number of iterations has been reached.

@item
An error has occurred.
@end itemize

@noindent
The handling of these conditions is under user control.  The functions
below allow the user to test the current estimate of the best-fit
parameters in several standard ways.

@deftypefun int gsl_multifit_nlinear_test (const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info}, const gsl_multifit_nlinear_workspace * @var{w})
This function tests for convergence of the minimization method
using the following criteria:

@itemize @bullet
@item
Testing for a small step size relative to the current parameter vector
@tex
\beforedisplay
$$
|\delta_i| \le xtol (|x_i| + xtol)
$$
\afterdisplay
@end tex
@ifinfo
@example
|\delta_i| <= xtol (|x_i| + xtol)
@end example
@end ifinfo
for each @math{0 <= i < p}. Each element of the step vector @math{\delta}
is tested individually in case the different parameters have widely
different scales. Adding @var{xtol} to @math{|x_i|} helps the test avoid
breaking down in situations where the true solution value @math{x_i = 0}.
If this test succeeds, @var{info} is set to 1 and the function
returns @code{GSL_SUCCESS}.

A general guideline for selecting the step tolerance is to choose
@math{xtol = 10^{-d}} where @math{d} is the number of accurate
decimal digits desired in the solution @math{x}. See Dennis and
Schnabel for more information.

@item
Testing for a small gradient (@math{g = \nabla \Phi(x) = J^T f})
indicating a local function minimum:
@tex
\beforedisplay
$$
max_i |g_i \times max(x_i, 1)| \le gtol \times max(\Phi(x), 1)
$$
\afterdisplay
@end tex
@ifinfo
@example
||g||_inf <= gtol
@end example
@end ifinfo
This expression tests whether the ratio
@math{(\nabla \Phi)_i x_i / \Phi} is small. Testing this scaled gradient
is a better than @math{\nabla \Phi} alone since it is a dimensionless
quantity and so independent of the scale of the problem. The
@code{max} arguments help ensure the test doesn't break down in
regions where @math{x_i} or @math{\Phi(x)} are close to 0.
If this test succeeds, @var{info} is set to 2 and the function
returns @code{GSL_SUCCESS}.

A general guideline for choosing the gradient tolerance is to set
@code{gtol = GSL_DBL_EPSILON^(1/3)}. See Dennis and Schnabel for
more information.

@end itemize

If none of the tests succeed, @var{info} is set to 0 and the
function returns @code{GSL_CONTINUE}, indicating further iterations
are required.

@end deftypefun

@node Nonlinear Least-Squares High Level Driver
@section High Level Driver

This routine provides a high level wrapper that combines the iteration
and convergence testing for easy use.

@deftypefun int gsl_multifit_nlinear_driver (const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, void (* @var{callback})(const size_t @var{iter}, void * @var{params}, const gsl_multifit_linear_workspace * @var{w}), void * @var{callback_params}, int * @var{info}, gsl_multifit_nlinear_workspace * @var{w})
This function iterates the nonlinear least squares solver @var{w} for a
maximum of @var{maxiter} iterations. After each iteration, the system is
tested for convergence with the error tolerances @var{xtol}, @var{gtol} and @var{ftol}.
Additionally, the user may supply a callback function @var{callback}
which is called after each iteration, so that the user may save or print
relevant quantities for each iteration. The parameter @var{callback_params}
is passed to the @var{callback} function. The parameters @var{callback}
and @var{callback_params} may be set to NULL to disable this feature.
Upon successful convergence, the function returns @code{GSL_SUCCESS}
and sets @var{info} to the reason for convergence (see
@code{gsl_multifit_nlinear_test}). If the function has not
converged after @var{maxiter} iterations, @code{GSL_EMAXITER} is
returned. In rare cases, during an iteration the algorithm may
be unable to find a new acceptable step @math{\delta} to take. In
this case, @code{GSL_ENOPROG} is returned indicating no further
progress can be made. If your problem is having difficulty converging,
see @ref{Nonlinear Least-Squares Troubleshooting} for further guidance.
@end deftypefun

@node Nonlinear Least-Squares Minimization Algorithms Using Derivatives
@section Minimization Algorithms using Derivatives

The minimization algorithms described in this section make use of both
the function and its derivative.  They require an initial guess for the
location of the minimum. There is no absolute guarantee of
convergence---the function must be suitable for this technique and the
initial guess must be sufficiently close to the minimum for it to work.

@comment ============================================================
@cindex Levenberg-Marquardt algorithm

@deffn {Derivative Solver} gsl_multifit_nlinear_lm
@cindex minimization algorithms

This specifies the Levenberg-Marquardt algorithm and is currently
the only nonlinear least squares solver available.

@end deffn

@node Nonlinear Least-Squares Covariance Matrix
@section Covariance matrix of best fit parameters
@cindex best-fit parameters, covariance
@cindex least squares, covariance of best-fit parameters
@cindex covariance matrix, nonlinear fits

@deftypefun int gsl_multifit_nlinear_covar (const gsl_matrix * @var{J}, const double @var{epsrel}, gsl_matrix * @var{covar})
This function computes the covariance matrix of best-fit parameters
using the Jacobian matrix @var{J} and stores it in @var{covar}.
The parameter @var{epsrel} is used to remove linear-dependent columns
when @var{J} is rank deficient.

The covariance matrix is given by,
@tex
\beforedisplay
$$
C = (J^T J)^{-1}
$$
\afterdisplay
@end tex
@ifinfo

@example
covar = (J^T J)^@{-1@}
@end example

@end ifinfo
or in the weighted case,
@tex
\beforedisplay
$$
C = (J^T W J)^{-1}
$$
\afterdisplay
@end tex
@ifinfo

@example
covar = (J^T W J)^@{-1@}
@end example

@end ifinfo
@noindent
and is computed by QR decomposition of J with column-pivoting.  Any
columns of @math{R} which satisfy 
@tex
\beforedisplay
$$
|R_{kk}| \leq epsrel |R_{11}|
$$
\afterdisplay
@end tex
@ifinfo

@example
|R_@{kk@}| <= epsrel |R_@{11@}|
@end example

@end ifinfo
@noindent
are considered linearly-dependent and are excluded from the covariance
matrix (the corresponding rows and columns of the covariance matrix are
set to zero).

If the minimisation uses the weighted least-squares function
@math{f_i = (Y(x, t_i) - y_i) / \sigma_i} then the covariance
matrix above gives the statistical error on the best-fit parameters
resulting from the Gaussian errors @math{\sigma_i} on 
the underlying data @math{y_i}.  This can be verified from the relation 
@math{\delta f = J \delta c} and the fact that the fluctuations in @math{f}
from the data @math{y_i} are normalised by @math{\sigma_i} and 
so satisfy @c{$\langle \delta f \delta f^T \rangle = I$}
@math{<\delta f \delta f^T> = I}.

For an unweighted least-squares function @math{f_i = (Y(x, t_i) -
y_i)} the covariance matrix above should be multiplied by the variance
of the residuals about the best-fit @math{\sigma^2 = \sum (y_i - Y(x,t_i))^2 / (n-p)}
to give the variance-covariance
matrix @math{\sigma^2 C}.  This estimates the statistical error on the
best-fit parameters from the scatter of the underlying data.

For more information about covariance matrices see @ref{Fitting Overview}.
@end deftypefun

@node Nonlinear Least-Squares Large Systems
@section Large Nonlinear Least-Squares Systems

This section describes functions available for solving
large nonlinear least squares systems (ie: @math{n >> p}).
Such systems may be too large to store the full Jacobian
matrix in memory. Additionally, large systems often have
significant sparse structure in the Jacobian which will
not be exploited by the @code{gsl_multifit_nlinear} interface.
The large nonlinear least squares @code{gsl_multilarge_nlinear}
interface requires the user to specify the function
vector @math{f(x)} as usual, but instead of supplying the full
Jacobian, the user must supply a routine to compute
@math{J^T J} and @math{J^T y} for a given arbitrary vector
@math{y} supplied by the library. This way, only the much
smaller @math{p}-by-@math{p} matrix @math{J^T J} is stored
in memory, and the user may efficiently construct this
matrix taking advantange of any sparse structure for their
particular problem.

@noindent
The header file @file{gsl_multilarge_nlinear.h} contains prototypes for the
multidimensional large nonlinear fitting functions and related declarations.

@menu
* Nonlinear Least-Squares Large Systems Overview::
* Nonlinear Least-Squares Large Systems Tunable Parameters::
* Nonlinear Least-Squares Large Systems Initialization::
* Nonlinear Least-Squares Large Systems Function Definition::
* Nonlinear Least-Squares Large Systems Iteration::
* Nonlinear Least-Squares Large Systems Testing for Convergence::
* Nonlinear Least-Squares Large Systems High Level Driver::
* Nonlinear Least-Squares Large Systems Minimization Algorithms Using Derivatives::
@end menu

@node Nonlinear Least-Squares Large Systems Overview
@subsection Overview

@noindent
The algorithm for solving the large nonlinear least squares
problem is the same as before, however the new proposed
step is computed using only the normal equations method:
@tex
\beforedisplay
$$
\left( J^T J + \mu D^T D \right) \delta = -J^T f
$$
\afterdisplay
@end tex
@ifinfo

@example
( J^T J + \mu D^T D ) \delta = -J^T f
@end example

@end ifinfo
The QR approach for computing @math{\delta} is not available,
since the full Jacobian matrix @math{J} is never constructed
explicitly. The user will directly provide the @math{J^T J}
matrix at each step of the iteration.

@node Nonlinear Least-Squares Large Systems Tunable Parameters
@subsection Tunable Parameters

@noindent
The user can tune nearly all aspects of the iteration by using the
@code{gsl_multilarge_nlinear_parameters} structure, which is
defined as follows:

@example
typedef struct
@{
  const gsl_multilarge_nlinear_scale *scale;  /* scaling method */
  int accel;                                  /* use geodesic acceleration */
  double avmax;                               /* max allowed |a|/|v| */
  double h_fvv;                               /* fvv finite difference step */
@} gsl_multilarge_nlinear_parameters;
@end example

@noindent
These parameters operate identically as the @code{gsl_multifit_nlinear}
interface except the linear solver parameter, which is not available
since only the normal equations appraoch is used. See
@ref{Nonlinear Least-Squares Tunable Parameters} for complete
details of each parameter.

@deftypevr {Parameter} {gsl_multilarge_nlinear_scale *} scale

This parameter determines the diagonal scaling matrix @math{D} and
may be selected from the following choices,

@defvr {Default} gsl_multilarge_nlinear_scale_more
@end defvr

@defvr {Option} gsl_multilarge_nlinear_scale_levenberg
@end defvr

@defvr {Option} gsl_multilarge_nlinear_scale_marquardt
@end defvr

@end deftypevr

@deftypevr {Parameter} {int} accel
This parameter toggles the use of geodesic acceleration.
It is set to 0 by default.
@end deftypevr

@deftypevr {Parameter} {double} avmax
This parameter specifies the maximum allowed ratio
of @math{||a|| / ||v||} during the iteration. It is
set to 0.75 by default.
@end deftypevr

@deftypevr {Parameter} {double} h_fvv
This parameter specifies the size of the step when
computing the finite difference approximation to the second
directional derivative @math{f_{vv}(x)}. It is set
to 0.01 by default.
@end deftypevr

@node Nonlinear Least-Squares Large Systems Initialization
@subsection Initializing the Solver

@deftypefun {gsl_multilarge_nlinear_workspace *} gsl_multilarge_nlinear_alloc (const gsl_multilarge_nlinear_type * @var{T}, const gsl_multilarge_nlinear_parameters * @var{params}, const size_t @var{n}, const size_t @var{p})
@tindex gsl_multilarge_nlinear_alloc
@tindex gsl_multilarge_nlinear_type
This function returns a pointer to a newly allocated instance of a
derivative solver of type @var{T} for @var{n} observations and @var{p}
parameters. The @var{params} input specifies a tunable set of
parameters which will affect important details in each iteration
of the Levenberg-Marquardt algorithm. It is recommended to start
with the suggested default parameters (see
@code{gsl_multilarge_nlinear_default_parameters}) and then tune
the parameters once the code is working correctly. See
@ref{Nonlinear Least-Squares Large Systems Tunable Parameters}
for descriptions of the various parameters.
The number of observations @var{n} must be greater than or equal to
parameters @var{p}.

If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of @code{GSL_ENOMEM}.
@end deftypefun

@deftypefun gsl_multilarge_nlinear_parameters gsl_multilarge_nlinear_default_parameters (void)
This function returns a set of recommended default parameters
for use in solving large nonlinear least squares problems. The user
can tune each parameter to improve the performance on their
particular problem, see
@ref{Nonlinear Least-Squares Large Systems Tunable Parameters}.
@end deftypefun

@deftypefun int gsl_multilarge_nlinear_init (const gsl_vector * @var{x}, gsl_multilarge_nlinear_fdf * @var{fdf}, gsl_multilarge_nlinear_workspace * @var{w})
These functions initialize, or reinitialize, an existing workspace @var{w}
to use the system @var{fdf} and the initial guess
@var{x}. See @ref{Nonlinear Least-Squares Large Systems Function Definition}
for a description of the @var{fdf} structure.

Optionally, a weight vector @var{wts} can be given to perform
a weighted nonlinear regression. Here, the weighting matrix is
@math{W = diag(w_1,w_2,...,w_n)}.
@end deftypefun

@deftypefun void gsl_multilarge_nlinear_free (gsl_multilarge_nlinear_workspace * @var{w})
This function frees all the memory associated with the workspace @var{w}.
@end deftypefun

@deftypefun {const char *} gsl_multilarge_nlinear_name (const gsl_multilarge_nlinear_workspace * @var{w})
This function returns a pointer to the name of the solver.
@end deftypefun

@node Nonlinear Least-Squares Large Systems Function Definition
@subsection Providing the Function to be Minimized

The user must provide @math{n} functions of @math{p} variables for the
minimization algorithm to operate on.  In order to allow for
arbitrary parameters the functions are defined by the following data
types:

@deftp {Data Type} gsl_multilarge_nlinear_fdf
This data type defines a general system of functions with arbitrary parameters,
the corresponding normal Jacobian matrix of derivatives @math{J^T J}, and optionally the
second directional derivative of the functions for geodesic acceleration

@table @code
@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
This function should store the @math{n} components of the vector
@c{$f(x)$}
@math{f(x)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
returning an appropriate error code if the function cannot be computed.

@item int (* df) (const gsl_vector * @var{x}, const gsl_vector * @var{y}, void * @var{params}, gsl_vector * @var{JTy}, gsl_matrix * @var{JTJ})
This function should store the @var{p}-by-@var{p} matrix
@math{J(x)^T J(x)} in @var{JTJ} for argument @var{x}
and arbitrary parameters @var{params}, returning an appropriate error code if the
matrix cannot be computed. Additionally, the library will provide
an @math{n}-by-1 vector @var{y}, and the user must store the result
@math{J(x)^T y} in @math{JTy} on output. The
library may occasionally need to compute @math{J^T y} without
needing a full update of @math{J^T J}, in which case the pointer
@var{JTJ} will be set to NULL, so the user should check for this
prior to computing the full matrix.

@item int (* fvv) (const gsl_vector * @var{x}, const gsl_vector * @var{v}, void * @var{params}, gsl_vector * @var{fvv})
When geodesic acceleration is enabled, this function should store the
@math{n} components of the vector
@math{f_{vv}(x) = \sum_{\alpha\beta} v_{\alpha} v_{\beta} {\partial \over \partial x_{\alpha}} {\partial \over \partial x_{\beta}} f(x)},
representing second directional derivatives of the function to be minimized,
into the output @var{fvv}. The parameter vector is provided in @var{x} and
the velocity vector is provided in @var{v}, both of which have @math{p}
components. The arbitrary parameters are given in @var{params}. If
analytic expressions for @math{f_{vv}(x)} are unavailable or too difficult
to compute, this function pointer may be set to NULL, in which case
@math{f_{vv}(x)} will be computed internally using a finite difference
approximation.

@item size_t n
the number of functions, i.e. the number of components of the
vector @var{f}.

@item size_t p
the number of independent variables, i.e. the number of components of
the vector @var{x}.

@item void * params
a pointer to the arbitrary parameters of the function.

@item size_t nevalf
This does not need to be set by the user. It counts the number of
function evaluations and is initialized by the @code{_init} function.

@item size_t nevaldf
This does not need to be set by the user. It counts the number of
evaluations of @math{J^T J} and is initialized by the @code{_init} function.

@item size_t nevaldff
This does not need to be set by the user. It counts the number of
evaluations of @math{J^T y} and is initialized by the @code{_init} function.

@item size_t nevalfvv
This does not need to be set by the user. It counts the number of
@math{f_{vv}(x)} evaluations and is initialized by the @code{_init} function.
@end table
@end deftp

@noindent
Note that when fitting a non-linear model against experimental data,
the data is passed to the functions above using the
@var{params} argument and the trial best-fit parameters through the
@var{x} argument.

@node Nonlinear Least-Squares Large Systems Iteration
@subsection Iteration

The following functions drive the iteration of the large nonlinear
least squares solver.

@deftypefun int gsl_multilarge_nlinear_iterate (gsl_multilarge_nlinear_workspace * @var{w})
This function performs a single iteration of the solver @var{w}.  If
the iteration encounters an unexpected problem then an error code will
be returned.  The solver workspace maintains a current estimate of the
best-fit parameters at all times. 
@end deftypefun

@noindent
The solver workspace @var{w} contains the following entries, which can
be used to track the progress of the solution:

@table @code
@item gsl_vector * x
The current position, length @math{p}.

@item gsl_vector * f
The function residual vector at the current position @math{f(x)}, length
@math{n}.

@item gsl_matrix * JTJ
The normal matrix @math{J^T J} at the current position @math{x}, size
@math{p}-by-@math{p}.

@item gsl_vector * dx
The difference between the current position and the previous position,
i.e. the last step @math{\delta}, taken as a vector, length @math{p}.

@end table

@noindent
These quantities can be accessed with the following functions,

@deftypefun {gsl_vector *} gsl_multilarge_nlinear_position (const gsl_multilarge_nlinear_workspace * @var{w})
This function returns the current position @math{x} (i.e. best-fit
parameters) of the solver @var{w}.
@end deftypefun

@deftypefun {gsl_vector *} gsl_multilarge_nlinear_step (const gsl_multilarge_nlinear_workspace * @var{w})
This function returns the last step taken @math{\delta}.
@end deftypefun

@deftypefun {gsl_vector *} gsl_multilarge_nlinear_residual (const gsl_multilarge_nlinear_workspace * @var{w})
This function returns the current residual vector @math{f(x)} of the
solver @var{w}.  For weighted systems, the residual vector includes the
weighting factor @math{\sqrt{W}}.
@end deftypefun

@deftypefun {gsl_matrix *} gsl_multilarge_nlinear_JTJ (const gsl_multilarge_nlinear_workspace * @var{w})
This function returns a pointer to the @math{p}-by-@math{p} matrix
@math{J^T J} for the current iteration of the solver @var{w}.
@end deftypefun

@deftypefun size_t gsl_multilarge_nlinear_niter (const gsl_multilarge_nlinear_workspace * @var{w})
This function returns the number of iterations performed so far.
The iteration counter is updated on each call to the
@code{_iterate} functions above, and reset to 0 in the
@code{_init} functions.
@end deftypefun

@deftypefun int gsl_multilarge_nlinear_rcond (double * @var{rcond}, gsl_multilarge_nlinear_workspace * @var{w})
This function computes the reciprocal condition number
of the Jacobian @math{J} at the current position @math{x} and
stores it in @var{rcond}. It is computed by calculating
the eigenvalues @math{\gamma} of @math{J(x)^T J(x)} and setting
@var{rcond} = @math{\sqrt{\gamma_{min} / \gamma_{max}}}. If
the eigenvalue decomposition fails, an error is returned.
@end deftypefun

@node Nonlinear Least-Squares Large Systems Testing for Convergence
@subsection Testing for Convergence

@deftypefun int gsl_multilarge_nlinear_test (const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info}, const gsl_multilarge_nlinear_workspace * @var{w})
This function tests for convergence of the minimization method
using the following criteria:

@itemize @bullet
@item
Testing for a small step size relative to the current parameter vector
@tex
\beforedisplay
$$
|\delta_i| \le xtol (|x_i| + xtol)
$$
\afterdisplay
@end tex
@ifinfo
@example
|\delta_i| <= xtol (|x_i| + xtol)
@end example
@end ifinfo
for each @math{0 <= i < p}. Each element of the step vector @math{\delta}
is tested individually in case the different parameters have widely
different scales. Adding @var{xtol} to @math{|x_i|} helps the test avoid
breaking down in situations where the true solution value @math{x_i = 0}.
If this test succeeds, @var{info} is set to 1 and the function
returns @code{GSL_SUCCESS}.

A general guideline for selecting the step tolerance is to choose
@math{xtol = 10^{-d}} where @math{d} is the number of accurate
decimal digits desired in the solution @math{x}. See Dennis and
Schnabel for more information.

@item
Testing for a small gradient (@math{g = \nabla \Phi(x) = J^T f})
indicating a local function minimum:
@tex
\beforedisplay
$$
max_i |g_i \times max(x_i, 1)| \le gtol \times max(\Phi(x), 1)
$$
\afterdisplay
@end tex
@ifinfo
@example
||g||_inf <= gtol
@end example
@end ifinfo
This expression tests whether the ratio
@math{(\nabla \Phi)_i x_i / \Phi} is small. Testing this scaled gradient
is a better than @math{\nabla \Phi} alone since it is a dimensionless
quantity and so independent of the scale of the problem. The
@code{max} arguments help ensure the test doesn't break down in
regions where @math{x_i} or @math{\Phi(x)} are close to 0.
If this test succeeds, @var{info} is set to 2 and the function
returns @code{GSL_SUCCESS}.

A general guideline for choosing the gradient tolerance is to set
@code{gtol = GSL_DBL_EPSILON^(1/3)}. See Dennis and Schnabel for
more information.

@end itemize

If none of the tests succeed, @var{info} is set to 0 and the
function returns @code{GSL_CONTINUE}, indicating further iterations
are required.

@end deftypefun

@node Nonlinear Least-Squares Large Systems High Level Driver
@subsection High Level Driver

This routine provides a high level wrapper that combines the iteration
and convergence testing for easy use.

@deftypefun int gsl_multilarge_nlinear_driver (const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, void (* @var{callback})(const size_t @var{iter}, void * @var{params}, const gsl_multilarge_linear_workspace * @var{w}), void * @var{callback_params}, int * @var{info}, gsl_multilarge_nlinear_workspace * @var{w})
This function iterates the large nonlinear least squares solver @var{w} for a
maximum of @var{maxiter} iterations. After each iteration, the system is
tested for convergence with the error tolerances @var{xtol}, @var{gtol} and @var{ftol}.
Additionally, the user may supply a callback function @var{callback}
which is called after each iteration, so that the user may save or print
relevant quantities for each iteration. The parameter @var{callback_params}
is passed to the @var{callback} function. The parameters @var{callback}
and @var{callback_params} may be set to NULL to disable this feature.
Upon successful convergence, the function returns @code{GSL_SUCCESS}
and sets @var{info} to the reason for convergence (see
@code{gsl_multilarge_nlinear_test}). If the function has not
converged after @var{maxiter} iterations, @code{GSL_EMAXITER} is
returned. In rare cases, during an iteration the algorithm may
be unable to find a new acceptable step @math{\delta} to take. In
this case, @code{GSL_ENOPROG} is returned indicating no further
progress can be made. If your problem is having difficulty converging,
see @ref{Nonlinear Least-Squares Troubleshooting} for further guidance.
@end deftypefun

@node Nonlinear Least-Squares Large Systems Minimization Algorithms Using Derivatives
@subsection Minimization Algorithms Using Derivatives

The minimization algorithms described in this section make use of both
the function and its derivative.  They require an initial guess for the
location of the minimum. There is no absolute guarantee of
convergence---the function must be suitable for this technique and the
initial guess must be sufficiently close to the minimum for it to work.

@cindex Levenberg-Marquardt algorithm

@deffn {Derivative Solver} gsl_multilarge_nlinear_lm
@cindex minimization algorithms

This specifies the Levenberg-Marquardt algorithm and is currently
the only large nonlinear least squares solver available.

@end deffn

@node Nonlinear Least-Squares Troubleshooting
@section Troubleshooting

When developing a code to solve a nonlinear least squares problem,
here are a few considerations to keep in mind.

@enumerate

@item
The most common difficulty is the accurate implementation of the Jacobian
matrix. If the analytic Jacobian is not properly provided to the
solver, this can hinder and many times prevent convergence of the method.
When developing a new nonlinear least squares code, it often helps
to compare the program output with the internally computed finite
difference Jacobian and the user supplied analytic Jacobian. If there
is a large difference in coefficients, it is likely the analytic
Jacobian is incorrectly implemented.

@item
If your code is having difficulty converging, the next thing to
check is the starting point provided to the solver. The methods
of this chapter are local methods, meaning if you provide a starting
point far away from the true minimum, the method may converge to
a local minimum or not converge at all. Sometimes it is possible
to solve a linearized approximation to the nonlinear problem,
and use the linear solution as the starting point to the nonlinear
problem.

@item
If the various parameters of the coefficient vector @math{x}
vary widely in magnitude, then the problem is said to be badly scaled.
The methods of this chapter do attempt to automatically rescale
the elements of @math{x} to have roughly the same order of magnitude,
but in extreme cases this could still cause problems for convergence.
In these cases it is recommended for the user to scale their
parameter vector @math{x} so that each parameter spans roughly the
same range, say @math{[-1,1]}. The solution vector can be backscaled
to recover the original units of the problem.

@end enumerate

@node Nonlinear Least-Squares Examples
@section Examples

The following example programs demonstrate the nonlinear least
squares fitting capabilities.

@menu
* Nonlinear Least-Squares Exponential Fit Example::
* Nonlinear Least-Squares Geodesic Acceleration Example::
* Nonlinear Least-Squares Comparison Example::
@end menu

@node Nonlinear Least-Squares Exponential Fit Example
@subsection Exponential Fitting Example

The following example program fits a weighted exponential model with
background to experimental data, @math{Y = A \exp(-\lambda t) + b}. The
first part of the program sets up the functions @code{expb_f} and
@code{expb_df} to calculate the model and its Jacobian.  The appropriate
fitting function is given by,
@tex
\beforedisplay
$$
f_i = (A \exp(-\lambda t_i) + b) - y_i
$$
\afterdisplay
@end tex
@ifinfo

@example
f_i = (A \exp(-\lambda t_i) + b) - y_i
@end example

@end ifinfo
@noindent
where we have chosen @math{t_i = i}.  The Jacobian matrix @math{J} is
the derivative of these functions with respect to the three parameters
(@math{A}, @math{\lambda}, @math{b}).  It is given by,
@tex
\beforedisplay
$$
J_{ij} = {\partial f_i \over \partial x_j}
$$
\afterdisplay
@end tex
@ifinfo

@example
J_@{ij@} = d f_i / d x_j
@end example

@end ifinfo
@noindent
where @math{x_0 = A}, @math{x_1 = \lambda} and @math{x_2 = b}.
The @math{i}th row of the Jacobian is therefore
@tex
\beforedisplay
$$
J_{i\cdot} = \left(
\matrix{
\exp(-\lambda t_i) & -t_i A \exp(-\lambda t_i) & 1
}
\right)
$$
\afterdisplay
@end tex
@ifinfo

@example
@end example

@end ifinfo

@noindent
The main part of the program sets up a Levenberg-Marquardt solver and
some simulated random data. The data uses the known parameters
(5.0,0.1,1.0) combined with Gaussian noise (standard deviation = 0.1)
over a range of 40 timesteps. The initial guess for the parameters is
chosen as (1.0, 1.0, 0.0). The iteration terminates when the relative
change in x is smaller than @math{10^{-8}}, or when the magnitude of
the gradient falls below @math{10^{-8}}. Here are the results of running
the program:

@smallexample
iter 0: A = 1.0000, lambda = 1.0000, b = 0.0000, cond(J) = 46.1118, |f(x)| = 62.2029
iter 1: A = 1.2196, lambda = 0.3663, b = 0.0436, cond(J) = 19.8763, |f(x)| = 59.8062
iter 2: A = 1.6062, lambda = 0.1506, b = 0.1054, cond(J) = 20.2970, |f(x)| = 53.9039
iter 3: A = 2.4528, lambda = 0.0583, b = 0.2470, cond(J) = 90.3289, |f(x)| = 28.8039
iter 4: A = 2.9723, lambda = 0.0494, b = 0.3727, cond(J) = 184.3828, |f(x)| = 15.3252
iter 5: A = 3.3473, lambda = 0.0477, b = 0.4410, cond(J) = 235.5901, |f(x)| = 10.7511
iter 6: A = 3.6690, lambda = 0.0508, b = 0.4617, cond(J) = 206.1182, |f(x)| = 9.7373
iter 7: A = 3.9907, lambda = 0.0580, b = 0.5433, cond(J) = 147.7071, |f(x)| = 8.7661
iter 8: A = 4.2353, lambda = 0.0731, b = 0.7989, cond(J) = 125.8964, |f(x)| = 7.4299
iter 9: A = 4.6573, lambda = 0.0958, b = 1.0302, cond(J) = 100.5450, |f(x)| = 6.1893
iter 10: A = 5.0138, lambda = 0.1060, b = 1.0329, cond(J) = 94.0404, |f(x)| = 5.4961
iter 11: A = 5.1505, lambda = 0.1103, b = 1.0497, cond(J) = 91.2259, |f(x)| = 5.4552
iter 12: A = 5.1724, lambda = 0.1110, b = 1.0526, cond(J) = 90.7179, |f(x)| = 5.4542
iter 13: A = 5.1737, lambda = 0.1110, b = 1.0528, cond(J) = 90.6803, |f(x)| = 5.4542
iter 14: A = 5.1738, lambda = 0.1110, b = 1.0528, cond(J) = 90.6791, |f(x)| = 5.4542
iter 15: A = 5.1738, lambda = 0.1110, b = 1.0528, cond(J) = 90.6790, |f(x)| = 5.4542
iter 16: A = 5.1738, lambda = 0.1110, b = 1.0528, cond(J) = 90.6790, |f(x)| = 5.4542
summary from method 'trust-region/levenberg-marquardt'
number of iterations: 16
function evaluations: 23
Jacobian evaluations: 17
reason for stopping: small step size
initial |f(x)| = 62.202928
final   |f(x)| = 5.454180
chisq/dof = 0.804002
A      = 5.17379 +/- 0.27938
lambda = 0.11104 +/- 0.00817
b      = 1.05283 +/- 0.05365
status = success
@end smallexample

@noindent
The approximate values of the parameters are found correctly, and the
chi-squared value indicates a good fit (the chi-squared per degree of
freedom is approximately 1).  In this case the errors on the parameters
can be estimated from the square roots of the diagonal elements of the
covariance matrix. If the chi-squared value shows a poor fit (i.e.
@c{$\chi^2/(n-p) \gg 1$}
@math{chi^2/dof >> 1}) then the error estimates obtained from the
covariance matrix will be too small.  In the example program the error estimates
are multiplied by @c{$\sqrt{\chi^2/(n-p)}$}
@math{\sqrt@{\chi^2/dof@}} in this case, a common way of increasing the
errors for a poor fit.  Note that a poor fit will result from the use
of an inappropriate model, and the scaled error estimates may then
be outside the range of validity for Gaussian errors.

@noindent
Additionally, we see that the condition number of @math{J(x)} stays
reasonably small throughout the iteration. This indicates we could
safely switch to the Cholesky solver for speed improvement,
although this particular system is too small to really benefit.

@iftex
@sp 1
@center @image{fit-exp,3.4in}
@end iftex

@example
@verbatiminclude examples/nlfit.c
@end example

@node Nonlinear Least-Squares Geodesic Acceleration Example
@subsection Geodesic Acceleration Example

The following example program minimizes a modified Rosenbrock function,
which is characterized by a narrow canyon with steep walls. The
starting point is selected high on the canyon wall, so the solver
must first find the canyon bottom and then navigate to the minimum.
The problem is solved both with and without using geodesic acceleration
for comparison. The cost function is given by
@tex
\beforedisplay
$$
\eqalign{
\Phi(x) &= {1 \over 2} (f_1^2 + f_2^2) \cr
f_1 &= 100 \left( x_2 - x_1^2 \right) \cr
f_2 &= 1 - x_1
}
$$
\afterdisplay
@end tex
@ifinfo

@example
Phi(x) = 1/2 (f1^2 + f2^2)
f1 = 100 ( x2 - x1^2 )
f2 = 1 - x1
@end example

@end ifinfo
@noindent
The Jacobian matrix is given by
@tex
\beforedisplay
$$
J =
\left(
\matrix{
{\partial f_1 \over \partial x_1} & {\partial f_1 \over \partial x_2} \cr
{\partial f_2 \over \partial x_1} & {\partial f_2 \over \partial x_2}
}
\right) =
\left(
\matrix{
-200 x_1 & 100 \cr
-1 & 0
}
\right)
$$
\afterdisplay
@end tex
@ifinfo

@example
J = [ -200*x1 100 ; -1 0 ]
@end example

@end ifinfo
@noindent
In order to use geodesic acceleration, the user must provide
the second directional derivative of each residual in the
velocity direction,
@math{D_v^2 f_i = \sum_{\alpha\beta} v_{\alpha} v_{\beta} \partial_{\alpha} \partial_{\beta} f_i}.
The velocity vector @math{v} is provided by the solver. For this example,
these derivatives are given by
@tex
\beforedisplay
$$
f_{vv} =
D_v^2
\left(
\matrix{
f_1 \cr
f_2
}
\right) =
\left(
\matrix{
-200 v_1^2 \cr
0
}
\right)
$$
\afterdisplay
@end tex
@ifinfo

@example
fvv = [ -200 v1^2 ; 0 ]
@end example

@end ifinfo
@noindent
The solution of this minimization problem is given by
@tex
\beforedisplay
$$
\eqalign{
x^{*} &= \left(
\matrix{
1 \cr
1
}
\right) \cr
\Phi(x^{*}) &= 0
}
$$
\afterdisplay
@end tex
@ifinfo

@example
x* = [ 1 ; 1 ]
Phi(x*) = 0
@end example

@end ifinfo
@noindent
The program output is shown below.

@smallexample
=== Solving system without acceleration ===
NITER         = 53
NFEV          = 56
NJEV          = 54
NAEV          = 0
initial cost  = 2.250225000000e+04
final cost    = 6.674986031430e-18
final x       = (9.999999974165e-01, 9.999999948328e-01)
final cond(J) = 5.000079979663e+02
=== Solving system with acceleration ===
NITER         = 15
NFEV          = 16
NJEV          = 16
NAEV          = 15
initial cost  = 2.250225000000e+04
final cost    = 1.778587232284e-21
final x       = (9.999999999578e-01, 9.999999999157e-01)
final cond(J) = 5.000079999976e+02
@end smallexample

@noindent
We can see that enabling geodesic acceleration requires less
than a third of the number of Jacobian evaluations in order to locate
the minimum. The path taken by both methods is shown in the
figure below. The contours show the cost function
@math{\Phi(x_1,x_2)}. We see that both methods quickly
find the canyon bottom, but the geodesic acceleration method
navigates along the bottom to the solution with significantly
fewer iterations.

@iftex
@sp 1
@center @image{nlfit2,6in}
@end iftex

@noindent
The program is given below.

@example
@verbatiminclude examples/nlfit2.c
@end example

@node Nonlinear Least-Squares Comparison Example
@subsection Comparing TRS Methods Example

The following program compares all available nonlinear least squares
trust-region subproblem (TRS) methods on the Branin function, a common
optimization test problem. The cost function is given by
@tex
\beforedisplay
$$
\eqalign{
\Phi(x) &= {1 \over 2} (f_1^2 + f_2^2) \cr
f_1 &= x_2 + a_1 x_1^2 + a_2 x_1 + a_3 \cr
f_2 &= \sqrt{a_4} \sqrt{1 + (1 - a_5) \cos{x_1}}
}
$$
\afterdisplay
@end tex
@ifinfo

@example
\Phi(x) &= 1/2 (f_1^2 + f_2^2)
f_1 &= x_2 + a_1 x_1^2 + a_2 x_1 + a_3
f_2 &= sqrt(a_4) sqrt(1 + (1 - a_5) cos(x_1))
@end example

@end ifinfo
with @math{a_1 = -{5.1 \over 4 \pi^2}, a_2 = {5 \over \pi}, a_3 = -6, a_4 = 10, a_5 = {1 \over 8\pi}}.
There are three minima of this function in the range
@math{(x_1,x_2) \in [-5,15] \times [-5,15]}. The program
below uses the starting point @math{(x_1,x_2) = (6,14.5)}
and calculates the solution with all available nonlinear
least squares TRS methods. The program output is shown below.

@smallexample
Method               NITER  NFEV   NJEV   Initial Cost  Final cost   Final cond(J) Final x        
levenberg-marquardt  20     27     21     1.9874e+02    3.9789e-01   1.4844e+08    (-3.14e+00, 1.23e+01)
levenberg-marquardt  27     36     28     1.9874e+02    3.9789e-01   3.4719e+07    (3.14e+00, 2.27e+00)
dogleg               23     64     23     1.9874e+02    3.9789e-01   inf           (3.14e+00, 2.28e+00)
double-dogleg        24     69     24     1.9874e+02    3.9789e-01   3.1929e+07    (3.14e+00, 2.27e+00)
2D-subspace          23     54     24     1.9874e+02    3.9789e-01   5.1824e+07    (3.14e+00, 2.27e+00)
steihaug-toint       34     86     32     1.9874e+02    3.9789e-01   8.8667e+02    (3.14e+00, 2.28e+00)
@end smallexample

@noindent
The first row of output above corresponds to standard Levenberg-Marquardt, while
the second row includes geodesic acceleration. We see that the standard LM method
converges to the minimum at @math{(-\pi,12.275)} and also uses the least number
of iterations and Jacobian evaluations. All other methods converge to the minimum
@math{(\pi,2.275)} and perform similarly in terms of number of Jacobian evaluations.
We see that @math{J} is fairly ill-conditioned
at both minima, indicating that the QR (or SVD) solver is the best choice for this problem.
Since there are only two parameters in this optimization problem, we can easily
visualize the paths taken by each method, which are shown in the figure below.
The figure shows contours of the cost function @math{\Phi(x_1,x_2)} which exhibits
three global minima in the range @math{[-5,15] \times [-5,15]}. The paths taken
by each solver are shown as colored lines.

@iftex
@sp 1
@center @image{nlfit3,6in}
@end iftex

@noindent
The program is given below.

@example
@verbatiminclude examples/nlfit3.c
@end example

@node Nonlinear Least-Squares References and Further Reading
@section References and Further Reading

The @sc{minpack} algorithm is described in the following article,

@itemize @w{}
@item
J.J. Mor@'e, @cite{The Levenberg-Marquardt Algorithm: Implementation and
Theory}, Lecture Notes in Mathematics, v630 (1978), ed G. Watson.
@end itemize

@noindent
The @code{lmniel} algorithm closely follows the following publications,

@itemize @w{}
@item
H. B. Nielsen, ``Damping Parameter in Marquardt's Method'',
IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-1999-05
(1999).

@item
K. Madsen and H. B. Nielsen, ``Introduction to Optimization and Data
Fitting'', IMM Department of Mathematical Modeling, DTU, 2010.
@end itemize

@noindent
The following publications are also relevant to the algorithms described
in this section,

@itemize @w{}
@item
J. E. Dennis and R. B. Schnabel, Numerical Methods for Unconstrained
Optimization and Nonlinear Equations, SIAM, 1996.

@item 
J.J. Mor@'e, B.S. Garbow, K.E. Hillstrom, ``Testing Unconstrained
Optimization Software'', ACM Transactions on Mathematical Software, Vol
7, No 1 (1981), p 17--41.

@item 
H. B. Nielsen, ``UCTP Test Problems for Unconstrained Optimization'',
IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-2000-17
(2000).
@end itemize

