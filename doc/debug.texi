This chapter describes some tips and tricks for debugging numerical
programs which use GSL.

@menu
* Using gdb::                   
* GCC warning options for numerical programs::  
@end menu

@node Using gdb
@section Using gdb
@cindex gdb
@cindex debugging numerical programs
@cindex breakpoints
Any errors reported by the library are routed through the function
@code{gsl_error}. By running your programs under gdb and setting a
breakpoint in this function you can automatically catch any library
errors. You can add a breakpoint for every session by putting

@example
break gsl_error
@end example
@c
@noindent
into your @file{.gdbinit} file in the directory where your program is
started. If the breakpoint catches an error then you can use a backtrace
(@code{bt}) to see the call-tree, and the arguments which possibly
caused the error. By moving into the caller (@code{up}, @code{up}) you
can investigate the values of variable at that point.

Here is an example from the program @code{fft/test_trap}, which contains
the following line,

@example
status = gsl_fft_complex_wavetable_alloc (0, &complex_wavetable);
@end example
@noindent
The function @code{gsl_fft_complex_wavetable_alloc} takes the length of
an FFT as its first argument. When this line is executed an error will
be generated because the length of an FFT is not allowed to be zero.

To debug this problem we start @code{gdb}, using the file
@file{.gdbinit} to define a breakpoint in @code{gsl_error},
@example
bjg|zeke> gdb test_trap
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.16 (i586-debian-linux), Copyright 1996 Free Software Foundation, Inc...
Breakpoint 1 at 0x8050b1e: file error.c, line 14.
@end example
@c
@noindent
When we run the program this breakpoint catches the error and shows the
reason for it. 
@example
(gdb) run
Starting program: /home/bjg/gsl/fft/test_trap 

Breakpoint 1, gsl_error (reason=0x8052b0d "length n must be positive integer", 
    file=0x8052b04 "c_init.c", line=108, gsl_errno=1) at error.c:14
14        if (gsl_error_handler) 
@end example
@c
@noindent
The first argument of @code{gsl_error} is always a string describing the
error. Now we can look at the backtrace to see what caused the problem,
@example
(gdb) bt
#0  gsl_error (reason=0x8052b0d "length n must be positive integer", 
    file=0x8052b04 "c_init.c", line=108, gsl_errno=1) at error.c:14
#1  0x8049376 in gsl_fft_complex_wavetable_alloc (n=0, wavetable=0xbffff778)
    at c_init.c:108
#2  0x8048a00 in main (argc=1, argv=0xbffff9bc) at test_trap.c:94
#3  0x80488be in ___crt_dummy__ ()
@end example
@c
@noindent
We can see that the error was generated in the function
@code{gsl_fft_complex_wavetable_alloc} when it was called with an
argument of @var{n=0}. The original call came from line 94 in the
file @file{test_trap.c}.

By moving up to the level of the original call we can find the line that
caused the error,
@example
(gdb) up
#1  0x8049376 in gsl_fft_complex_wavetable_alloc (n=0, wavetable=0xbffff778)
    at c_init.c:108
108           GSL_ERROR ("length n must be positive integer", GSL_EDOM);
(gdb) up
#2  0x8048a00 in main (argc=1, argv=0xbffff9bc) at test_trap.c:94
94        status = gsl_fft_complex_wavetable_alloc (0, &complex_wavetable);
@end example
@c
@noindent
Thus we have found the line that caused the problem.  From this point we
could also print out the values of other variables such as
@code{complex_wavetable}.

@node GCC warning options for numerical programs
@section GCC warning options for numerical programs
@cindex warning options
@cindex gcc warning options
@cindex -Wall

Writing reliable numerical programs in C requires great
care. Uninitialized variables, conversions to and from integers or from
signed to unsigned integers can all cause hard-to-find problems.  For
many non-numerical programs compiling with @code{gcc}'s warning option
@code{-Wall} provides a good check against common errors. However, for
numerical programs @code{-Wall} is not enough. If you are unconvinced
take a look at this program which contains an error that can occur in
numerical code,

@example
#include <math.h>
#include <stdio.h>

double f (int x) ;

int main ()
@{
  double a = 1.5 ;
  double y = f(a) ;
  printf("a = %g, sqrt(a) = %g\n", a, y) ;  
  return 0 ;
@}

double f(x) @{
  return sqrt(x) ;
@}
@end example
@noindent
This code compiles cleanly with @code{-Wall} but produces some strange
output,

@example
bjg|zeke> gcc -Wall tmp.c -lm
bjg|zeke> ./a.out 
a = 1.5, sqrt(a) = 1
@end example
@noindent
Note that adding @code{-ansi} does not help here, since the program does
not contain any invalid constructs. What is happening is that the
prototype for the function @code{f(int x)} is not consistent with the
function call @code{f(y)}, where @code{y} is a floating point
number. This results in the argument being silently converted to an
integer. This is valid C, but in a numerical program it also likely to
be a programming error so we would like to be warned about it. (If we
genuinely wanted to convert @code{y} to an integer then we could use an
explicit cast, @code{(int)y}).  

Fortunately GCC provides many additional warnings which can alert you to
problems such as this. You just have to remember to use them. Here is a
set of recommended warning options for numerical programs.

@example
gcc -ansi -pedantic -Werror -Wall -W -Wmissing-prototypes
  -Wstrict-prototypes -Wtraditional -Wconversion -Wshadow
  -Wpointer-arith -Wcast-qual -Wcast-align -Wwrite-strings
  -Waggregate-return -fshort-enums -fno-common -Wnested-externs
  -Dinline= -g -O4
@end example
@noindent
It saves time if you to put these options in your @file{Makefile} (for
example, under the target @code{make strict}) or define them as a shell
variable or alias. For details of each option consult the manual
@cite{Using and porting GCC}. The following table gives a brief
explanation of what types of errors these warnings catch.

@table @code
@item -ansi -pedantic 
Use ANSI C, and reject any non-ANSI extensions. These flags help in
writing portable programs that will compile on other systems.
@item -Werror 
Consider warnings to be errors, so that compilation stops. This prevents
warnings from scrolling off the top of the screen and being lost. You
won't be able to compile the program until it is completely
warning-free.
@item -Wall 
This turns on a set of warnings for common programming problems. You
need @code{-Wall}, but it is not enough on its own, as explained above.
@item -O4
The warnings for unitialized variables in @code{-Wall} rely on the
optimizer to analyze the code. If there is no optimization then the
warnings aren't generated.
@item -W 
This turns on some extra warnings not included in @code{-Wall}, such as
missing return values and comparisons between signed and unsigned
integers.
@item -Wmissing-prototypes -Wstrict-prototypes 
Warn if there are any missing or inconsistent prototypes. If your
prototypes are missing then you will never detect problems with
incorrect arguments. If your prototypes are inconsistent then you
already have a problem.
@item -Wtraditional 
This warns about certain constructs that behave differently in
traditional and ANSI C. Whether the traditional or ANSI interpretation
is used might be unpredictable on other compilers. 
@item -Wconversion 
The main use of this option is to warn about conversions from signed to
unsigned integers. For example, @code{unsigned int x = -1}.. If you need
to perform such a conversion you can use an explicit cast.
@item -Wshadow
This warns whenever a local variable shadows another local variable. If
two variables have the same name then it is a potential source of
confusion.
@item -Wpointer-arith -Wcast-qual -Wcast-align 
These options warn if you try to do pointer arithmetic for types which
don't have a size, such as @code{void}, if you remove a @code{const}
cast from a pointer, or if you cast a pointer to a type which has a
different size, causing an invalid alignment.
@item -Wwrite-strings
This option gives string constants a @code{const} qualifier so that it
will be a compile-time error to attempt to overwrite them.
@item -Waggregate-return 
Warn if any functions that return structures or unions are defined or
called. Some older compilers might have problems with such a construct.
@item -fshort-enums 
This option makes the type of @code{enum} as short as possible. Normally
this makes an @code{enum} different from an @code{int}. Consequently any
attempts to assign a pointer-to-int to a pointer-to-enum will generate a
cast-alignment warning.
@item -fno-common
This option prevents global variables being simultaneously defined in
different object files (you get an error at link time). Such a variable
should be defined in one file and referred to in other files with an
@code{extern} declaration.
@item -Wnested-externs 
This warns if an @code{extern} declaration is encountered within an
function.
@item -Dinline= 
The @code{inline} keyword is not part of ANSI C. Thus if you want to use
@code{-ansi} with a program which uses inline functions you can use this
preprocessor definition to remove the @code{inline} keywords.
@item -g 
It always makes sense to put debugging symbols in the executable so that
you can debug it using @code{gdb}. The only effect of debugging symbols
is to increase the size of the file, and you can use the @code{strip}
command to remove them later if necessary.
@end table

For comparison, this is what happens when the test program above is
compiled with these options.

@example
bjg|zeke> gcc -ansi -pedantic -Werror -W -Wall -Wtraditional 
-Wconversion -Wshadow -Wpointer-arith -Wcast-qual -Wcast-align 
-Wwrite-strings -Waggregate-return -Wstrict-prototypes -fshort-enums 
-fno-common -Wmissing-prototypes -Wnested-externs -Dinline= 
-g -O4 tmp.c 
cc1: warnings being treated as errors
tmp.c:7: warning: function declaration isn't a prototype
tmp.c: In function `main':
tmp.c:9: warning: passing arg 1 of `f' as integer rather than floating 
due to prototype
tmp.c: In function `f':
tmp.c:14: warning: type of `x' defaults to `int'
tmp.c:15: warning: passing arg 1 of `sqrt' as floating rather than integer 
due to prototype
make: *** [tmp] Error 1
@end example
@noindent
The error in the prototype is flagged, plus the fact that we should have
defined main as @code{int main (void)} in ANSI C. Clearly there is some
work to do before this program is ready to run.

