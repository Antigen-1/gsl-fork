@comment
@node Coulomb Wave Functions
@section Coulomb Wave Functions
@cindex Coulomb wave functions
@cindex hydrogen atom

@subsection Normalized Hydrogenic Bound States

@deftypefun double gsl_sf_hydrogenicR_1 (double @var{Z}, double @var{r})
@deftypefunx int gsl_sf_hydrogenicR_1_e (double @var{Z}, double @var{r}, gsl_sf_result * @var{result})
These routines compute the lowest-order normalized hydrogenic bound
state radial wavefunction @math{R_1 := 2Z \sqrt(Z) \exp(-Z r)}.
@end deftypefun

@deftypefun double gsl_sf_hydrogenicR (int @var{n}, int @var{l}, double @var{Z}, double @var{r})
@deftypefunx int gsl_sf_hydrogenicR_e (int @var{n}, int @var{l}, double @var{Z}, double @var{r}, gsl_sf_result * @var{result})
These routines compute the normalized hydrogenic bound state
radial wavefunction @math{R_n := norm \exp(-Z r/n) (2Z/n)^l Laguerre[n-l-1,
2l+1, 2Z/n r]} normalization such that @math{\psi(n,l,r) = R_n Y_(lm)}
@end deftypefun

@subsection Coulomb Wave Functions

Coulomb wave functions F_(lam_F)(eta,x), G_(lam_G)(eta,x) and their
derivatives; lam_G := lam_F - k_lam_G

lam_F, lam_G > -0.5
x > 0.0

Conventions of Abramowitz+Stegun.

Because their can be a large dynamic range of values, overflows are
handled gracefully.  If an overflow occurs, GSL_EOVRFLW is signalled and
exponent(s) are returned through exp_F, exp_G. These are such that

  F_L(eta,x)  =  fc[k_L] * exp(exp_F)
  G_L(eta,x)  =  gc[k_L] * exp(exp_G)
  F_L'(eta,x) = fcp[k_L] * exp(exp_F)
  G_L'(eta,x) = gcp[k_L] * exp(exp_G)

@deftypefun int gsl_sf_coulomb_wave_FG (double @var{eta}, double @var{x}, double @var{lam_F}, int @var{k_lam_G}, gsl_sf_result * @var{F}, gsl_sf_result * @var{Fp}, gsl_sf_result * @var{G}, gsl_sf_result * @var{Gp}, double * @var{exp_F}, double * @var{exp_G})
@end deftypefun

@deftypefun int gsl_sf_coulomb_wave_F_array (double @var{lam_min}, int @var{kmax}, double @var{eta}, double @var{x}, double * @var{fc_array}, double * @var{F_exponent})
F_L(eta,x)
@end deftypefun

@deftypefun int gsl_sf_coulomb_wave_FG_array (double @var{lam_min}, int @var{kmax}, double @var{eta}, double @var{x}, double * @var{fc_array}, double * @var{gc_array}, double * @var{F_exponent}, double * @var{G_exponent})
F_L(eta,x), G_L(eta,x)
@end deftypefun

@deftypefun int gsl_sf_coulomb_wave_FGp_e (double @var{lam_min}, int @var{kmax}, double @var{eta}, double @var{x}, gsl_sf_result * @var{fc}, gsl_sf_result * @var{fcp}, gsl_sf_result * @var{gc}, gsl_sf_result * @var{gcp}, double * @var{F_exponent}, double * @var{G_exponent})
F_L(eta,x), G_L(eta,x), F'_L(eta,x), G'_L(eta,x)
@end deftypefun

@deftypefun int gsl_sf_coulomb_wave_sphF_array (double @var{lam_min}, int @var{kmax}, double @var{eta}, double @var{x}, double * @var{fc_array}, double * @var{F_exponent})
Coulomb wave function divided by the argument,
F(xi, eta)/xi.  This is the function which reduces to
spherical Bessel functions in the limit eta->0.
@end deftypefun


@subsection Coulomb Wave Function Normalization Constant

[Abramowitz+Stegun 14.1.8, 14.1.9]

@deftypefun int gsl_sf_coulomb_CL (double @var{L}, double @var{eta}, gsl_sf_result * @var{result})
@deftypefunx int gsl_sf_coulomb_CL_list (double @var{Lmin}, int @var{kmax}, double @var{eta}, double * @var{cl})
@end deftypefun



