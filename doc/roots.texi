@cindex root finding
@cindex zero finding
@cindex finding roots
@cindex finding zeros
@cindex roots

This chapter describes functions for finding the roots of arbitrary
functions. It discusses proper use and possible pitfalls of each
function and gives an overview of the algorithms involved.

@menu
* Root Finding Overview::
* Stopping Criteria::
* Hybrid Algorithms::
* Bisection::
* Newtons Method::
* Secant Method::
* False Position::
@end menu


@node Root Finding Overview
@section Root Finding Overview
@cindex root finding, overview

FIXME: Insert discussion of numerical root finding here.

Declarations for these functions and associated crud is in
@file{gsl_roots.h}; you should include it in your programs which make
use of @sc{gsl} root finding services.


@node Stopping Criteria
@section Stopping Criteria
@cindex root finding, stopping criteria

@sc{gsl} root finding functions (and numerical root finding functions in
general) stop when one of the following conditions is true:

@itemize @bullet
@item
A root has been found to within the user-specified precision (the
@dfn{epsilon}).

@item
A user-specified maximum number of iterations has executed.

@item
An error has occured (for example, Newton's Method has landed on an
extrema).
@end itemize

Whenever you call a @sc{gsl} root finding function, you must specify the
epsilon and the maximum allowed iterations. Every @sc{gsl} root
finding function accepts the following arguments:

@deftypevar double epsilon
The maximum permissible error in @sc{gsl} root finder answers. This must
be greater than (FIXME: or equal to?) @w{@code{DBL_EPSILON}}, specified in the
file @w{@file{float.h}} of the @sc{ansi} C Library, which is the
smallest positive @math{x} such that the relation @math{1 + x \neq 1}
holds true. With a 64-bit @code{double}, this is around @math{10^@{-16@}}
(FIXME: is that correct? should we give this information?)

It is a good idea to not ask for more precision than you need,
especially if your function is costly to evaluate.
@end deftypevar

@deftypevar int max_iterations
The maximum number of iterations a root finder is allowed to perform.
This must be greater than or equal to 1, as performing a negative number
is extremely difficult and not doing any iterations is rather useless.

FIXME: There must be a good rule of thumb for setting the number of
iterations. Do not set @w{@var{max_iterations}} ``way high''; if there
is a problem, you don't want your program chug away on something you'll
never get an answer for.
@end deftypevar


@node Hybrid Algorithms
@section Hybrid Algorithms
@cindex root finding, hybrid algorithms

Often, the best root finding algorithm is one which combines two or more
different methods. The @value{GSL} provides two hybrids: one for use
when the function's first derivative is available, and one for when it
is not.

@deftypefun int gsl_root_have_1der( @w{double * @var{root}}, @w{double (* @var{fn})(double)}, @w{double (* @var{dfn})(double)}, @w{double @var{lower_bound}}, @w{double @var{upper_bound}}, double @w{@var{epsilon}}, int @w{@var{max_iterations}}, double @w{@var{max_step_size}})

Search for a zero using a combination of bisection and Newton's Method.

Arguments:

@table @var
@item root
A place to put the answer.

@item fn
The function on which to search.

@item dfn
@var{fn}'s first derivative.

@item lower_bound
The lower end of the search interval.

@item upper_bound
The upper end of the search interval. 

@item max_step_size
This is the largest step Newton's Method is allowed to take.
@xref{Newtons Method}.
@end table

For an explanation of @var{epsilon} and @w{@var{max_iterations}}, see
@ref{Stopping Criteria}.

On error, @w{@code{gsl_root_have_1der}} can set @w{@code{gsl_error}} to
the following values:

@table @code
@item GSL_EINVAL
One or more of the input arguments is invalid because at least one of
these conditions is true:

@itemize @bullet
@item 
@var{epsilon} is too small or @w{@var{max_iterations}} is less than 1.
@xref{Stopping Criteria}.

@item
@w{@var{lower_bound}} is not less than @w{@var{upper_bound}}.

@item
@var{fn} or @var{dfn} is not working as @w{@code{gsl_root_have_1der}}
expects it to.
@end itemize

@w{@var{*root}} is totally wrong in this case.

@item GSL_ETIMEOUT
The number of iterations executed exceeded @w{@var{max_iterations}}. In
this case, @w{@var{*root}} is of questionable value. It might hold the
location of a root, just not to the requested precision, or it might
hold the number of hairs on Bill Clinton's left butt cheek on the
morning of his twenty-third birthday. You should treat @w{@var{*root}}
as garbage unless you have a very good reason not to.

@item GSL_ERUNAWAY
Newton's Method tried to take a step larger than @w{@var{max_step_size}}. This means that the great mathematician landed on a place where the @var{fn}'s derivative was very small (@math{|dfn(x)| < fn(x) \over max\_step\_size}) and would have been on his was to Never-Never Land.

@end table

@end deftypefun

Use example:

@smallexample
@group
int status;
status = gsl_root_have_1der(sin, cos, (
@end group
@end smallexample


@node Bisection
@section Bisection
@cindex bisection
@cindex root finding, bisection algorithm

ha ha ha


@node Newtons Method
@section Newtons Method
@cindex Newton's Method
@cindex root finding, Newton's Method algorithm

ha ha ha


@node Secant Method
@section Secant Method
@cindex Secant Method
@cindex root finding, Secant Method algorithm

ha h aha


@node False Position
@section False Position
@cindex false position
@cindex root finding, false position algorithm

ha ha ha
