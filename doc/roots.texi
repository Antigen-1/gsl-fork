@cindex root finding
@cindex zero finding
@cindex finding roots
@cindex finding zeros
@cindex roots

This chapter describes functions for finding a root of an arbitrary
one-dimensional function which you provide. 

The @value{GSL} provides two types of root finding functions: high-level
functions which take few arguments and make most decisions for you, and
low-level functions which take many arguments and can be precisely
controlled. For most tasks, the simpler high-level functions will be
sufficient, but the greater degree of control provided by the low-level
functions is sometimes useful.

The header file @w{@file{gsl_roots.h}} contains prototypes for GSL root
finding functions and some other related declarations.

@menu
* Root Finding Overview::
* High Level vs. Low Level::
* High Level Root Finding Functions::
* Low Level Root Finding Functions::
* Root Finder Error Handling::
@end menu


@node Root Finding Overview
@section Root Finding Overview
@cindex root finding, overview

@strong{FIXME: Insert discussion of numerical root finding here.}

GSL root finding functions operate on continous functions only.

While it is not absolutely required that @math{f} have a root within the
search region, numerical root finding functions should not be used
haphazardly to check for the @emph{existence} of roots. There are better
ways to do this! Because it is so easy to create situations where
numerical root finders go awry, it is a bad idea to throw a root finder
at a function you do not know much about.

Note that GSL root finding functions can only search for one root at a
time. While their behavior in cases of multiple roots (several roots in
the search area, not one root of degree greater than 1) is
deterministic, it depends entirely on the algorithm and the function
under search and is rather complex; it is therefore difficult to
predict. @emph{In most cases, no error will be reported if you try to
find a root in an area where there is more than one.}


@node High Level vs. Low Level
@section High Level vs. Low Level
@cindex root finding, high level vs. low level
@cindex root finding, choosing between high level and low level

@strong{FIXME: fill in this section.}

In general, you should use high level functions unless there is a
definite reason to use low level functions.

@node High Level Root Finding Functions
@section High Level Root Finding Functions
@cindex root finding, high level functions

GSL provides three high level root finding functions. They are simple to
use, robust, and adequate for most tasks, but certain situations require
more control than the high level root finding functions provide.

@menu
* Root Finder Exit Values::           How to tell if an error occured and
                                      how the root location is returned
* Providing the Function to Search::  How to provide a function for the
                                      root finder to operate on
* Automatic Control Decisions::       How high level root finders set
                                      parameters such as tolerance
* High Level Functions::              Names and arguments of the high
                                      level root finding functions
@end menu


@node Root Finder Exit Values
@subsection Root Finder Exit Values

Since the return value of GSL root finding functions is reserved for the
error status, you must provide storage for the location of the found
root. 

@deftypevr {Function Argument} {double *} root
@vindex @r{root finding,} root @r{(function argument)}
A pointer to a place for the GSL root finder to store the location of
the found root. This must be a valid pointer; GSL root finders will not
allocate any memory for you.
@end deftypevr

If a GSL root finder succeeds, it will return @code{0} and store the
location of the found root in @w{@code{*root}}.

If a GSL root finder fails, it will return @code{-1} and set
@w{@code{gsl_errno}} to a diagnostic value. @xref{Root Finder Error
Handling}, for a discussion of possible error codes. Nothing useful will
be stored in @w{@code{*root}} if the function failed.


@node Providing the Function to Search
@subsection Providing the Function to Search
@cindex root finding, providing a function to search

You must provide a continous function of one variable for GSL root
finder(s) to operate on, and, sometimes, its first derivative.

Recall that when passing pointers to functions, you give the name of the
function you are passing. For example:

@smallexample
foo = i_take_a_function_pointer(my_function);
@end smallexample

@deftypevr {Function Argument} double {@t{(*} f@t{)(double)}}
@vindex @r{root finding,} f @r{(function argument)}
A pointer to the function whose root you are searching for. It is called
by the root finding function many times during its search. It must be
continous within the region of interest.

Here is an example function which you could pass to a GSL root finder:

@smallexample
@group
double
my_f (double x) @{
   return sin (2 * x) + 2 * cos (x);
@}
@end group
@end smallexample

@end deftypevr

@deftypevr {Function Argument} double {@t{(*} df@t{)(double)}}
@vindex @r{root finding,} df @r{(function argument)}
A pointer to the first derivative of the function whose root you are
searching for.

If we were looking for a root of the function in the previous example,
this is what we would use for @code{df}:

@smallexample
@group
double
my_df (double x) @{
   return 2 * cos (2 * x) - 2 * sin (x);
@} 
@end group
@end smallexample

@end deftypevr

@deftypevr {Function Argument} void {@t{(*} fdf@t{)(double *, double *, double, int, int)}}
A pointer to a function which calculates both the value of the function
under search and the value of its first derivative. Because many terms
of a function and its derivative are the same, it is often faster to use
this method as opposed to providing @math{f(x)} and @math{f'(x)}
separately. However, it is more complicated.

It stores @math{f(x)} in its first argument and @math{f'(x)} in its
second.

Here's an example where @math{f(x) = 2\sin(2x)\cos(x)}:

@smallexample
@group
void
my_fdf (double * y, double * yprime, double x,
        int y_wanted, int yprime_wanted) @{
   double sin2x, cosx;

   sin2x = sin (2 * x);
   cosx = cos (x);

   if (y_wanted)
      *y = 2 * sin2x * cos (x);
   if (yprime_wanted)
      *yprime = 2 * sin2x * -sin (x) + 2 * cos (2 * x) * cosx);
@}
@end group
@end smallexample

@end deftypevr


@node Automatic Control Decisions
@subsection Automatic Control Decisions
@cindex root finding, high level automatic control
@cindex root finding, control (high level)

@strong{FIXME: Coming soon...}


@node High Level Functions
@subsection High Level Functions
@cindex root finding, high level functions
@cindex root finding, hybrid algorithms
@cindex root finding, high level algorithms

@strong{FIXME: Coming soon...}


@node Low Level Root Finding Functions
@section Low Level Root Finding Functions
@cindex root finding, low level functions

GSL provides several low level root finding functions which are more
complicated to use than the high level function but provide more
control. The following
@iftex
subsections
@end iftex
@ifinfo
nodes
@end ifinfo
explain how to use low level root finding functions.

Low level functions return errors and roots and are provided functions
to search in the same manner as the high level functions; see @ref{Root
Finder Exit Values}, and @ref{Providing the Function to Search},
respectively.

@menu
* Search Bounds and Guesses::   How to tell GSL where to search
* Search Stopping Parameters::  How to tell GSL when to stop searching
* Bisection::                   GSL's implementation of bisection
* False Position::              GSL's implementation of false position
* Secant Method::               GSL's implementation of secant method
* Newtons Method::              GSL's implementation of Newton's Method
@end menu


@node Search Bounds and Guesses
@subsection Search Bounds and Guesses
@cindex root finding, search bounds
@cindex root finding, guess(es)

When using low level functions, you can specify and monitor the region
being searched more precisely than you can when using high level
functions. You provide either search bounds or one or two guesses; this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
explains how search bounds and guesses work and how function arguments
control them.

Search bounds are the endpoints of the search interval which is iterated
smaller and smaller until the length of the interval is smaller than the
requested precision or one of the endpoints converges; a guess is an
@math{x} value which is iterated around until the it is within the
desired precision of a root. Two guesses behave similarly to one; there
are just two @math{x} values wandering about instead of one.

In low level functions, these arguments are defined as pointers to
@code{double} rather than simply @code{double}s for two reasons. First,
if the root finding function fails, it is very useful to have the final
values of your iterated variables available to help diagnose why it
failed. Second, it makes it possible to preserve the state of the root
finder, enabling it to be restarted in the same place if needed. A
situation where this could be useful is if the function under search is
very costly to evaluate. 

Note that these arguments must be valid pointers; GSL root finders will
not allocate any memory for you.

@deftypevr {Low Level Function Argument} {double *} lower_bound
@deftypevrx {Low Level Function Argument} {double *} upper_bound
@vindex @r{root finding,} lower_bound @r{(low level function argument)}
@vindex @r{root finding,} upper_bound @r{(low level function argument)}
The initial upper and lower bounds of the interval in which to search for a
root. @w{@code{lower_bound}} must be less than @w{@code{upper_bound}}.

These arguments are modified during execution of the root finding
function; if you need to preserve their initial values, you must make
copies of them. See the third paragraph of this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
for the reasoning behind this behavior.

@end deftypevr

@deftypevr {Low Level Function Argument} {double *} guess
@deftypevrx {Low Level Function Argument} {double *} guess2
@vindex @r{root finding,} guess @r{(low level function argument)}
@vindex @r{root finding,} guess2 @r{(low level function argument)}
One or two initial values for the guess(es) iterated by the root finding
function.

These arguments are modified during execution of the root finding
function; if you need to preserve their initial values, you must make
copies of them. See the third paragraph of this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
for the reasoning behind this behavior.

@end deftypevr


@node Search Stopping Parameters
@subsection Search Stopping Parameters
@cindex root finding, stopping parameters

@strong{FIXME: clean up this section and add documentation for
max_deltay.}

GSL root finding functions (and numerical root finding functions in
general) stop when one of the following conditions is true:

@itemize @bullet
@item
A root has been found to within the user-specified precision.

@item
A user-specified maximum number of iterations has executed.

@item
An error has occured.
@end itemize

Whenever you call a low level GSL root finding function, you must
specify precisely absolute and/or relative tolerances and the maximum
number of iterations.

GSL decides that two values @math{a} and @math{b}. with relative
tolerance @math{R} and absolute tolerance @math{A}, are close enough if
the following relation is true:

@equation
|a - b| \leq R \min(|a|,|b|) + A 
@end equation

You can set either @math{R} or @math{A} to zero, but be aware that GSL
will signal an error if the search moves into an area where both
@math{R} and @math{A} are meaningless; assuming @math{a} and @math{b}
are the endpoints of the region of interest, the following must be true
or GSL will signal an error:

@equation
R \min(|a|,|b|) + A \geq 10 \max(|a|,|b|) \times @{\tt DBL\_EPSILON@} 
@end equation

(We introduce a buffer of @math{10} to protect against roundoff error.)

For the sake of efficient resource use, do not ask for more precision
than you need, especially if your function is costly to evaluate.

@deftypevr {Low Level Function Argument} double abs_epsilon
@vindex @r{root finding,} abs_epsilon @r{(low level function argument)}
The maximum permissible absolute error in GSL root finder answers.

The only static limit on @w{@code{abs_epsilon}} is that it must be
positive; see above for other restrictions, however.
@end deftypevr

@deftypevr {Low Level Function Argument} double rel_epsilon
@vindex @r{root finding,} rel_epsilon @r{(low level function argument)}
The maximum permissible relative error in GSL root finder answers.

@w{@code{rel_epsilon}} must be greater than or equal to @math{@{\tt
DBL\_EPSILON@} \times 10} (note the buffer factor to protect against
roundoff error). See above for additional non-static restrictions.
@end deftypevr

@deftypevr {Function Argument} {unsigned int} max_iterations
@vindex @r{root finding,} max_iterations @r{(function argument)}
The maximum number of iterations a root finder is allowed to perform.
This must be greater than or equal to 1, as performing a negative number
of iterations is extremely difficult and not doing any iterations is
rather useless.

Do not set @w{@code{max_iterations}} too large. If there is a problem,
you want to know about it as soon as possible; you don't want your
program chugging away for many cycles in error.
@end deftypevr

In addition, GSL root finding functions which extrapolate (Newton's
Method, (@ref{Newtons Method}, and Secant Method, @ref{Secant Method})
accept an additional argument:

@deftypevr {Function Argument} double max_step_size
@vindex @r{root finding,} max_step_size @r{(function argument)}
The maximum step size an extrapolating algorithm is allowed to take.
This is to prevents the algorithm from landing on a place where the test
function's derivative is very small and zooming off to infinity or into
a different solution basin.

@strong{FIXME: talk about minimum value for max_step_size.}

For example, if while solving @math{\sin(x) = 0}, @math{x_n} of Newton's
Method (@pxref{Newtons Method}) landed on @math{1.570700000}
(@math{\pi/2 \approx 1.570796327}), then @math{x_@{n+1@}}
would be approximately @math{-10000}, which is definitely not what we
wanted! We want the root finder to recognize this step as ``too big''
and flag an error.

The alarm bell will ring if the following relation in true:

@equation
|@{@{d@} \over @{dx@}@} f(x)| < |@{@{f(x)@} \over @{\tt max\_step\_size@}@}|
@end equation
@noindent
Note that while Secant Method (@pxref{Secant Method}) does not deal with
derivatives directly, when extrapolating it approximates them
numerically.

Do not set @w{@code{max_step_size}} too large; that will defeat its
purpose. In the @math{\sin(x) = 0} example, @math{\pi} would be a good
value for @w{@code{max_step_size}}; any step larger than that would
certainly be headed astray. A good understanding of the problem is
especially important for @w{@code{max_step_size}}.
@end deftypevr


@node Bisection
@subsection Bisection
@cindex bisection algorithm for finding roots
@cindex root finding, bisection algorithm

Bisection is a simple and robust method of finding roots of a function
@math{f}; when its arguments are valid, it cannot fail. However, it is
the slowest algorithm implemented by GSL, and it cannot find roots of
even degree. Its convergence is linear.

One begins the algorithm with an interval which is guaranteed by the
Intermediate Value Theorem to contain a root: where @math{a} and
@math{b} are the endpoints of the interval, @math{f(a)} must differ in
sign from @math{f(b)}. (If you're a bit fuzzy on the Intermediate Value
Theorem, consult any elementary calculus textbook.)

Each iteration, bisection chops its interval in half and discards the
interval which does not contain a root. Once the interval is smaller
than the requested epsilon, iteration stops and the root location is
returned.

@c eps file "roots-bisection.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-bisection.eps}}
@end tex
@quotation
Four iterations of bisection, where @math{a_n} is @math{n}th position of
the beginning of the interval and @math{b_n} is the @math{n}th position
of the end. The midpoint of each interval is also indicated.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
bisection.)
@end ifinfo

@deftypefun int gsl_root_bisection (@w{double * @var{root}}, @w{double (* @var{f})(double)}, @w{double * @var{lower_bound}}, @w{double * @var{upper_bound}}, @w{double @var{rel_epsilon}}, @w{double @var{abs_epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_deltay}})
@findex @r{root finding,} gsl_root_bisection

Search for a zero of @code{f} using bisection. Returns @code{0} if
successful, @code{-1} on error (@pxref{Root Finder Error
Handling}).

@code{f(*lower_bound)} and @code{f(*upper_bound)} must differ in sign.

Arguments:
@table @code
@item root
A place to store the root location once it is found. @xref{Root Finder
Exit Values}.
@item f
A user defined function to search for a root. @xref{Providing the
Function to Search}.
@item lower_bound@r{, }upper_bound
Lower and upper bounds of the interval to search. @xref{Search Bounds
and Guesses}.
@item rel_epsilon@r{, }abs_epsilon
Maximum permitted relative and absolute error. @xref{Search Stopping
Parameters}.
@item max_iterations
The maximum allowed number of iterations. @xref{Search Stopping
Parameters}.
@item max_deltay
The maximum allowed difference between @w{@code{f(*lower_bound)}} and
@w{@code{f(*upper_bound)}}. @xref{Search Stopping Parameters}.
@end table

@end deftypefun


@node False Position
@subsection False Position
@cindex false position algorithm for finding roots
@cindex root finding, false position algorithm

False position is a robust method of finding roots of a function
@math{f}; if its arguments are valid, it cannot fail. However, it cannot
find roots of even degree. Its convergence is linear, but it is usually
faster than bisection.

One begins the algorithm with an interval which is guaranteed by the
Intermediate Value Theorem to contain a root: where @math{a} and
@math{b} are the endpoints of the interval, @math{f(a)} must differ in
sign from @math{f(b)}. (If you're a bit fuzzy on the Intermediate Value
Theorem, consult any elementary calculus textbook.)

Each iteration, false position draws a line between @math{f(a)} and
@math{f(b)}; the @math{x} position where this line crosses the @math{x}
axis is where the interval is split. The part of the interval which
contains the root is taken to be the new interval, and the process is
repeated until one of the following is true:

@equation
|a - b| \leq \varepsilon
@end equation
@equation
a_n - a_@{n-1@} = 0 \;\;\;@{\rm and@}\;\;\; |b_n - b_@{n-1@}| \leq \varepsilon
@end equation
@equation
b_n - b_@{n-1@} = 0 \;\;\;@{\rm and@}\;\;\;|a_n - a_@{n-1@}| \leq \varepsilon
@end equation

@c eps file "roots-false-position.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-false-position.eps}}
@end tex
@quotation
Several iterations of false position, where @math{a_n} is @math{n}th
position of the beginning of the interval and @math{b_n} is the
@math{n}th position of the end.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
false position.)
@end ifinfo

@deftypefun int gsl_root_falsepos (@w{double * @var{root}}, @w{double (* @var{f})(double)}, @w{double * @var{lower_bound}}, @w{double * @var{upper_bound}}, @w{double @var{rel_epsilon}}, @w{double @var{abs_epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_deltay}})
@findex @r{root finding,} gsl_root_falsepos

Search for a zero of @code{f} using false position. Return @code{0} if
successful, @code{-1} on error (@pxref{Root Finder Error Handling}.

@code{f(*lower_bound)} and @code{f(*upper_bound)} must differ in sign.

Arguments:
@table @code
@item root
A place to store the root location once it is found. @xref{Root Finder
Exit Values}.
@item f
A user defined function to search for a root. @xref{Providing the
Function to Search}.
@item lower_bound@r{, }upper_bound
Lower and upper bounds of the interval to search. @xref{Search Bounds
and Guesses}.
@item rel_epsilon@r{, }abs_epsilon
Maximum permitted relative and absolute error. @xref{Search Stopping
Parameters}.
@item max_iterations
The maximum allowed number of iterations. @xref{Search Stopping
Parameters}.
@item max_deltay
The maximum allowed difference between @w{@code{f(*lower_bound)}} and
@w{@code{f(*upper_bound)}}. @xref{Search Stopping Parameters}.
@end table

@end deftypefun


@node Secant Method
@subsection Secant Method
@cindex Secant Method algorithm for finding roots
@cindex root finding, Secant Method algorithm

Secant Method is a somewhat fragile method of finding roots. On single
roots, its convergence is of order @math{(1 + \sqrt 5)/2} (approximately
@math{1.62}). On multiple roots, converges linearly.

One begins the algorithm with two guesses for the value of the root,
@math{g_0} and @math{g_1}. The root may be either inside or outside the
interval defined by @math{g_0} and @math{g_1}.

Each iteration, Secant Method draws a line through @math{f(g_@{n - 1@})}
and @math{f(g_n)}. The @math{x} position where this line crosses the
@math{x} axis becomes @math{g_@{n + 1@}}. @math{g_@{n - 1@}} is
discarded, @math{n} is incremented, and the process is repeated until:

@equation
|g_n - g_@{n-1@}| \leq \varepsilon
@end equation

Note that @math{g_@{n + 1@}} may be obtained by either interpolation or
extrapolation and that Secant Method cannot fail during interpolation.

Secant Method breaks in the same situations that Newton's Method does,
though it is somewhat less sensitive. (@xref{Newtons Method}.)

@c eps file "roots-secant-method.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-secant-method.eps}}
@end tex
@quotation
Several iterations of Secant Method, where @math{g_n} is the @math{n}th
guess.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
Secant Method.)
@end ifinfo

@deftypefun int gsl_root_secant (@w{double * @var{root}}, @w{double (* @var{f})(double)}, @w{double * @var{guess}}, @w{double * @var{guess2}}, @w{double @var{epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_step_size}})
@findex @r{root finding,} gsl_root_secant

Search for a zero of @code{f} using Secant Method, with @code{*guess}
and @code{*guess2} being the guesses.

arguments. @xref{Root Finder Error Handling}, for a discussion of possible
error codes.

@end deftypefun


@node Newtons Method
@subsection Newtons Method
@cindex Newton's Method algorithm for finding roots
@cindex root finding, Newton's Method algorithm

Newton's Method is a fast but somewhat fragile method of finding roots.
On single roots, it converges quadratically; however, on multiple roots
it converges linearly.

One begins the algorithm with one guess @math{g} for the value of the
root. Each iteration, Newton's Method draws a line tangent to @math{f}
(the function whose root you are searching for); the @math{x} position
where this line crosses the @math{x} axis becomes the new @math{g}. The
process is repeated until:

@equation
|g_n - g_@{n-1@}| \leq \varepsilon
@end equation

@strong{FIXME: talk about ways to break Newton.}

This algorithm is entirely unrelated to Newt Gingrich.

@c eps file "roots-newtons-method.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-newtons-method.eps}}
@end tex
@quotation
Several iterations of Newton's Method, where @math{g_n} is the
@math{n}th guess.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
Newton's Method.)
@end ifinfo

@deftypefun int gsl_root_newton (@w{double * @var{root}}, @w{void (* @var{fdf})(double *, double *, double, int, int)}, @w{double * @var{guess}}, @w{double @var{epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_step_size}})
@findex @r{root finding,} gsl_root_newton

Search for a zero of @code{f} using Newton's Method, with @code{*guess}
being the guess.

@xref{Root Finder Error Handling}, for a discussion of possible
error codes.

@end deftypefun

@node Root Finder Error Handling
@section Root Finder Error Handling
@cindex root finding, errors

When successful, GSL root finding functions return @code{0}; on error,
they return @code{-1} and set the global variable @w{@code{gsl_errno}}
to a diagnostic value. (@xref{Error handling in GSL}, for a general
discussion of GSL error handling.)

When using low-level functions, you can examine @code{*guess},
@code{*guess2}, @w{@code{*lower_bound}}, or @w{@code{*upper_bound}}
(@pxref{Search Bounds and Guesses}) to help determine why a root finder
failed.

@set llo @i{[Low Level Only]}
GSL root finders can set @w{@code{gsl_errno}} to the following macros.
Some errors can only be encountered by low level functions; they are
marked by @value{llo}.

@table @code
@item GSL_EINVAL
One or more of the input arguments is invalid because at least one of
these conditions is true:

@itemize @bullet
@item 
@value{llo} @w{@code{max_iterations}} is equal to 0. @xref{Search
Stopping Parameters}.

@item
The lower bound of the search interval is not less than the upper bound.

@item
You supplied a pointer argument which was null.

@item
@math{f(lower\_bound)} and @math{f(upper\_bound)} do not differ in sign,
and the function that you are using requires that they do.

@end itemize

@item GSL_EBADFUNC
The function under search (or its derivative) did not return a valid
number when it was called by GSL. (Instead, it returned @code{NAN} or
@code{INF}.)

@item GSL_ERUNAWAY
@value{llo} A root finder tried to take a step larger than
@w{@code{max_step_size}} (@pxref{Search Stopping Parameters}). This
happens when an extrapolating algorithm lands on a place where the
derivative is too small.

@item GSL_EMAXITER
The number of iterations executed exceeded @w{@code{max_iterations}}
(@pxref{Search Stopping Parameters}).

@item GSL_EBADTOL
@value{llo} You specified an invalid error tolerance in one or more of
the following ways (@pxref{Search Stopping Parameters}):

@itemize @bullet
@item
@w{@code{rel_epsilon}} was too small.

@item
@w{@code{rel_epsilon}} and @w{@code{abs_epsilon}} were both zero.

@item
@w{@code{rel_epsilon}} was zero, and the search converged to a place too
far from zero for @w{@code{abs_epsilon}} to be useful.

@item
@w{@code{abs_epsilon}} was zero, and the search converged to a place too
close to zero for @w{@code{rel_epsilon}} to be useful.

@item
@strong{FIXME: add stuff for delta.}
@end itemize
   
@item GSL_EZERODIV
@value{llo} GSL caught itself before dividing by zero. This most often
happens when Newton's Method (@pxref{Newtons Method}) or Secant Method
(@pxref{Secant Method}) lands on an extremum.
@end table


