@cindex root finding
@cindex zero finding
@cindex finding roots
@cindex finding zeros
@cindex roots
@cindex solving a non-linear equation
@cindex non-linear equation, solutions of

This chapter describes functions for finding a root of an arbitrary
one-dimensional function which you provide.  The header file
@file{gsl_roots.h} contains prototypes for the root finding functions
and related declarations.

@menu
* Root Finding Overview::       
* Root Finding Caveats::        
* Initializing the solver::     
* Providing the function to solve::  
* Search Bounds and Guesses::   
* Search Stopping Parameters::  
@end menu

@node Root Finding Overview
@section Root Finding Overview
@cindex root finding, overview

Root finding algorithms can be divided into two classes, @dfn{root
bracketing} and @dfn{root polishing}.

Algorithms which proceed by bracketing a root are guaranteed to
converge. Bracketing algorithms begin with a bounded region known to
contain a root. The size of this bounded region is reduced, iteratively,
until it encloses the root to a desired tolerance. This provides a
rigorous error estimate for the location of the root.

Algorithms using the technique of @dfn{root polishing} attempt to
improve an initial guess to the root. These algorithms converge only if
started ``close enough'' to a root, and sacrifice a rigorous error bound
for speed. By approximating the behavior of a function in the vicinity
of a root they attempt to find a higher order improvement of an initial
guess. When the behavior of the function is compatible with the
algorithm and a good initial guess is available a polishing algorithm
can provide rapid convergence.

In GSL both types of algorithm are available in a similar framework.

@itemize @bullet
@item
initialize solver state, @var{s}, for algorithm @var{T}

@item
update @var{s} using @var{T}

@item
test new estimate from @var{s}, and repeat update unless converged
@end itemize

@noindent
The state for bracketing solvers is held in a @code{gsl_root_fsolver}
struct. The updating procedure uses only function evaluations (not
derivatives).

The state for root polishing solvers is held in a
@code{gsl_root_fdfsolver} struct. The updates require both the function
and its derivative (hence the name @code{fdf}) to be supplied by the
user.

@node Root Finding Caveats
@section Root Finding Caveats
@cindex root finding, caveats

Note that root finding functions can only search for one root at a time.
When there are several roots in the search area, the first root to be
found will be returned; however it is difficult to predict which of the
roots this will be. @emph{In most cases, no error will be reported if
you try to find a root in an area where there is more than one.}

Care must be taken when a function may have a root of second-order or
higher multiplicity (such as 
@c{$f(x) = (x-x_0)^2$}
@math{f(x) = (x-x_0)^2} or 
@c{$f(x) = (x-x_0)^3$}
@math{f(x) = (x-x_0)^3}).  
Routines which maintain a strict bound on the root should not have
problems with odd-multiplicity roots (e.g. cubic, quintic, @dots{}),
since they make use only of the occurrence zero-crossings and not the
behavior of the function. However it is impossible to use these routines
for even-multiplicity roots because they require a bound on the initial
root which guarantees a zero-crossing (below zero at one end of the
bound and above zero at the other end). Roots with even-multiplicity do
not cross zero, but only touch it instantaneously. In general these
functions need to be approached on a case-by-case basis using knowledge
of the algorithm to be used. Root polishing algorithms generally work
with higher multiplicity roots but with a reduced rate of convergence.

While it is not absolutely required that @math{f} have a root within the
search region, numerical root finding functions should not be used
haphazardly to check for the @emph{existence} of roots. There are better
ways to do this! Because it is so easy to create situations where
numerical root finders go awry, it is a bad idea to throw a root finder
at a function you do not know much about. In general it is best to
examine the function visually by plotting before searching for a root.

@node Initializing the solver
@section Initializing the solver

@deftypefun {gsl_root_fsolver *} gsl_root_fsolver_alloc (const gsl_root_fsolver_type * @var{T}, gsl_function * @var{f}, gsl_interval @var{x})
This function returns a pointer to a a newly allocated instance of a
solver of type @var{T} for the function @var{f}, with an initial bracket
on the root of @var{x}.

If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of @code{GSL_ENOMEM}.
@end deftypefun

@deftypefun {gsl_root_fdfsolver *} gsl_root_fdfsolver_alloc (const gsl_root_fdfsolver_type * @var{T}, gsl_function_fdf * @var{fdf}, double @var{root})
This function returns a pointer to a a newly allocated instance of a
solver of type @var{T} for the function @var{f}, with an initial guess
for the root of @var{root}.

If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of @code{GSL_ENOMEM}.
@end deftypefun

@node Providing the function to solve
@section Providing the function to solve
@cindex root finding, providing a function to solve

You must provide a continous function of one variable for the root
finder(s) to operate on, and, sometimes, its first derivative.

@deftp {Data Type} gsl_function 
A pointer to the function whose root you are searching for. It is called
by the root finding function many times during its search. It must be
continous within the region of interest.

Here is an example function for

@tex
\beforedisplay
$$
f(x) = a x^2 + b x + c
$$
\afterdisplay
@end tex
@ifinfo
@example
f(x) = a x^2 + b x + c
@end example
@end ifinfo

@noindent
with @math{a = 3}, @math{b = 2}, @math{c = 1} which you could pass to a
root finder:

@smallexample
struct my_f_params @{ double a ; double b ; double c ; @} ;

double
my_f (double x, void * p) @{
   struct my_f_params * params = *(struct my_f_params *)p ;
   double a = (params->a) ;
   double b = (params->b) ;
   double c = (params->c) ;

   return  (a * x + b) * x + c ;
@}

gsl_function F ;
struct my_f_params params = @{ 3.0, 2.0, 1.0 @};

F.function = &my_f ;
F.params = &params ;
@end smallexample
@end deftp

@deftp {Data Type} gsl_function_fdf
A pointer to a function which calculates both the value of the function
and its first derivative. 

Because many terms of a function and its derivative are often the same,
it can be much faster to use this method as opposed to calculating
@math{f(x)} and @math{f'(x)} separately. It stores @math{f(x)} in its
first argument and @math{f'(x)} in its second.

Here's an example where 
@c{$f(x) = \exp(2x)$}
@math{f(x) = 2\exp(2x)}:

@smallexample
@group

double
my_f (double x, void * params)
@{
   return exp (2 * x);
@}

double
my_df (double x, void * params)
@{
   return 2 * exp (2 * x);
@}

void
my_fdf (double x, void * params, double * f, double * df)
@{
   double t = exp (2 * x) ;

   *f = t;
   *df = 2 * t;
@}

gsl_function_fdf FDF ;

FDF.f = &my_f ;
FDF.df = &my_df ;
FDF.fdf = &my_fdf ;
FDF.params = 0 ;
@end group
@end smallexample

@end deftp

@node Search Bounds and Guesses
@section Search Bounds and Guesses
@cindex root finding, search bounds
@cindex root finding, guess(es)

You provide either search bounds or an initial guess; this section
explains how search bounds and guesses work and how function arguments
control them.

A guess is simply an @math{x} value which is iterated until it is within
the desired precision of a root. It takes the form of a @code{double}.

Search bounds are the endpoints of a interval which is iterated smaller
and smaller until the length of the interval is smaller than the
requested precision. The interval is defined by the following struct,

@deftp {Data Type} {gsl_interval}
This is a structure that holds an interval (@var{lower}, @var{upper}) on
the real line.

@table @code
@item double lower
the lower limit of the interval 
@item double upper
the upper limit of the interval
@end table

Whether the endpoints are included in the interval or not depends on the
context in which the interval is used. Thus, the structure could also
describe the interval [@var{lower}, @var{upper}].
@end deftp

@deftypefun int gsl_root_fsolver_set (gsl_root_fsolver * @var{s}, gsl_function * @var{f}, gsl_interval @var{x})
@deftypefunx int gsl_root_fdfsolver_set (gsl_root_fdfsolver * @var{s}, gsl_function_fdf * @var{fdf}, double @var{root})
@end deftypefun

@deftypefun void gsl_root_fsolver_free (gsl_root_fsolver * @var{s})
@deftypefunx void gsl_root_fdfsolver_free (gsl_root_fdfsolver * @var{s})
@end deftypefun

@deftypefun {const char *} gsl_root_fsolver_name (const gsl_root_fsolver * @var{s})
@deftypefunx {const char *} gsl_root_fdfsolver_name (const gsl_root_fdfsolver * @var{s})
@end deftypefun

@deftypefun int gsl_root_fsolver_iterate (gsl_root_fsolver * @var{s})
@deftypefunx int gsl_root_fdfsolver_iterate (gsl_root_fdfsolver * @var{s})
@end deftypefun

@deftypefun double gsl_root_fsolver_root (const gsl_root_fsolver * @var{s})
@deftypefunx double gsl_root_fdfsolver_root (const gsl_root_fdfsolver * @var{s})
@end deftypefun

@deftypefun gsl_interval gsl_root_fsolver_interval (const gsl_root_fsolver * @var{s})
@end deftypefun



@node Search Stopping Parameters
@section Search Stopping Parameters
@cindex root finding, stopping parameters

The root finding functions (and numerical root finding functions in
general) stop when one of the following conditions is true:

@itemize @bullet
@item
A root has been found to within the user-specified precision.

@item
A user-specified maximum number of iterations has executed.

@item
An error has occured.
@end itemize

Whenever you call a low level root finding function, you must specify
precisely absolute and/or relative tolerances and the maximum number of
iterations.

The stopping criterion decides that two values @math{a} and
@math{b}. with relative tolerance @math{R} and absolute tolerance
@math{A}, are close enough if the following relation is true:

@tex
\beforedisplay
$$
|a - b| \leq R \min(|a|,|b|) + A 
$$
\afterdisplay
@end tex
@ifinfo
@example
|a - b| <= R min(|a|,|b|) + A 
@end example
@end ifinfo
@noindent
You can set either @math{R} or @math{A} to zero, but be aware that the
library will signal an error if the search moves into an area where both
@math{R} and @math{A} are meaningless; assuming @math{a} and @math{b}
are the endpoints of the region of interest, the following must be true
an error will be returned:

@tex
\beforedisplay
$$
R \min(|a|,|b|) + A \geq 10 \max(|a|,|b|) \times {\tt DBL\_EPSILON} 
$$
\afterdisplay
@end tex
@ifinfo
@example
R min(|a|,|b|) + A >= 10 max(|a|,|b|) DBL_EPSILON 
@end example
@end ifinfo
@noindent
(We introduce a buffer of @math{10} to protect against roundoff error.)

For the sake of efficient resource use, do not ask for more precision
than you need, especially if your function is costly to evaluate.

@deftypevr {Low Level Function Argument} double abs_epsilon
@vindex @r{root finding,} abs_epsilon @r{(low level function argument)}
The maximum permissible absolute error in root finder answers.

The only static limit on @code{abs_epsilon} is that it must be
positive; see above for other restrictions, however.
@end deftypevr

@deftypevr {Low Level Function Argument} double rel_epsilon
@vindex @r{root finding,} rel_epsilon @r{(low level function argument)}
The maximum permissible relative error in root finder answers.

@code{rel_epsilon} must be greater than or equal to 
@c{${\tt DBL\_EPSILON} \times 10$} 
@math{DBL_EPSILON \times 10}
(note the buffer factor to protect against roundoff error). See above
for additional non-static restrictions.
@end deftypevr

@deftypevr {Function Argument} {unsigned int} max_iterations
@vindex @r{root finding,} max_iterations @r{(function argument)}
The maximum number of iterations a root finder is allowed to perform.
This must be greater than or equal to 1, as performing a negative number
of iterations is extremely difficult and not doing any iterations is
rather useless.

Do not set @code{max_iterations} too large. If there is a problem,
you want to know about it as soon as possible; you don't want your
program chugging away for many cycles in error.
@end deftypevr


@deftypefun int gsl_root_test_interval (gsl_interval @var{x}, double @var{rel_epsilon}, double @var{abs_epsilon})
@end deftypefun

@deftypefun int gsl_root_test_residual (double @var{f}, double @var{abs_epsilon})
@end deftypefun

@deftypefun int gsl_root_test_delta (double @var{x1}, double @var{x0}, double @var{rel_epsilon}, double @var{abs_epsilon})
@end deftypefun


















