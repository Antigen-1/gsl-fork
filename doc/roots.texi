@cindex root finding
@cindex zero finding
@cindex finding roots
@cindex finding zeros
@cindex roots

This chapter describes functions for finding the roots of arbitrary
functions. It discusses proper use and possible pitfalls of each
function and gives an overview of the algorithms involved.

@menu
* Root Finding Overview::
* Calling GSL Root Finding Functions::
* Hybrid Algorithms::
* Bisection::
* Newtons Method::
* Secant Method::
* False Position::
@end menu


@node Root Finding Overview
@section Root Finding Overview
@cindex root finding, overview

FIXME: Insert discussion of numerical root finding here.

While it is not absolutely required that @math{f} have a root within the
search region, numerical root finding functions should not be used
haphazardly to check for the @emph{existence} of roots. There are better
ways to do this! Since it is easy to create situations where numerical
root finders go awry, it is a bad idea to throw a root finder at a
function you do not know much about.

Note that GSL root finding functions can only search for one root at a
time.


@node Calling GSL Root Finding Functions
@section Calling GSL Root Finding Functions
@cindex root finding, function arguments
@cindex root finding, calling functions

All GSL root finding functions follow the same general template:

@deftypefun double gsl_root_template (@var{f}, [@var{df},] [@w{@var{lower_bound}}, @w{@var{upper_bound}}, | @var{guess}, [@var{guess2},]], @var{epsilon}, @w{@var{max_iterations}} [, @w{@var{max_step_size}}])
@end deftypefun

The following 
@iftex
subsections
@end iftex
@ifinfo
nodes
@end ifinfo
explain how to use GSL root finding functions in your code, the specific
meaning of each argument, and which error codes are possible.

@menu
* Using the Root Finding Functions::   Proper @code{#include}ing and linking
* Root Finder Return Values::          What GSL root finders return and when
* Providing the Function to Search::   @code{f}, @code{df}
* Search Bounds and Guesses::          @code{lower_bound}, @code{upper_bound}, @code{guess},
                                         @code{guess2}
* Search Stopping Parameters::         @code{epsilon}, @code{max_iterations},
                                         @code{max_step_size}
* Root Finder Error Codes::            Error codes GSL root finding functions
                                         can return
@end menu


@node Using the Root Finding Functions
@subsection Using the Root Finding Functions
@cindex root finding, include files
@cindex root finding, linking
@cindex linking root finding functions
@cindex include files for root finding functions

Declarations of GSL root finding functions and associated crud is in
@file{gsl_roots.h}; you should include it in your programs which make
use of GSL root finding services.

The library @file{libgslroots.*} contains code for the GSL root finding
functions; use @samp{-lgslroots} on the command line to link it in.
Alternately, you could just link the main GSL library (@file{libgsl.*},
@samp{-lgsl}); this might be the better way to go if you are using other
GSL functions as well. (FIXME: How correct is this?)

Once you've @code{#include}d and linked, you're all set. Call GSL root
finding functions as they're described in this manual.

FIXME: Anything else?


@node Root Finder Return Values
@subsection Root Finder Return Values

Depending on whether a GSL root finding function succeeded or failed, it
will return the location of a root or the special value @code{NAN} (IEEE
Not-A-Number).

If the function succeeded in finding a root to the desired precision in
the specified number of iterations, it will return the location of that
root.

If the function failed, it will return @code{NAN} (defined in the ANSI
standard header file @file{math.h} FIXME: Is this true?) and set
@w{@code{gsl_errno}} to a diagnostic value. @xref{Root Finder Error
Codes}, for a list of possible @w{@code{gsl_errno}} values and their
meanings.

The final values of @w{@code{lower_bound}}, @w{@code{upper_bound}},
@code{guess}, and/or @code{guess2} are very often useful for diagnosing
why a root finder failed. @xref{Search Bounds and Guesses}.


@node Providing the Function to Search
@subsection Providing the Function to Search
@vindex @r{root finding,} f @r{(function argument)}
@vindex @r{root finding,} df @r{(function argument)}

You must provide a continous function of one variable for the GSL root
finder(s) to operate on, and, occasionally, its first derivative.

@deftypevr {Function Argument} double {@t{(*} f@t{)(double)}}
A pointer to the function whose root you are searching for. It is called
by the root finding function many times during its search. It must be
continous within the search region (@pxref{Search Bounds and Guesses}).

Here is an example function which you could pass to a GSL root finder:

@smallexample
@group
double
my_function (double x) @{
   double y;
   
   y = sin (2 * x) + 2 * cos (x);
   return (y);
@}
@end group
@end smallexample

Recall that when passing pointers to functions, you give the name of the
function you are passing. For example:

@smallexample
function_which_takes_a_function_pointer (my_function);
@end smallexample

@end deftypevr

@deftypevr {Function Argument} double {@t{(*} df@t{)(double)}}
A pointer to the first derivative of the function whose root you are
searching for.

@emph{Please note:} If your function's first derivative is not
available, you should not approximate it numerically; it is almost
always faster to use an algorithm which does not require a derivative.
(FIXME: Is this a valid statement?)

If we were looking for a root of the function in the previous example,
this is what we would use for @code{dfn}:

@smallexample
@group
double
my_functions_first_derivative (double x) @{
   double yprime;

   yprime = 2 * cos (2 * x) - 2 * sin (x);
   return (yprime);
@} 
@end group
@end smallexample

This argument is only required for algorithms which use Newton's Method
(@pxref{Newtons Method}).
@end deftypevr


@node Search Bounds and Guesses
@subsection Search Bounds and Guesses
@cindex root finding, search bounds
@cindex root finding, guess(es)

Search bounds and guesses are not the same things. Search bounds are the
endpoints of the search interval which is iterated smaller and smaller
until the length of the interval is smaller than the requested
precision; a guess is an @math{x} value which is iterated around until
the it is within desired precision of a root. Two guesses behave
similarly to one; there are just two @math{x} values wandering about
instead of one.

No GSL root finding functions take both bounds and guesses. While the
hybrid functions (@pxref{Hybrid Algorithms}) incorporate algorithms
whose use of bounds and guesses is mixed, hybrid functions accept bounds
and generate guesses internally when they are needed.

These variables are defined as pointers to @code{double}s rather than
simply @code{double}s for two reasons. First, if the root finding
function fails, it is very useful to have the final values of your
iterated variables available to help diagnose why it failed. Second, it
makes it possible to preserve the state of the root finder, enabling it
to be restarted in the same place if needed. A situation where this
could be useful is if the function under search is very costly to
evaluate. Pretend, for a moment, that you want to find a root of a
function which takes several minutes to evaluate. Your program could
chug away for a few iterations, then examine your mailbox to see if the
number of flames about bogging down the machine is above a certain
threshold. If it isn't, chug away for a few more iterations and repeat
the process; if it is, depending on your temperament, your program could
renice itself to a lower priority and mail back apologies before
continuing, or it could mailbomb everyone who complained, spawn copies
of itself endlessly, and dump garbage to @w{@file{/dev/audio}} and
@w{@file{/dev/console}}.

@deftypevr {Function Argument} {double *} lower_bound
@deftypevrx {Function Argument} {double *} upper_bound
@vindex @r{root finding,} lower_bound @r{(function argument)}
@vindex @r{root finding,} upper_bound @r{(function argument)}
The initial upper and lower bounds of the interval in which to search for a
root. @w{@code{lower_bound}} must be less than @w{@code{upper_bound}}.

These arguments are modified during execution of the root finding
function; if you need to preserve their initial values, you must make
copies of them. See the third paragraph of this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
for the reasoning behind this behavior.

These arguments is accepted by bracketing algorithms such as bisection
(@pxref{Bisection}) and hybrid algorithms (@pxref{Hybrid Algorithms}).
@end deftypevr

@deftypevr {Function Argument} {double *} guess
@deftypevrx {Function Argument} {double *} guess2
@vindex @r{root finding,} guess @r{(function argument)}
@vindex @r{root finding,} guess2 @r{(function argument)}
One or two initial values for the guess(es) iterated by the root finding
function.

These arguments are modified during execution of the root finding
function; if you need to preserve their initial values, you must make
copies of them. See the third paragraph of this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
for the reasoning behind this behavior.

@code{guess} is accepted by stepping algorithms (Newton's Method,
@ref{Newtons Method}, and Secant Method, @ref{Secant Method}.)
@code{guess2} is only accepted by Secant Method.
@end deftypevr

@node Search Stopping Parameters
@subsection Search Stopping Parameters
@cindex root finding, stopping parameters

GSL root finding functions (and numerical root finding functions in
general) stop when one of the following conditions is true:

@itemize @bullet
@item
A root has been found to within the user-specified precision (the
@dfn{epsilon}).

@item
A user-specified maximum number of iterations has executed.

@item
An error has occured (for example, Newton's Method has landed too close
to an extremum).
@end itemize

Whenever you call a GSL root finding function, you must specify the
epsilon and the maximum allowed iterations. Every GSL root
finding function accepts the following arguments:

@deftypevr {Function Argument} double epsilon
@vindex @r{root finding,} epsilon @r{(function argument)}
The maximum permissible error in GSL root finder answers. This must
be greater than (FIXME: or equal to?) @w{@code{DBL_EPSILON}}, specified in the
file @w{@file{float.h}} of the @sc{ansi} C Library, which is the
smallest positive @math{x} such that the relation @math{1 + x \neq 1}
holds true. With a 64-bit @code{double}, this is around @math{10^@{-16@}}
(FIXME: is that correct? should we give this information?)

It is a good idea to not ask for more precision than you need,
especially if your function is costly to evaluate.
@end deftypevr

@deftypevr {Function Argument} int max_iterations
@vindex @r{root finding,} max_iterations @r{(function argument)}
The maximum number of iterations a root finder is allowed to perform.
This must be greater than or equal to 1, as performing a negative number
of iterations is extremely difficult and not doing any iterations is
rather useless.

FIXME: There must be a good rule of thumb for setting the number of
iterations. Do not set @w{@code{max_iterations}} too large; if there
is a problem, you don't want your program chugging away on something you'll
never get an answer for.
@end deftypevr

In addition, GSL root finding functions which make use of stepping
algorithms (i.e. Newton's Method, @pxref{Newtons Method}) rather than
bracketing algorithms (i.e. bisection, @pxref{Bisection}) accept an
additional argument:

@deftypevr {Function Argument} double max_step_size
@vindex @r{root finding,} max_step_size @r{(function argument)}
The maximum step size a stepping algorithm is allowed to take. This is
to prevent a stepping function from landing on a place where the test
function's derivative is very small and zooming off to infinity or into
a different solution basin.

For example, if while solving @math{sin(x) = 0}, @math{x_n} of Newton's
Method (@pxref{Newtons Method}) landed on @math{1.570700000}
(@math{@{\pi \over 2@} = 1.570796327}), then @math{x_@{n+1@}} would be
approximately @math{-10000}, which is definitely not what we wanted! We
want the root finder to recognize this step as ``too big'' and flag an
error.

The alarm bell will ring if the following relation in true:

@equation
|@{@{d@} \over @{dx@}@} f(x)| < |@{@{f(x)@} \over max\_step\_size@}|
@end equation
@noindent
Note that while Secant Method (@pxref{Secant Method}) does not deal with
derivatives directly, it approximates them numerically.

Do not set @w{@code{max_step_size}} too large; that will defeat its
purpose. In the @math{sin(x) = 0} example, @math{\pi} would be a good
value for @w{@code{max_step_size}}; any step larger than that would
certainly be headed astray. While a good understanding of the problem is
important for setting any of these arguments to a useful value, it is
especially important for @w{@code{max_step_size}}.
@end deftypevr


@node Root Finder Error Codes
@subsection Root Finder Error Codes
@cindex root finding, error codes

When successful, GSL root finding functions return @code{0}; on
error, they return @code{-1} and set the variable @w{@code{gsl_errno}}
to a diagnostic value. (This is how most GSL functions behave.
@xref{Error handling in GSL}.)

Unless otherwise specified, an error of any kind indicates that the
returned root location is garbage and should not be used.

GSL root finders may set @w{@code{gsl_errno}} to the following values:

@table @code
@item GSL_EINVAL
One or more of the input arguments is invalid because at least one of
these conditions is true:

@itemize @bullet
@item 
@code{epsilon} is too small or @w{@code{max_iterations}} is less than 1.
@xref{Search Stopping Parameters}.

@item
The lower bound of the search interval is not less than the upper bound.

@item
The function under search (or its derivative) is not behaving as GSL
expects it to. (For example, it returned @code{NAN}.)

@item
@code{guess}, @code{guess2}, @w{@code{lower_bound}}, or
@w{@code{upper_bound}} is a null pointer. @xref{Search Bounds and Guesses}.
@end itemize

@item GSL_ERUNAWAY
A stepping root finder tried to take a step larger than
@w{@code{max_step_size}} (@pxref{Search Stopping Parameters}). This
happens when a stepping algorithm lands on a place where the derivative
is too small.

@item GSL_ETIMEOUT
The number of iterations executed exceeded @w{@code{max_iterations}}
(@pxref{Search Stopping Parameters}). In certain situations which depend
on the function under search and the initial parameters, the returned
root location might be correct but not to the requested precision.
However, @emph{this is unlikely!} Do not treat the root location as
valid unless you are @emph{sure} that it is.

@item GSL_EZERODIV
GSL caught itself before dividing by zero. This most often happens when
Newton's Method (@pxref{Newtons Method}) or Secant Method (@pxref{Secant
Method}) lands on an extremum.
@end table


@node Hybrid Algorithms
@section Hybrid Algorithms
@cindex root finding, hybrid algorithms

Often, the best root finding algorithm is one which combines two or more
different methods. The @value{GSL} provides two hybrids: one for use
when the function's first derivative is available, and one for when it
is not.

@deftypefun int gsl_root_have_1der (@w{double * @var{root}}, @w{double (* @var{f})(double)}, @w{double (* @var{df})(double)}, @w{double @var{lower_bound}}, @w{double @var{upper_bound}}, double @w{@var{epsilon}}, int @w{@var{max_iterations}}, double @w{@var{max_step_size}})

Search for a zero using a combination of bisection (@pxref{Bisection})
and Newton's Method (@pxref{Newtons Method}).

@xref{Calling GSL Root Finding Functions}, for an explanation of the arguments.

@end deftypefun

Use example:

@smallexample
@group
int status;
status = gsl_root_have_1der(sin, cos, (
@end group
@end smallexample


@node Bisection
@section Bisection
@cindex bisection algorithm for finding roots
@cindex root finding, bisection algorithm

ha ha ha


@node Newtons Method
@section Newtons Method
@cindex Newton's Method algorithm for finding roots
@cindex root finding, Newton's Method algorithm

ha ha ha


@node Secant Method
@section Secant Method
@cindex Secant Method algorithm for finding roots
@cindex root finding, Secant Method algorithm

ha h aha


@node False Position
@section False Position
@cindex false position algorithm for finding roots
@cindex root finding, false position algorithm

ha ha ha
