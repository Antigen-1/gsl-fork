@cindex root finding
@cindex zero finding
@cindex finding roots
@cindex finding zeros
@cindex roots

This chapter describes functions for finding a root of an arbitrary
function which you provide. It discusses proper use and possible
pitfalls of each function and gives an overview of the algorithms
involved.

The @value{GSL} provides two types of root finding functions: high-level
functions which take few arguments and make most decisions for you, and
low-level functions which take many arguments and can be precisely
controlled. For most tasks, the simpler high-level functions will be
sufficient, but the greater degree of control provided by the low-level
functions is sometimes useful.

For examples of GSL root finding functions in action, look at the source
code for the testing program which verifies that the they work correctly
(it is run when you do a @samp{make check}). It is in the file
@w{@file{roots/test.c}} and implements one way of properly handling
errors.

The header file @w{@file{gsl_roots.h}} contains prototypes for GSL root
finding functions and some other related declarations.

@strong{FIXME: add a note about performance.}

@menu
* Root Finding Overview::
* High Level vs. Low Level::
* High Level Root Finding Functions::
* Low Level Root Finding Functions::
* Root Finder Error Handling::
@end menu


@node Root Finding Overview
@section Root Finding Overview
@cindex root finding, overview

@strong{FIXME: Insert discussion of numerical root finding here.}

GSL root finding functions operate on continous functions only.

While it is not absolutely required that @math{f} have a root within the
search region, numerical root finding functions should not be used
haphazardly to check for the @emph{existence} of roots. There are better
ways to do this! Because it is so easy to create situations where
numerical root finders go awry, it is a bad idea to throw a root finder
at a function you do not know much about.

Note that GSL root finding functions can only search for one root at a
time. While their behavior in cases of multiple roots (several roots in
the search area, not one root of degree greater than 1) is
deterministic, it depends entirely on the algorithm and the function
under search and is rather complex; it is therefore difficult to
predict. @emph{In most cases, no error will be reported if you try to
find a root in an area where there is more than one.}


@node High Level vs. Low Level
@section High Level vs. Low Level
@cindex root finding, high level vs. low level
@cindex root finding, choosing between high level and low level

@strong{FIXME: fill in this section.}

In general, you should use high level functions unless there is a
definite reason to use low level functions.


@include roots-high.texi


@include roots-low.texi


@node Root Finder Error Handling
@section Root Finder Error Handling
@cindex root finding, errors

When successful, GSL root finding functions return @code{0}; on error,
they return @code{-1} and set the global variable @w{@code{gsl_errno}}
to a diagnostic value. (@xref{Error handling in GSL}, for a general
discussion of GSL error handling.)

When using low-level functions, you can examine @code{*guess},
@code{*guess2}, @w{@code{*lower_bound}}, or @w{@code{*upper_bound}}
(@pxref{Search Bounds and Guesses}) to help determine why a root finder
failed.

@set llo @i{[Low Level Only]}
GSL root finders can set @w{@code{gsl_errno}} to the following macros.
Some errors can only be encountered by low level functions; they are
marked by @value{llo}.

@table @code
@item GSL_EINVAL
One or more of the input arguments is invalid because at least one of
these conditions is true:

@itemize @bullet
@item 
@value{llo} @w{@code{max_iterations}} is equal to 0. @xref{Search
Stopping Parameters}.

@item
The lower bound of the search interval is not less than the upper bound.

@item
You supplied a pointer argument which was null.

@item
@math{f(lower\_bound)} and @math{f(upper\_bound)} do not differ in sign,
and the function that you are using requires that they do.

@end itemize

@item GSL_EBADFUNC
The function under search (or its derivative) did not return a valid
number when it was called by GSL. (Instead, it returned @code{NAN} or
@code{INF}.)

@item GSL_ERUNAWAY
@value{llo} A root finder tried to take a step larger than
@w{@code{max_step_size}} (@pxref{Search Stopping Parameters}). This
happens when an extrapolating algorithm lands on a place where the
derivative is too small.

@item GSL_ETIMEOUT
The number of iterations executed exceeded @w{@code{max_iterations}}
(@pxref{Search Stopping Parameters}).

@item GSL_ETOL
@value{llo} You specified an invalid error tolerance in one or more of
the following ways (@pxref{Search Stopping Parameters}):

@itemize @bullet
@item
@w{@code{rel_epsilon}} was too small.

@item
@w{@code{rel_epsilon}} and @w{@code{abs_epsilon}} were both zero.

@item
@w{@code{rel_epsilon}} was zero, and the search converged to a place too
far from zero for @w{@code{abs_epsilon}} to be useful.

@item
@w{@code{abs_epsilon}} was zero, and the search converged to a place too
close to zero for @w{@code{rel_epsilon}} to be useful.

@item
@strong{FIXME: add stuff for delta.}
@end itemize
   
@item GSL_EZERODIV
@value{llo} GSL caught itself before dividing by zero. This most often
happens when Newton's Method (@pxref{Newtons Method}) or Secant Method
(@pxref{Secant Method}) lands on an extremum.
@end table


