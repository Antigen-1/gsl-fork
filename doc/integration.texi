This chapter describes functions for performing quadrature or numerical
integration. The library reimplements algorithms from the QUADPACK
library by Piessens, Doncker-Kapenga, Uberhuber and Kahaner. Fortran
code for QUADPACK is available on Netlib.

All the functions attempt to compute an integral of the form

@tex
\beforedisplay
$$
I = \int_a^b f(x) dx
$$
\afterdisplay
@end tex
@ifinfo
@example
I = \int_a^b f(x) dx
@end example
@end ifinfo

@noindent
aiming to satisfy the accuracy requirement

@tex
\beforedisplay
$$
|\hbox{\it RESULT} - I|  \leq \max \{ epsabs, epsrel |I| \}
$$
\afterdisplay
@end tex
@ifinfo
@example
|RESULT - I|  <= max@{epsabs, epsrel |I|@}
@end example
@end ifinfo

@noindent
where RESULT is the numerical approximation obtained by the
algorithm. The integrators attempt to estimate the absolute error
@c{$ABSERR = |\hbox{\it RESULT} - I|$}
@math{ABSERR = |RESULT - I|} in such a way that the following inequality
holds,

@tex
\beforedisplay
$$
|\hbox{\it RESULT} - I| \leq ABSERR \leq \max \{ epsabs, epsrel |I| \}
$$
\afterdisplay
@end tex
@ifinfo
@example
|RESULT - I| <= ABSERR \leq \max@{ epsabs, epsrel |I|@}
@end example
@end ifinfo



@menu
* QNG non-adaptive Gauss-Kronrod integration::  
* QAG adaptive integration::    
* QAGS adaptive integration with end-point singularities::  
* QAGP adaptive integration with singular points::  
* QAGI adaptive integration on infinite intervals::  
* QAWC adaptive integration for Cauchy principal value::  
* QAWS adaptive integration for singular functions::  
* QAWO adaptive integration for oscillatory functions::  
* QAWF adaptive integration for Fourier integrals::  
* Numerical integration examples::  
* Numerical integration References and Further Reading::  
@end menu

@node QNG non-adaptive Gauss-Kronrod integration
@section QNG non-adaptive Gauss-Kronrod integration

@deftypefun int gsl_integration_qng (const gsl_function *@var{f}, double @var{a}, double @var{b}, double @var{epsabs}, double @var{epsrel}, double * @var{result}, double * @var{abserr}, size_t * @var{neval})

This function applies the Gauss-Kronrod 10-point, 21-point, 43-point and
87-point integration rules in succession until an estimate of the
integral of @math{f} over @math{(a,b)} is achieved within the desired
absolute and relative error limits, @var{epsabs} and @var{epsrel}. The
function returns the final approximation, @var{result}, an estimate of
the absolute error, @var{abserr} and the number of function evaluations
used, @var{neval}. The Gauss-Kronrod rules are designed in such a way
that each rule uses all the results of its predecessors, in order to
minimise the total number of function evaluations.
@end deftypefun


@node QAG adaptive integration
@section QAG adaptive integration

@deftypefun {gsl_integration_workspace *} gsl_integration_workspace_alloc (const size_t @var{n}) 
This function allocates a workspace sufficient to hold @var{n} double
precision intervals, their integration results and error estimates.
@end deftypefun

@deftypefun void gsl_integration_workspace_free (gsl_integration_workspace * @var{w})
This function frees the memory associated with the workspace @var{w}.
@end deftypefun

@deftypefun int gsl_integration_qag (const gsl_function *@var{f}, double @var{a}, double @var{b}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, int @var{key}, gsl_integration_workspace * @var{workspace},  double * @var{result}, double * @var{abserr})

This function applies an integration rule adaptively until an estimate
of the integral of @math{f} over @math{(a,b)} is achieved within the
desired absolute and relative error limits, @var{epsabs} and
@var{epsrel}. The function returns the final approximation,
@var{result}, and an estimate of the absolute error, @var{abserr}. The
integration rule is determined by the value of @var{key}, which should
be chosen from the following symbolic names,

@example
GSL_INTEG_GAUSS15  (key = 1)
GSL_INTEG_GAUSS21  (key = 2)
GSL_INTEG_GAUSS31  (key = 3)
GSL_INTEG_GAUSS41  (key = 4)
GSL_INTEG_GAUSS51  (key = 5)
GSL_INTEG_GAUSS61  (key = 6)
@end example

@noindent
corresponding to the 15, 21, 31, 41, 51 and 61 point Gauss-Kronrod
rules. The higher-order rules give better accuracy for smooth functions,
while lower-order rules have superior overall performance when the
function contains non-smooth regions, such as discontinuities.

On each iteration the adaptive integration strategy bisects the interval
with the largest error estimate. The subintervals and their results and
error estimates are stored in the memory provided by @var{workspace}.
@end deftypefun


@node QAGS adaptive integration with end-point singularities
@section QAGS adaptive integration with end-point singularities

@deftypefun int gsl_integration_qags (const gsl_function * @var{f}, double @var{a}, double @var{b}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function applies the Gauss-Kronrod 21-point integration rule
adaptively until an estimate of the integral of @math{f} over
@math{(a,b)} is achieved within the desired absolute and relative error
limits, @var{epsabs} and @var{epsrel}. The results are extrapolated
using the epsilon-algorithm, which accelerates the convergence of the
integral in the presence of discontinuities and integrable
singularities. The function returns the final approximation from the
extrapolation, @var{result}, and an estimate of the absolute error,
@var{abserr}.

@end deftypefun

@node QAGP adaptive integration with singular points
@section QAGP adaptive integration with singular points

@deftypefun int gsl_integration_qagp (const gsl_function * @var{f}, double *@var{pts}, size_t @var{npts}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function applies the adaptive integration algorithm QAGS taking
account of the user-supplied locations of singular points. The array
@var{pts} of length @var{npts} should contain the endpoints of the
integration ranges defined by the integration region and locations of
the singularities. For example, to integrate over the region
@math{(a,b)} with break-points at @math{x_1, x_2, x_3} (where 
@math{a < x_1 < x_2 < x_3 < b}) the following @var{pts} array should be used

@example
pts[0] = a
pts[1] = x_1
pts[2] = x_2
pts[3] = x_3
pts[4] = b
@end example

@noindent
with @var{npts} = 5.

@end deftypefun

@node QAGI adaptive integration on infinite intervals
@section QAGI adaptive integration on infinite intervals

@deftypefun int gsl_integration_qagi (gsl_function * @var{f}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function computes the integral of the function @var{f} over the
infinite region @math{(-\infty,+\infty)}.  The integral is mapped onto the
region @math{(0,1]} using the transformation @math{x = (1-t)/t},

@tex
\beforedisplay
$$
\int_{-\infty}^{+\infty} dx \, f(x) 
  = \int_0^1 dt \, (f((1-t)/t) + f(-(1-t)/t))/t^2
$$
\afterdisplay
@end tex
@ifinfo
@example
\int_@{-\infty@}^@{+\infty@} dx f(x) = 
     \int_0^1 dt (f((1-t)/t) + f((-1+t)/t))/t^2
@end example
@end ifinfo

@noindent
and then integrated using the QAGS algorithm. The normal 21-point
Gauss-Kronrod rule of QAGS is replaced by a 15-point rule, because the
transformation can generate an integrable singularity at the origin. In
this case a lower-order rule is more efficient.
@end deftypefun

@deftypefun int gsl_integration_qagiu (gsl_function * @var{f}, double @var{a}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function computes the integral of the function @var{f} over the
semi-infinite region @math{(a,+\infty)}.  The integral is mapped onto the
region @math{(0,1]} using the transformation @math{x = a + (1-t)/t},

@tex
\beforedisplay
$$
\int_{a}^{+\infty} dx \, f(x) 
  = \int_0^1 dt \, (f(a + (1-t)/t)/t^2
$$
\afterdisplay
@end tex
@ifinfo
@example
\int_@{a@}^@{+\infty@} dx f(x) = 
     \int_0^1 dt (f(a + (1-t)/t)/t^2
@end example
@end ifinfo

@noindent
and then integrated using the QAGS algorithm.
@end deftypefun

@deftypefun int gsl_integration_qagil (gsl_function * @var{f}, double @var{b}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})
This function computes the integral of the function @var{f} over the
semi-infinite region @math{(-\infty,b)}.  The integral is mapped onto the
region @math{(0,1]} using the transformation @math{x = b - (1-t)/t},

@tex
\beforedisplay
$$
\int_{-\infty}^{b} dx \, f(x) 
  = \int_0^1 dt \, (f(b - (1-t)/t)/t^2
$$
\afterdisplay
@end tex
@ifinfo
@example
\int_@{+\infty@}^@{b@} dx f(x) = 
     \int_0^1 dt (f(b - (1-t)/t)/t^2
@end example
@end ifinfo

@noindent
and then integrated using the QAGS algorithm.
@end deftypefun

@node  QAWC adaptive integration for Cauchy principal value
@section QAWC adaptive integration for Cauchy principal value

@deftypefun int gsl_integration_qawc (gsl_function *@var{f}, double @var{a}, double @var{b}, double @var{c}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double * @var{result}, double * @var{abserr})

This function computes the Cauchy principal value of the integral of
@math{f} over @math{(a,b)}, with a singularity at @var{c},

@tex
\beforedisplay
$$
I = \int_a^b dx\, {f(x) \over x - c}
$$
\afterdisplay
@end tex
@ifinfo
@example
I = \int_a^b dx f(x) / (x - c)
@end example
@end ifinfo

@noindent
The adaptive bisection algorithm of QAG is used, with modifications to
ensure that subdivisions do not occur at the singular point @math{x = c}.
When a subinterval contains the point @math{x = c} or is close to
it then a special 25-point modified Clenshaw-Curtis rule is used to control
the singularity.  Further away from the
singularity the algorithm uses an ordinary 15-point Gauss-Kronrod
integration rule.

@end deftypefun

@node  QAWS adaptive integration for singular functions
@section QAWS adaptive integration for singular functions

@deftypefun {gsl_integration_qaws_table *} gsl_integration_qaws_table_alloc (double @var{alpha}, double @var{beta}, int @var{mu}, int @var{nu})

This function allocates space for a @code{gsl_integration_qaws_table}
struct and associated workspace describing a singular weight function
@math{W(x)} with the parameters @math{(\alpha, \beta, \mu, \nu)},

@tex
\beforedisplay
$$
W(x) = (x - a)^\alpha (b - x)^\beta \log^\mu (x - a) \log^\nu (b - x)
$$
\afterdisplay
@end tex
@ifinfo
@example
W(x) = (x-a)^alpha (b-x)^beta log^\mu (x-a) log^\nu (b-x)
@end example
@end ifinfo

@noindent
where @math{\alpha < -1}, @math{\beta < -1}, and @math{\mu = 0, 1},
@math{\nu = 0, 1}. The weight function can take four different forms
depending on the value of @math{\mu} and @math{\nu},

@tex
\beforedisplay
$$
\matrix{
W(x) = (x - a)^\alpha (b - x)^\beta  
                                                \hfill~ (\mu = 0, \nu = 0) \cr
W(x) = (x - a)^\alpha (b - x)^\beta \log(x - a) 
                                                \hfill~ (\mu = 1, \nu = 0) \cr
W(x) = (x - a)^\alpha (b - x)^\beta \log(b - x) 
                                                \hfill~ (\mu = 0, \nu = 1) \cr
W(x) = (x - a)^\alpha (b - x)^\beta \log(x - a) \log(b - x) 
                                                \hfill~ (\mu = 1, \nu = 1)
}
$$
\afterdisplay
@end tex
@ifinfo
@example
W(x) = (x-a)^alpha (b-x)^beta                   (mu = 0, nu = 0)
W(x) = (x-a)^alpha (b-x)^beta log(x-a)          (mu = 1, nu = 0)
W(x) = (x-a)^alpha (b-x)^beta log(b-x)          (mu = 0, nu = 1)
W(x) = (x-a)^alpha (b-x)^beta log(x-a) log(b-x) (mu = 1, nu = 1)
@end example
@end ifinfo

@noindent
The singular points @math{(a,b)} do not have to be specified until the
integral is computed, where they are the endpoints of the integration
range.

The function returns a pointer to the newly allocated
@code{gsl_integration_qaws_table} if no errors were detected, and 0 in
the case of error.
@end deftypefun

@deftypefun int gsl_integration_qaws_table_set (gsl_integration_qaws_table * @var{t}, double @var{alpha}, double @var{beta}, int @var{mu}, int @var{nu})
This function modifies the parameters @math{(\alpha, \beta, \mu, \nu)} of
an existing @code{gsl_integration_qaws_table} struct @var{r}.
@end deftypefun

@deftypefun void gsl_integration_qaws_table_free (gsl_integration_qaws_table * @var{t})
This function frees all the memory associated with the
@code{gsl_integration_qaws_table} struct @var{t}.
@end deftypefun

@deftypefun int gsl_integration_qaws (gsl_function * @var{f}, const double @var{a}, const double @var{b}, gsl_integration_qaws_table * @var{t}, const double @var{epsabs}, const double @var{epsrel}, const size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function computes the integral of the function @math{f(x)} over the
interval @math{(a,b)} with the singular weight function
@c{$(x - a)^\alpha (b - x)^\beta \log^\mu (x - a) \log^\nu (b - x)$}
@math{(x-a)^alpha (b-x)^beta log^\mu (x-a) log^\nu (b-x)}. The parameters 
of the weight function @math{(\alpha, \beta, \mu, \nu)} are taken from the
table @var{t}.

@tex
\beforedisplay
$$
I = \int_a^b dx\, f(x) (x - a)^\alpha (b - x)^\beta 
        \log^\mu (x - a) \log^\nu (b - x)
$$
\afterdisplay
@end tex
@ifinfo
@example
I = \int_a^b dx f(x) (x-a)^alpha (b-x)^beta log^\mu (x-a) log^\nu (b-x)
@end example
@end ifinfo

@noindent
The adaptive bisection algorithm of QAG is used.  When a subinterval
contains one of the endpoints then a special 25-point modified
Clenshaw-Curtis rule is used to control the singularities.  For
subintervals which do not include the endpoints an ordinary 15-point
Gauss-Kronrod integration rule is used.

@end deftypefun

@node  QAWO adaptive integration for oscillatory functions
@section QAWO adaptive integration for oscillatory functions

@deftypefun {gsl_integration_qawo_workspace *} gsl_integration_qawo_workspace_alloc (double @var{omega}, double @var{L}, enum gsl_integration_qawo_enum @var{sine}, size_t @var{n})

This function allocates space for a @code{gsl_integration_qawo_table}
struct and its associated workspace describing a sine or cosine weight
function @math{W(x)} with the parameters @math{(\omega, L)},

@tex
\beforedisplay
$$
\eqalign{
W(x) & = \left\{\matrix{\sin(\omega x) \cr \cos(\omega x)} \right\}
}
$$
\afterdisplay
@end tex
@ifinfo
@example
W(x) = sin(omega x)
W(x) = cos(omega x)
@end example
@end ifinfo

@noindent
The parameter @var{L} must be the length of the interval over which the
function will be integrated @math{L = b - a}.  The choice of sine or
cosine is made with the parameter @var{sine} which should be chosen from
one of the two following symbolic values:

@example
GSL_INTEG_COSINE
GSL_INTEG_SINE
@end example

@noindent
The @code{gsl_integration_qawo_table} acts as a cache for trigonmetric
coefficients computed in the integration process. The parameter @var{n}
determines the number of levels of coefficients that can be stored. Each
level corresponds to one bisection of the interval @math{L}, so that
@var{n} levels are sufficient for subintervals down to the length
@math{L/2^n}.

@end deftypefun

@deftypefun int gsl_integration_qawo_workspace_set (gsl_integration_qawo_workspace * @var{t}, double @var{omega}, double @var{L}, enum gsl_integration_qawo_enum @var{sine})
This function changes the parameters @var{omega}, @var{L} and @var{sine}
of the existing workspace @var{t}.
@end deftypefun

@deftypefun int gsl_integration_qawo_workspace_set_length (gsl_integration_qawo_workspace * @var{t}, double @var{L})
This function allows the length parameter @var{L} of the workspace
@var{t} to be changed.
@end deftypefun

@deftypefun void gsl_integration_qawo_workspace_free (gsl_integration_qawo_workspace * @var{t})
This function frees all the memory associated with the workspace @var{t}.
@end deftypefun

@deftypefun int gsl_integration_qawo (gsl_function * @var{f}, const double @var{a}, const double @var{epsabs}, const double @var{epsrel}, const size_t @var{limit}, gsl_integration_workspace * @var{workspace}, gsl_integration_qawo_workspace * @var{wf}, double *@var{result}, double *@var{abserr})

This function uses an adaptive algorithm to compute the integral of
@math{f} over @math{(a,b)} with the weight function 
@math{\sin(\omega x)} or @math{\cos(\omega x)} defined 
by the workspace @var{wf}.

@tex
\beforedisplay
$$
\eqalign{
I & = \int_a^b dx\, f(x) \left\{ \matrix{\sin(\omega x) \cr \cos(\omega x)}\right\}
}
$$
\afterdisplay
@end tex
@ifinfo
@example
I =  \int_a^b dx f(x) \sin(\omega x)
I =  \int_a^b dx f(x) \cos(\omega x)
@end example
@end ifinfo

@noindent
The results are extrapolated using the epsilon-algorithm to accelerate
the convergence of the integral. The function returns the final
approximation from the extrapolation, @var{result}, and an estimate of
the absolute error, @var{abserr}.

Those subintervals with ``large'' widths @math{d}, @math{d\omega > 4} are
computed using a 25-point Clenshaw-Curtis integration rule, which handles the
oscillatory behavior. Subintervals with a ``small'' width
@math{d\omega < 4} are computed using a 15-point Gauss-Kronrod integration.

@end deftypefun

@node  QAWF adaptive integration for Fourier integrals
@section QAWF adaptive integration for Fourier integrals

@deftypefun int gsl_integration_qawf (gsl_function * @var{f}, const double @var{a}, const double @var{epsabs}, const size_t @var{limit}, gsl_integration_workspace * @var{workspace}, gsl_integration_workspace * @var{cycle_workspace}, gsl_integration_qawo_workspace * @var{wf}, double *@var{result}, double *@var{abserr})

This function attempts to compute a Fourier integral of the function
@var{f} over the semi-infinite interval @math{[a,+\infty)}.

@tex
\beforedisplay
$$
\eqalign{
I & = \int_a^{+\infty} dx\, f(x) \left\{ \matrix{ \sin(\omega x) \cr
                                                 \cos(\omega x) } \right\}
}
$$
\afterdisplay
@end tex
@ifinfo
@example
I =  \int_a^@{+\infty@} dx f(x) \sin(\omega x)
I =  \int_a^@{+\infty@} dx f(x) \cos(\omega x)
@end example
@end ifinfo

The parameters are taken from the workspace @var{wf}, but the length
@var{L} can take any value. The integral is computed over the
subintervals,

@tex
\beforedisplay
$$
\eqalign{
C_1 & = [a, a + c] \cr
C_2 & = [a + c, a + 2c] \cr
\dots & = \dots \cr
C_k & = [a + (k-1) c, a + k c]
}
$$
\afterdisplay
@end tex
@ifinfo
@example
C_1 = [a, a + c]
C_2 = [a + c, a + 2 c]
... = ...
C_k = [a + (k-1) c, a + k c]
@end example
@end ifinfo

@noindent
where @math{c = (2[|w|] + 1) \pi/|w|}. The width @math{c} is chosen to
cover an odd number of periods so that the contributions from the
intervals alternate in sign and are monotonically descreasing when
@var{f} is positive and monotically descreasing. The sum of this
sequence of contributions is accelerated using the epsilon-algorithm.

This function works to an absolute tolerance @var{abserr}. On each
interval @math{C_k} the algorithm tries to achieve the tolerance

@tex
\beforedisplay
$$
TOL_k = u_k abserr
$$
\afterdisplay
@end tex
@ifinfo
@example
TOL_k = u_k abserr
@end example
@end ifinfo

@noindent
where 
@c{$u_k = (1 - p)p^{k-1}$}
@math{u_k = (1 - p)p^@{k-1@}} and @math{p = 9/10}. If the integration of
a subinterval leads to difficulties then the accuracy requirement for
subsequent intervals is relaxed,

@tex
\beforedisplay
$$
TOL_i = u_i \max \{abserr, \max_{k<i}\{E_k\}\}
$$
\afterdisplay
@end tex
@ifinfo
@example
TOL_i = u_i \max@{abserr, \max_@{k<i@}@{E_k@}@}
@end example
@end ifinfo

@noindent
where @math{E_k} is the estimated error on the interval @math{C_k}.

@end deftypefun

@node Numerical integration examples
@section Numerical integration examples

@example
#include <stdio.h>
#include <math.h>
#include <gsl_integration.h>

double f (double x, void * params) @{
  double alpha = *(double *) params ;
  double f = log(alpha*x) / sqrt(x);
  return f ;
@}

int 
main ()
@{
  gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);

  double result, error;

  double expected = -4.0;

  double alpha = 1.0;

  gsl_function F;

  F.function = &f;
  F.params = &alpha;

  gsl_integration_qags (&F, 0, 1, 0, 1e-7, 1000, w, &result, &error); 

  printf("result          = % .18f\n", result);
  printf("exact result    = % .18f\n", expected);
  printf("estimated error = % .18f\n", error);
  printf("actual error    = % .18f\n",  result - expected);
  printf("intervals =  %d\n", w->size);
@}
@end example


@example
bash$ ./a.out 
result          = -3.999999999999973799
exact result    = -4.000000000000000000
estimated error =  0.000000000000246025
actual error    =  0.000000000000026201
intervals =  8
@end example




@node Numerical integration References and Further Reading
@section Numerical integration  References and Further Reading

@noindent
The following book is the definitive reference for QUADPACK, and was
written by the original authors. It provides descriptions of the
algorithms, test programs, examples and useful advice on numerical
integration. It also includes many references to the numerical
integration literature used in developing QUADPACK.

@itemize @asis
@item
R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, D.K. Kahaner.
@cite{@sc{quadpack} A subroutine package for automatic integration}
Springer Verlag, 1983.
@end itemize
@noindent






