@cindex quadrature
@cindex numerical integration (quadrature)
@cindex integration, numerical (quadrature)
@cindex QUADPACK

This chapter describes functions for performing numerical integration
(quadrature). There are functions for both adaptive and non-adaptive
integration of general functions, specialised routines for integration
over infinite and semi-infinite ranges, singular integrals, including
logarithmic singularities and computation of Cauchy principal values,
and oscillatory integrals. The library reimplements all the algorithms
used in QUADPACK, a numerical integration package written by Piessens,
Doncker-Kapenga, Uberhuber and Kahaner. Fortran code for QUADPACK is
available on Netlib.

All the functions compute an approximation to a definite integral of the
form,

@tex
\beforedisplay
$$
I = \int_a^b f(x) w(x) dx
$$
\afterdisplay
@end tex
@ifinfo
@example
I = \int_a^b f(x) w(x) dx
@end example
@end ifinfo

@noindent
where @math{w(x)} is a weight function.  The user provides absolute and
relative error bounds @math{(epsabs, epsrel)} to be used in the
following accuracy requirement,

@tex
\beforedisplay
$$
|\hbox{\it RESULT} - I|  \leq \max \{ epsabs, epsrel |I| \}
$$
\afterdisplay
@end tex
@ifinfo
@example
|RESULT - I|  <= max@{epsabs, epsrel |I|@}
@end example
@end ifinfo

@noindent
where RESULT is the numerical approximation obtained by the
algorithm. The integrators attempt to estimate the absolute error
@c{$ABSERR = |\hbox{\it RESULT} - I|$}
@math{ABSERR = |RESULT - I|} in such a way that the following inequality
holds,

@tex
\beforedisplay
$$
|\hbox{\it RESULT} - I| \leq ABSERR \leq \max \{ epsabs, epsrel |I| \}
$$
\afterdisplay
@end tex
@ifinfo
@example
|RESULT - I| <= ABSERR \leq \max@{ epsabs, epsrel |I|@}
@end example
@end ifinfo

@noindent
An integrator will fail to converge if the error bounds are too
stringent, but will return the best approximation it was able to obtain.

The algorithms in QUADPACK use a naming convention based on the
following letters,

@display 
@code{Q} - quadrature routine

@code{N} - non-adaptive integrator
@code{A} - adaptive integrator

@code{G} - general integrand (user-defined)
@code{W} - weight function with integrand

@code{S} - singularities can be more readily integrated
@code{P} - points of special difficulty can be supplied
@code{I} - infinite range of integration
@code{O} - oscillatory weight function, @math{\cos(\omega x)} or @math{\sin(\omega x)}
@code{F} - Fourier integral
@code{C} - Cauchy principal value
@end display

@noindent
All the algorithms in QUADPACK are based Gauss-Kronrod rules for general
integrands and modified Clenshaw-Curtis quadrature rules for integrands
with weight functions. The rules are used to compute an approximation to
an integral over a small range and an estimate of the error in the
approximation.

A Gauss-Kronrod rule begins with a classical Gaussian quadrature rule of
order @math{m}. This is extended with interpolatory points between each
of the abscissae to give a higher order Kronrod rule of order
@math{2m+1}.  The original function evaluations can be reused in
computing this higher order rule. It is used as the best approximation
to the integral, and the difference between the two rules is used to
estimate the error in the approximation.

A Clenshaw-Curtis rule takes an @math{n}-th order Chebyschev
approximation to the integrand and integrates it exactly. The Chebyschev
expansion can be extended to higher order to improve the approximation.
The presence of singularities (or other behavior) in the integrand can
cause slow convergence in the Chebyschev approximation.  The modified
Clenshaw-Curtis rules used in QUADPACK separate out several common
weight functions which cause slow convergence. These weight functions
are integrated analytically against the Chebyschev polynomials to
precompute @dfn{modified Chebyschev moments}. Combining the moments with
the Chebyschev approximation to the function gives the desired
integral. The use of analytic integration for the singular part of the
function allows exact cancellations and substantially improves the
overall convergence behavior of the integration.

@menu
* QNG non-adaptive Gauss-Kronrod integration::  
* QAG adaptive integration::    
* QAGS adaptive integration with singularities::  
* QAGP adaptive integration with known singular points::  
* QAGI adaptive integration on infinite intervals::  
* QAWC adaptive integration for Cauchy principal values::  
* QAWS adaptive integration for singular functions::  
* QAWO adaptive integration for oscillatory functions::  
* QAWF adaptive integration for Fourier integrals::  
* Numerical integration examples::  
* Numerical integration References and Further Reading::  
@end menu

@node QNG non-adaptive Gauss-Kronrod integration
@section QNG non-adaptive Gauss-Kronrod integration

@deftypefun int gsl_integration_qng (const gsl_function *@var{f}, double @var{a}, double @var{b}, double @var{epsabs}, double @var{epsrel}, double * @var{result}, double * @var{abserr}, size_t * @var{neval})

This function applies the Gauss-Kronrod 10-point, 21-point, 43-point and
87-point integration rules in succession until an estimate of the
integral of @math{f} over @math{(a,b)} is achieved within the desired
absolute and relative error limits, @var{epsabs} and @var{epsrel}. The
function returns the final approximation, @var{result}, an estimate of
the absolute error, @var{abserr} and the number of function evaluations
used, @var{neval}. The Gauss-Kronrod rules are designed in such a way
that each rule uses all the results of its predecessors, in order to
minimise the total number of function evaluations.
@end deftypefun


@node QAG adaptive integration
@section QAG adaptive integration

All the adaptive integrators divide the integration region into
subintervals. These subintervals are managed by a
@code{gsl_integration_workspace} struct, which handles the memory for
the subinterval ranges, results and error estimates.

@deftypefun {gsl_integration_workspace *} gsl_integration_workspace_alloc (const size_t @var{n}) 
This function allocates a workspace sufficient to hold @var{n} double
precision intervals, their integration results and error estimates.
@end deftypefun

@deftypefun void gsl_integration_workspace_free (gsl_integration_workspace * @var{w})
This function frees the memory associated with the workspace @var{w}.
@end deftypefun

@deftypefun int gsl_integration_qag (const gsl_function *@var{f}, double @var{a}, double @var{b}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, int @var{key}, gsl_integration_workspace * @var{workspace},  double * @var{result}, double * @var{abserr})

This function applies an integration rule adaptively until an estimate
of the integral of @math{f} over @math{(a,b)} is achieved within the
desired absolute and relative error limits, @var{epsabs} and
@var{epsrel}. The function returns the final approximation,
@var{result}, and an estimate of the absolute error, @var{abserr}. The
integration rule is determined by the value of @var{key}, which should
be chosen from the following symbolic names,

@example
GSL_INTEG_GAUSS15  (key = 1)
GSL_INTEG_GAUSS21  (key = 2)
GSL_INTEG_GAUSS31  (key = 3)
GSL_INTEG_GAUSS41  (key = 4)
GSL_INTEG_GAUSS51  (key = 5)
GSL_INTEG_GAUSS61  (key = 6)
@end example

@noindent
corresponding to the 15, 21, 31, 41, 51 and 61 point Gauss-Kronrod
rules. The higher-order rules give better accuracy for smooth functions,
while lower-order rules have superior overall performance when the
function contains non-smooth regions, such as discontinuities.

On each iteration the adaptive integration strategy bisects the interval
with the largest error estimate. The subintervals and their results and
error estimates are stored in the memory provided by @var{workspace}.
@end deftypefun


@node QAGS adaptive integration with singularities
@section QAGS adaptive integration with singularities

@deftypefun int gsl_integration_qags (const gsl_function * @var{f}, double @var{a}, double @var{b}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function applies the Gauss-Kronrod 21-point integration rule
adaptively until an estimate of the integral of @math{f} over
@math{(a,b)} is achieved within the desired absolute and relative error
limits, @var{epsabs} and @var{epsrel}. The results are extrapolated
using the epsilon-algorithm, which accelerates the convergence of the
integral in the presence of discontinuities and integrable
singularities. The function returns the final approximation from the
extrapolation, @var{result}, and an estimate of the absolute error,
@var{abserr}.

@end deftypefun

@node QAGP adaptive integration with known singular points
@section QAGP adaptive integration with known singular points

@deftypefun int gsl_integration_qagp (const gsl_function * @var{f}, double *@var{pts}, size_t @var{npts}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function applies the adaptive integration algorithm QAGS taking
account of the user-supplied locations of singular points. The array
@var{pts} of length @var{npts} should contain the endpoints of the
integration ranges defined by the integration region and locations of
the singularities. For example, to integrate over the region
@math{(a,b)} with break-points at @math{x_1, x_2, x_3} (where 
@math{a < x_1 < x_2 < x_3 < b}) the following @var{pts} array should be used

@example
pts[0] = a
pts[1] = x_1
pts[2] = x_2
pts[3] = x_3
pts[4] = b
@end example

@noindent
with @var{npts} = 5.

@noindent
If you know the locations of the singular points in the integration
region then this routine will be faster than @code{QAGS}.

@end deftypefun

@node QAGI adaptive integration on infinite intervals
@section QAGI adaptive integration on infinite intervals

@deftypefun int gsl_integration_qagi (gsl_function * @var{f}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function computes the integral of the function @var{f} over the
infinite interval @math{(-\infty,+\infty)}.  The integral is mapped onto the
interval @math{(0,1]} using the transformation @math{x = (1-t)/t},

@tex
\beforedisplay
$$
\int_{-\infty}^{+\infty} dx \, f(x) 
  = \int_0^1 dt \, (f((1-t)/t) + f(-(1-t)/t))/t^2
$$
\afterdisplay
@end tex
@ifinfo
@example
\int_@{-\infty@}^@{+\infty@} dx f(x) = 
     \int_0^1 dt (f((1-t)/t) + f((-1+t)/t))/t^2
@end example
@end ifinfo

@noindent
and then integrated using the QAGS algorithm. The normal 21-point
Gauss-Kronrod rule of QAGS is replaced by a 15-point rule, because the
transformation can generate an integrable singularity at the origin. In
this case a lower-order rule is more efficient.
@end deftypefun

@deftypefun int gsl_integration_qagiu (gsl_function * @var{f}, double @var{a}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function computes the integral of the function @var{f} over the
semi-infinite interval @math{(a,+\infty)}.  The integral is mapped onto the
interval @math{(0,1]} using the transformation @math{x = a + (1-t)/t},

@tex
\beforedisplay
$$
\int_{a}^{+\infty} dx \, f(x) 
  = \int_0^1 dt \, (f(a + (1-t)/t)/t^2
$$
\afterdisplay
@end tex
@ifinfo
@example
\int_@{a@}^@{+\infty@} dx f(x) = 
     \int_0^1 dt (f(a + (1-t)/t)/t^2
@end example
@end ifinfo

@noindent
and then integrated using the QAGS algorithm.
@end deftypefun

@deftypefun int gsl_integration_qagil (gsl_function * @var{f}, double @var{b}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})
This function computes the integral of the function @var{f} over the
semi-infinite interval @math{(-\infty,b)}.  The integral is mapped onto the
region @math{(0,1]} using the transformation @math{x = b - (1-t)/t},

@tex
\beforedisplay
$$
\int_{-\infty}^{b} dx \, f(x) 
  = \int_0^1 dt \, (f(b - (1-t)/t)/t^2
$$
\afterdisplay
@end tex
@ifinfo
@example
\int_@{+\infty@}^@{b@} dx f(x) = 
     \int_0^1 dt (f(b - (1-t)/t)/t^2
@end example
@end ifinfo

@noindent
and then integrated using the QAGS algorithm.
@end deftypefun

@node  QAWC adaptive integration for Cauchy principal values
@section QAWC adaptive integration for Cauchy principal values

@deftypefun int gsl_integration_qawc (gsl_function *@var{f}, double @var{a}, double @var{b}, double @var{c}, double @var{epsabs}, double @var{epsrel}, size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double * @var{result}, double * @var{abserr})

This function computes the Cauchy principal value of the integral of
@math{f} over @math{(a,b)}, with a singularity at @var{c},

@tex
\beforedisplay
$$
I = \int_a^b dx\, {f(x) \over x - c}
$$
\afterdisplay
@end tex
@ifinfo
@example
I = \int_a^b dx f(x) / (x - c)
@end example
@end ifinfo

@noindent
The adaptive bisection algorithm of QAG is used, with modifications to
ensure that subdivisions do not occur at the singular point @math{x = c}.
When a subinterval contains the point @math{x = c} or is close to
it then a special 25-point modified Clenshaw-Curtis rule is used to control
the singularity.  Further away from the
singularity the algorithm uses an ordinary 15-point Gauss-Kronrod
integration rule.

@end deftypefun

@node  QAWS adaptive integration for singular functions
@section QAWS adaptive integration for singular functions

@deftypefun {gsl_integration_qaws_table *} gsl_integration_qaws_table_alloc (double @var{alpha}, double @var{beta}, int @var{mu}, int @var{nu})

This function allocates space for a @code{gsl_integration_qaws_table}
struct and associated workspace describing a singular weight function
@math{W(x)} with the parameters @math{(\alpha, \beta, \mu, \nu)},

@tex
\beforedisplay
$$
W(x) = (x - a)^\alpha (b - x)^\beta \log^\mu (x - a) \log^\nu (b - x)
$$
\afterdisplay
@end tex
@ifinfo
@example
W(x) = (x-a)^alpha (b-x)^beta log^\mu (x-a) log^\nu (b-x)
@end example
@end ifinfo

@noindent
where @math{\alpha < -1}, @math{\beta < -1}, and @math{\mu = 0, 1},
@math{\nu = 0, 1}. The weight function can take four different forms
depending on the values of @math{\mu} and @math{\nu},

@tex
\beforedisplay
$$
\matrix{
W(x) = (x - a)^\alpha (b - x)^\beta  
                                                \hfill~ (\mu = 0, \nu = 0) \cr
W(x) = (x - a)^\alpha (b - x)^\beta \log(x - a) 
                                                \hfill~ (\mu = 1, \nu = 0) \cr
W(x) = (x - a)^\alpha (b - x)^\beta \log(b - x) 
                                                \hfill~ (\mu = 0, \nu = 1) \cr
W(x) = (x - a)^\alpha (b - x)^\beta \log(x - a) \log(b - x) 
                                                \hfill~ (\mu = 1, \nu = 1)
}
$$
\afterdisplay
@end tex
@ifinfo
@example
W(x) = (x-a)^alpha (b-x)^beta                   (mu = 0, nu = 0)
W(x) = (x-a)^alpha (b-x)^beta log(x-a)          (mu = 1, nu = 0)
W(x) = (x-a)^alpha (b-x)^beta log(b-x)          (mu = 0, nu = 1)
W(x) = (x-a)^alpha (b-x)^beta log(x-a) log(b-x) (mu = 1, nu = 1)
@end example
@end ifinfo

@noindent
The singular points @math{(a,b)} do not have to be specified until the
integral is computed, where they are the endpoints of the integration
range.

The function returns a pointer to the newly allocated
@code{gsl_integration_qaws_table} if no errors were detected, and 0 in
the case of error.
@end deftypefun

@deftypefun int gsl_integration_qaws_table_set (gsl_integration_qaws_table * @var{t}, double @var{alpha}, double @var{beta}, int @var{mu}, int @var{nu})
This function modifies the parameters @math{(\alpha, \beta, \mu, \nu)} of
an existing @code{gsl_integration_qaws_table} struct @var{r}.
@end deftypefun

@deftypefun void gsl_integration_qaws_table_free (gsl_integration_qaws_table * @var{t})
This function frees all the memory associated with the
@code{gsl_integration_qaws_table} struct @var{t}.
@end deftypefun

@deftypefun int gsl_integration_qaws (gsl_function * @var{f}, const double @var{a}, const double @var{b}, gsl_integration_qaws_table * @var{t}, const double @var{epsabs}, const double @var{epsrel}, const size_t @var{limit}, gsl_integration_workspace * @var{workspace}, double *@var{result}, double *@var{abserr})

This function computes the integral of the function @math{f(x)} over the
interval @math{(a,b)} with the singular weight function
@c{$(x - a)^\alpha (b - x)^\beta \log^\mu (x - a) \log^\nu (b - x)$}
@math{(x-a)^alpha (b-x)^beta log^\mu (x-a) log^\nu (b-x)}. The parameters 
of the weight function @math{(\alpha, \beta, \mu, \nu)} are taken from the
table @var{t}.

@tex
\beforedisplay
$$
I = \int_a^b dx\, f(x) (x - a)^\alpha (b - x)^\beta 
        \log^\mu (x - a) \log^\nu (b - x)
$$
\afterdisplay
@end tex
@ifinfo
@example
I = \int_a^b dx f(x) (x-a)^alpha (b-x)^beta log^\mu (x-a) log^\nu (b-x)
@end example
@end ifinfo

@noindent
The adaptive bisection algorithm of QAG is used.  When a subinterval
contains one of the endpoints then a special 25-point modified
Clenshaw-Curtis rule is used to control the singularities.  For
subintervals which do not include the endpoints an ordinary 15-point
Gauss-Kronrod integration rule is used.

@end deftypefun

@node  QAWO adaptive integration for oscillatory functions
@section QAWO adaptive integration for oscillatory functions

@deftypefun {gsl_integration_qawo_workspace *} gsl_integration_qawo_workspace_alloc (double @var{omega}, double @var{L}, enum gsl_integration_qawo_enum @var{sine}, size_t @var{n})

This function allocates space for a @code{gsl_integration_qawo_table}
struct and its associated workspace describing a sine or cosine weight
function @math{W(x)} with the parameters @math{(\omega, L)},

@tex
\beforedisplay
$$
\eqalign{
W(x) & = \left\{\matrix{\sin(\omega x) \cr \cos(\omega x)} \right\}
}
$$
\afterdisplay
@end tex
@ifinfo
@example
W(x) = sin(omega x)
W(x) = cos(omega x)
@end example
@end ifinfo

@noindent
The parameter @var{L} must be the length of the interval over which the
function will be integrated @math{L = b - a}.  The choice of sine or
cosine is made with the parameter @var{sine} which should be chosen from
one of the two following symbolic values:

@example
GSL_INTEG_COSINE
GSL_INTEG_SINE
@end example

@noindent
The @code{gsl_integration_qawo_table} acts as a cache for trigonmetric
coefficients computed in the integration process. The parameter @var{n}
determines the number of levels of coefficients that can be stored. Each
level corresponds to one bisection of the interval @math{L}, so that
@var{n} levels are sufficient for subintervals down to the length
@math{L/2^n}.

@end deftypefun

@deftypefun int gsl_integration_qawo_workspace_set (gsl_integration_qawo_workspace * @var{t}, double @var{omega}, double @var{L}, enum gsl_integration_qawo_enum @var{sine})
This function changes the parameters @var{omega}, @var{L} and @var{sine}
of the existing workspace @var{t}.
@end deftypefun

@deftypefun int gsl_integration_qawo_workspace_set_length (gsl_integration_qawo_workspace * @var{t}, double @var{L})
This function allows the length parameter @var{L} of the workspace
@var{t} to be changed.
@end deftypefun

@deftypefun void gsl_integration_qawo_workspace_free (gsl_integration_qawo_workspace * @var{t})
This function frees all the memory associated with the workspace @var{t}.
@end deftypefun

@deftypefun int gsl_integration_qawo (gsl_function * @var{f}, const double @var{a}, const double @var{epsabs}, const double @var{epsrel}, const size_t @var{limit}, gsl_integration_workspace * @var{workspace}, gsl_integration_qawo_workspace * @var{wf}, double *@var{result}, double *@var{abserr})

This function uses an adaptive algorithm to compute the integral of
@math{f} over @math{(a,b)} with the weight function 
@math{\sin(\omega x)} or @math{\cos(\omega x)} defined 
by the workspace @var{wf}.

@tex
\beforedisplay
$$
\eqalign{
I & = \int_a^b dx\, f(x) \left\{ \matrix{\sin(\omega x) \cr \cos(\omega x)}\right\}
}
$$
\afterdisplay
@end tex
@ifinfo
@example
I =  \int_a^b dx f(x) \sin(\omega x)
I =  \int_a^b dx f(x) \cos(\omega x)
@end example
@end ifinfo

@noindent
The results are extrapolated using the epsilon-algorithm to accelerate
the convergence of the integral. The function returns the final
approximation from the extrapolation, @var{result}, and an estimate of
the absolute error, @var{abserr}.

Those subintervals with ``large'' widths @math{d}, @math{d\omega > 4} are
computed using a 25-point Clenshaw-Curtis integration rule, which handles the
oscillatory behavior. Subintervals with a ``small'' width
@math{d\omega < 4} are computed using a 15-point Gauss-Kronrod integration.

@end deftypefun

@node  QAWF adaptive integration for Fourier integrals
@section QAWF adaptive integration for Fourier integrals
@cindex Fourier integrals, numerical

@deftypefun int gsl_integration_qawf (gsl_function * @var{f}, const double @var{a}, const double @var{epsabs}, const size_t @var{limit}, gsl_integration_workspace * @var{workspace}, gsl_integration_workspace * @var{cycle_workspace}, gsl_integration_qawo_workspace * @var{wf}, double *@var{result}, double *@var{abserr})

This function attempts to compute a Fourier integral of the function
@var{f} over the semi-infinite interval @math{[a,+\infty)}.

@tex
\beforedisplay
$$
\eqalign{
I & = \int_a^{+\infty} dx\, f(x) \left\{ \matrix{ \sin(\omega x) \cr
                                                 \cos(\omega x) } \right\}
}
$$
\afterdisplay
@end tex
@ifinfo
@example
I =  \int_a^@{+\infty@} dx f(x) \sin(\omega x)
I =  \int_a^@{+\infty@} dx f(x) \cos(\omega x)
@end example
@end ifinfo

The parameters are taken from the workspace @var{wf}, but the length
@var{L} can take any value. The integral is computed over the
subintervals,

@tex
\beforedisplay
$$
\eqalign{
C_1 & = [a, a + c] \cr
C_2 & = [a + c, a + 2c] \cr
\dots & = \dots \cr
C_k & = [a + (k-1) c, a + k c]
}
$$
\afterdisplay
@end tex
@ifinfo
@example
C_1 = [a, a + c]
C_2 = [a + c, a + 2 c]
... = ...
C_k = [a + (k-1) c, a + k c]
@end example
@end ifinfo

@noindent
where 
@c{$c = (2 \hbox{floor}(|\omega|) + 1) \pi/|\omega|$}
@math{c = (2 floor(|\omega|) + 1) \pi/|\omega|}. The width @math{c} is
chosen to cover an odd number of periods so that the contributions from
the intervals alternate in sign and are monotonically descreasing when
@var{f} is positive and monotically descreasing. The sum of this
sequence of contributions is accelerated using the epsilon-algorithm.

This function works to an absolute tolerance @var{abserr}. On each
interval @math{C_k} the algorithm tries to achieve the tolerance

@tex
\beforedisplay
$$
TOL_k = u_k abserr
$$
\afterdisplay
@end tex
@ifinfo
@example
TOL_k = u_k abserr
@end example
@end ifinfo

@noindent
where 
@c{$u_k = (1 - p)p^{k-1}$}
@math{u_k = (1 - p)p^@{k-1@}} and @math{p = 9/10}. If the integration of
a subinterval leads to difficulties then the accuracy requirement for
subsequent intervals is relaxed,

@tex
\beforedisplay
$$
TOL_i = u_i \max \{abserr, \max_{k<i}\{E_k\}\}
$$
\afterdisplay
@end tex
@ifinfo
@example
TOL_i = u_i \max@{abserr, \max_@{k<i@}@{E_k@}@}
@end example
@end ifinfo

@noindent
where @math{E_k} is the estimated error on the interval @math{C_k}.

@end deftypefun

@node Numerical integration examples
@section Numerical integration examples

The integrator @code{QAGS} will handle a large class of definite
integrals. For example, consider the following integral, which has a
algebraic-logarithmic singularity at the origin,

@tex
\beforedisplay
$$
\int_0^1 x^{-1/2} \log(x) \,dx = -4
$$
\afterdisplay
@end tex
@ifinfo
@example
\int_0^1 x^@{-1/2@} log(x) dx = -4
@end example
@end ifinfo

@noindent
The program below computes this integral using a relative accuracy bound of
@code{1e-7}. 

@example
#include <stdio.h>
#include <math.h>
#include <gsl_integration.h>

double f (double x, void * params) @{
  double alpha = *(double *) params ;
  double f = log(alpha*x) / sqrt(x);
  return f ;
@}

int 
main ()
@{
  gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
  
  double result, error;
  double expected = -4.0;
  double alpha = 1.0;

  gsl_function F;
  F.function = &f;
  F.params = &alpha;

  gsl_integration_qags (&F, 0, 1, 0, 1e-7, 1000, w, &result, &error); 

  printf("result          = % .18f\n", result);
  printf("exact result    = % .18f\n", expected);
  printf("estimated error = % .18f\n", error);
  printf("actual error    = % .18f\n",  result - expected);
  printf("intervals =  %d\n", w->size);
@}
@end example

@noindent
The results show that the desired accuracy is achieved after 8
subdivisions. In fact, the extrapolation procedure used by @code{QAGS}
produces an accuracy of almost twice as many digits.

@example
bash$ ./a.out 
result          = -3.999999999999973799
exact result    = -4.000000000000000000
estimated error =  0.000000000000246025
actual error    =  0.000000000000026201
intervals =  8
@end example

@noindent
The error estimate returned by the extrapolation procedure is larger
than the actual error, giving a margin of safety of one order of
magnitude.


@node Numerical integration References and Further Reading
@section Numerical integration  References and Further Reading

@noindent
The following book is the definitive reference for QUADPACK, and was
written by the original authors. It provides descriptions of the
algorithms, test programs, examples and useful advice on numerical
integration. It also includes many references to the numerical
integration literature used in developing QUADPACK.

@itemize @asis
@item
R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, D.K. Kahaner.
@cite{@sc{quadpack} A subroutine package for automatic integration}
Springer Verlag, 1983.
@end itemize
@noindent






