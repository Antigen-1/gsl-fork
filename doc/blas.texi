@cindex linear algebra, BLAS
@cindex matrix, operations
@cindex vector, operations
@cindex BLAS
@cindex CBLAS

The Basic Linear Algebra Subprograms (BLAS) define a set of fundamental
operations on vectors and matrices which can be used to create optimized
higher-level linear algebra functionality.

The library provides a low-level layer which corresponds directly to the
C-language BLAS standard, referred to here as ``CBLAS'', and a
higher-level interface for operations on GSL vectors and matrices.
Users who are interested in simple operations on GSL vector and matrix
objects should use the high-level layer, which is specified in the file
@code{gsl_blas.h}.  This should satisfy the needs of most users.  Note
that GSL matrices are implemented using dense-storage so the interface
only includes the corresponding dense-storage BLAS functions.  The full
BLAS functionality for band-format and packed-format matrices is
available through the low-level CBLAS interface.

The interface for the @code{gsl_cblas} layer is specified in the file
@code{gsl_cblas.h}.  This interface corresponds the BLAS Technical
Forum's draft standard for the C interface to legacy BLAS
implementations. Users who have access to other conforming CBLAS
implementations can use these in place of the version provided by the
library.  Note that users who have only a Fortran BLAS library can use a
CBLAS conformant wrapper to convert it into a CBLAS library.  A
reference CBLAS wrapper for legacy Fortran implementations exists as
part of the draft CBLAS standard and can be obtained from Netlib.

There are three levels of BLAS operations,

@table @b
@item Level 1
Vector operations, e.g. @math{y = \alpha x + y}
@item Level 2
Matrix-vector operations, e.g. @math{y = \alpha A x + \beta y}
@item Level 3
Matrix-matrix operations, e.g. @math{C = \alpha A B + C}
@end table
@noindent
Each routine has a name which specifies the operation, the type of
matrices involved and their precisions.  Some of the most common
operations and their names are given below,

@table @b
@item DOT
scalar product, @math{x^T y}
@item AXPY
vector sum, @math{\alpha x + y}
@item MV
matrix-vector product, @math{A x}
@item SV
matrix-vector solve, @math{inv(A) x}
@item MM
matrix-matrix product, @math{A B}
@item SM
matrix-matrix solve, @math{inv(A) B}
@end table
@noindent
The type of matrices are,

@table @b
@item GE
general
@item GB
general band
@item SY
symmetric
@item SB
symmetric band
@item SP
symmetric packed
@item HE
hermitian
@item HB
hermitian band
@item HP
hermitian packed
@item TR
triangular 
@item TB
triangular band
@item TP
triangular packed
@end table
@noindent
Each operation is defined for four precisions,

@table @b
@item S
single real
@item D
double real
@item C
single complex
@item Z
double complex
@end table
@noindent
Thus, for example, the name @sc{sgemm} stands for ``single-precision
general matrix-matrix multiply'' and @sc{zgemm} stands for
``double-precision complex matrix-matrix multiply''.

@menu
* GSL BLAS Interface::          
* CBLAS Library::               
* BLAS Examples::               
* BLAS References and Further Reading::  
@end menu

@node GSL BLAS Interface
@section GSL BLAS Interface

GSL provides dense vector and matrix objects, based on the relevant
built-in types.  The library provides an interface to the BLAS
operations which apply to these objects.  The interface to this
functionality is given in the file @code{gsl_blas.h}.

@comment CblasNoTrans, CblasTrans, CblasConjTrans
@comment CblasUpper, CblasLower
@comment CblasNonUnit, CblasUnit
@comment CblasLeft, CblasRight

@menu
* Level 1 GSL BLAS Interface::  
* Level 2 GSL BLAS Interface::  
* Level 3 GSL BLAS Interface::  
@end menu

@node Level 1 GSL BLAS Interface
@subsection Level 1 

@deftypefun int gsl_blas_sdsdot (float @var{alpha}, const gsl_vector_float * @var{X}, const gsl_vector_float * @var{Y}, float * @var{result})
@deftypefunx int gsl_blas_dsdot (const gsl_vector_float * @var{X}, const gsl_vector_float * @var{Y}, double * @var{result})
@cindex DOT, Level-1 BLAS
These functions compute the sum @math{\alpha + X^T Y} for the vectors
@var{X} and @var{Y}, returning the result in @var{result}.
@end deftypefun

@deftypefun int gsl_blas_sdot (const gsl_vector_float * @var{X}, const gsl_vector_float * @var{Y}, float * @var{result})
@deftypefunx int gsl_blas_ddot (const gsl_vector * @var{X}, const gsl_vector * @var{Y}, double * @var{result})
These functions compute the scalar product @math{X^T Y} for the vectors
@var{X} and @var{Y}, returning the result in @var{result}.
@end deftypefun

@deftypefun int gsl_blas_cdotu (const gsl_vector_complex_float * @var{X}, const gsl_vector_complex_float * @var{Y}, gsl_complex_float * @var{dotu})
@deftypefunx int gsl_blas_zdotu (const gsl_vector_complex * @var{X}, const gsl_vector_complex * @var{Y}, gsl_complex * @var{dotu})
These functions compute the complex scalar product @math{X^T Y} for the
vectors @var{X} and @var{Y}, returning the result in @var{result}
@end deftypefun

@deftypefun int gsl_blas_cdotc (const gsl_vector_complex_float * @var{X}, const gsl_vector_complex_float * @var{Y}, gsl_complex_float * @var{dotc})
@deftypefunx int gsl_blas_zdotc (const gsl_vector_complex * @var{X}, const gsl_vector_complex * @var{Y}, gsl_complex * @var{dotc})
These functions compute the complex conjugate scalar product @math{X^H
Y} for the vectors @var{X} and @var{Y}, returning the result in
@var{result}
@end deftypefun

@deftypefun float gsl_blas_snrm2 (const gsl_vector_float * @var{X})
@deftypefunx double gsl_blas_dnrm2 (const gsl_vector * @var{X})
@cindex NRM2, Level-1 BLAS
These functions compute the Euclidean norm 
@c{$||X||_2 = \sqrt{\sum x_i^2}$}
@math{||X||_2 = \sqrt @{\sum x_i^2@}} of the vector @var{X}.
@end deftypefun

@deftypefun float gsl_blas_scnrm2 (const gsl_vector_complex_float * @var{X})
@deftypefunx double gsl_blas_dznrm2 (const gsl_vector_complex * @var{X})
These functions compute the Euclidean norm 
@c{$||X||_2 = \sqrt{\sum (\Re(x_i)^2 + \Im(x_i)^2)}$} 
@math{||X||_2 = \sqrt @{\sum (\Re(x_i)^2 + \Im(x_i)^2)@}} 
of the complex vector @var{X}.
@end deftypefun

@deftypefun float gsl_blas_sasum (const gsl_vector_float * @var{X})
@deftypefunx double gsl_blas_dasum (const gsl_vector * @var{X})
@cindex ASUM, Level-1 BLAS
These functions compute the absolute sum @math{\sum |x_i|} of the
elements of the vector @var{X}.
@end deftypefun

@deftypefun float gsl_blas_scasum (const gsl_vector_complex_float * @var{X})
@deftypefunx double gsl_blas_dzasum (const gsl_vector_complex * @var{X})
These functions compute the absolute sum @math{\sum |\Re(x_i)| +
|\Im(x_i)|} of the elements of the vector @var{X}.
@end deftypefun

@deftypefun CBLAS_INDEX_t gsl_blas_isamax (const gsl_vector_float * @var{X})
@deftypefunx CBLAS_INDEX_t gsl_blas_idamax (const gsl_vector * @var{X})
@deftypefunx CBLAS_INDEX_t gsl_blas_icamax (const gsl_vector_complex_float * @var{X})
@deftypefunx CBLAS_INDEX_t gsl_blas_izamax (const gsl_vector_complex * @var{X})
@cindex AMAX, Level-1 BLAS
These functions return the index of the largest element of the vector
@var{X}. The largest element is determined by its absolute magnitude for
real vector and by the sum of the magnitudes of the real and imaginary
parts @math{|\Re(x_i)| + |\Im(x_i)|} for complex vectors.  If the
largest value occurs several times then the index of the first
occurrence is returned.
@end deftypefun

@deftypefun int gsl_blas_sswap (gsl_vector_float * @var{X}, gsl_vector_float * @var{Y})
@deftypefunx int gsl_blas_dswap (gsl_vector * @var{X}, gsl_vector * @var{Y})
@deftypefunx int gsl_blas_cswap (gsl_vector_complex_float * @var{X}, gsl_vector_complex_float * @var{Y})
@deftypefunx int gsl_blas_zswap (gsl_vector_complex * @var{X}, gsl_vector_complex * @var{Y})
@cindex SWAP, Level-1 BLAS
These functions exchange the elements of the vectors @var{X} and @var{Y}.
@end deftypefun

@deftypefun int gsl_blas_scopy (const gsl_vector_float * @var{X}, gsl_vector_float * @var{Y})
@deftypefunx int gsl_blas_dcopy (const gsl_vector * @var{X}, gsl_vector * @var{Y})
@deftypefunx int gsl_blas_ccopy (const gsl_vector_complex_float * @var{X}, gsl_vector_complex_float * @var{Y})
@deftypefunx int gsl_blas_zcopy (const gsl_vector_complex * @var{X}, gsl_vector_complex * @var{Y})
@cindex COPY, Level-1 BLAS
These functions copy the elements of the vector @var{X} into the vector
@var{Y}.
@end deftypefun


@deftypefun int gsl_blas_saxpy (float @var{alpha}, const gsl_vector_float * @var{X}, gsl_vector_float * @var{Y})
@deftypefunx int gsl_blas_daxpy (double @var{alpha}, const gsl_vector * @var{X}, gsl_vector * @var{Y})
@deftypefunx int gsl_blas_caxpy (const gsl_complex_float @var{alpha}, const gsl_vector_complex_float * @var{X}, gsl_vector_complex_float * @var{Y})
@deftypefunx int gsl_blas_zaxpy (const gsl_complex @var{alpha}, const gsl_vector_complex * @var{X}, gsl_vector_complex * @var{Y})
@cindex AXPY, Level-1 BLAS
These functions compute the sum @math{Y = \alpha X + Y} for the vectors
@var{X} and @var{Y}.
@end deftypefun

@deftypefun void gsl_blas_sscal (float @var{alpha}, gsl_vector_float * @var{X})
@deftypefunx void gsl_blas_dscal (double @var{alpha}, gsl_vector * @var{X})
@deftypefunx void gsl_blas_cscal (const gsl_complex_float @var{alpha}, gsl_vector_complex_float * @var{X})
@deftypefunx void gsl_blas_zscal (const gsl_complex @var{alpha}, gsl_vector_complex * @var{X})
@deftypefunx void gsl_blas_csscal (float @var{alpha}, gsl_vector_complex_float * @var{X})
@deftypefunx void gsl_blas_zdscal (double @var{alpha}, gsl_vector_complex * @var{X})
@cindex SCAL, Level-1 BLAS
These functions rescale the vector @var{X} by the multiplicative factor
@var{alpha}.
@end deftypefun

@deftypefun int gsl_blas_srotg (float a[], float b[], float c[], float s[])
@deftypefunx int gsl_blas_drotg (double a[], double b[], double c[], double s[])
@cindex ROTG, Level-1 BLAS
@cindex Givens Rotation, BLAS
These functions compute a Givens rotation @math{(c,s)} which zeroes the
vector @math{(a,b)},

@tex
\beforedisplay
$$
\left(
\matrix{c&s\cr
-s&c\cr}
\right)
\left(
\matrix{a\cr
b\cr}
\right)
=
\left(
\matrix{r'\cr
0\cr}
\right)
$$
\afterdisplay
@end tex
@ifinfo
@example
[  c  s ] [ a ] = [ r ]
[ -s  c ] [ b ]   [ 0 ]
@end example
@end ifinfo
@noindent
The variables @var{a} and @var{b} are overwritten by the routine.
@end deftypefun

@deftypefun int gsl_blas_srot (gsl_vector_float * @var{X}, gsl_vector_float * @var{Y}, float @var{c}, float @var{s})
@deftypefunx int gsl_blas_drot (gsl_vector * @var{X}, gsl_vector * @var{Y}, const double @var{c}, const double @var{s})
These functions apply a Givens rotation @math{(X', Y') = (c X + s Y, -s
X + c Y)} to the vectors @var{X}, @var{Y}.
@end deftypefun

@deftypefun int gsl_blas_srotmg (float d1[], float d2[], float b1[], float @var{b2}, float P[])
@deftypefunx int gsl_blas_drotmg (double d1[], double d2[], double b1[], double @var{b2}, double P[])
@cindex Modified Givens Rotation, BLAS
@cindex Givens Rotation, Modified, BLAS
These functions compute a modified Given's transformation.
@end deftypefun

@deftypefun int gsl_blas_srotm (gsl_vector_float * @var{X}, gsl_vector_float * @var{Y}, const float P[])
@deftypefunx int gsl_blas_drotm (gsl_vector * @var{X}, gsl_vector * @var{Y}, const double P[])
These functions apply a modified Given's transformation.
@end deftypefun

@node Level 2 GSL BLAS Interface
@subsection Level 2 

@deftypefun int gsl_blas_sgemv (CBLAS_TRANSPOSE_t @var{TransA}, float @var{alpha}, const gsl_matrix_float * @var{A}, const gsl_vector_float * @var{X}, float @var{beta}, gsl_vector_float * @var{Y})
@deftypefunx int gsl_blas_dgemv (CBLAS_TRANSPOSE_t @var{TransA}, double @var{alpha}, const gsl_matrix * @var{A}, const gsl_vector * @var{X}, double @var{beta}, gsl_vector * @var{Y})
@deftypefunx int gsl_blas_cgemv (CBLAS_TRANSPOSE_t @var{TransA}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_vector_complex_float * @var{X}, const gsl_complex_float @var{beta}, gsl_vector_complex_float * @var{Y})
@deftypefunx int gsl_blas_zgemv (CBLAS_TRANSPOSE_t @var{TransA}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_vector_complex * @var{X}, const gsl_complex @var{beta}, gsl_vector_complex * @var{Y})
@cindex GEMV, Level-2 BLAS
These functions compute the matrix-vector product and sum @math{Y =
\alpha op(A) X + \beta Y}, where @math{op(A) = A},
@math{A^T}, @math{A^H} for @var{TransA} = @code{CblasNoTrans},
@code{CblasTrans}, @code{CblasConjTrans}.
@end deftypefun


@deftypefun int gsl_blas_strmv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix_float * @var{A}, gsl_vector_float * @var{X})
@deftypefunx int gsl_blas_dtrmv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix * @var{A}, gsl_vector * @var{X})
@deftypefunx int gsl_blas_ctrmv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix_complex_float * @var{A}, gsl_vector_complex_float * @var{X})
@deftypefunx int gsl_blas_ztrmv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix_complex * @var{A}, gsl_vector_complex * @var{X})
@cindex TRMV, Level-2 BLAS
These functions compute the matrix-vector product and sum 
@math{Y =\alpha op(A) X + \beta Y} for the triangular matrix @var{A}, where
@math{op(A) = A}, @math{A^T}, @math{A^H} for @var{TransA} =
@code{CblasNoTrans}, @code{CblasTrans}, @code{CblasConjTrans}.  When
@var{Uplo} is @code{CblasUpper} then the upper triangle of @var{A} is
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
of @var{A} is used.  If @var{Diag} is @code{CblasNonUnit} then the
diagonal of the matrix is used, but if @var{Diag} is @code{CblasUnit}
then the diagonal elements of the matrix @var{A} are taken as unity and
are not referenced.
@end deftypefun


@deftypefun int gsl_blas_strsv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix_float * @var{A}, gsl_vector_float * @var{X})
@deftypefunx int gsl_blas_dtrsv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix * @var{A}, gsl_vector * @var{X})
@deftypefunx int gsl_blas_ctrsv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix_complex_float * @var{A}, gsl_vector_complex_float * @var{X})
@deftypefunx int gsl_blas_ztrsv (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_matrix_complex * @var{A}, gsl_vector_complex *@var{X})
@cindex TRSV, Level-2 BLAS
These functions compute @math{inv(op(A)) X} for @var{X}, where
@math{op(A) = A}, @math{A^T}, @math{A^H} for @var{TransA} =
@code{CblasNoTrans}, @code{CblasTrans}, @code{CblasConjTrans}.  When
@var{Uplo} is @code{CblasUpper} then the upper triangle of @var{A} is
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
of @var{A} is used.  If @var{Diag} is @code{CblasNonUnit} then the
diagonal of the matrix is used, but if @var{Diag} is @code{CblasUnit}
then the diagonal elements of the matrix @var{A} are taken as unity and
are not referenced.
@end deftypefun


@deftypefun int gsl_blas_ssymv (CBLAS_UPLO_t @var{Uplo}, float @var{alpha}, const gsl_matrix_float * @var{A}, const gsl_vector_float * @var{X}, float @var{beta}, gsl_vector_float * @var{Y})
@deftypefunx int gsl_blas_dsymv (CBLAS_UPLO_t @var{Uplo}, double @var{alpha}, const gsl_matrix * @var{A}, const gsl_vector * @var{X}, double @var{beta}, gsl_vector * @var{Y})
@cindex SYMV, Level-2 BLAS
These functions compute the matrix-vector product and sum @math{Y =
\alpha A X + \beta Y} for the symmetric matrix @var{A}.  Since the
matrix @var{A} is symmetric only its upper half or lower half need to be
stored.  When @var{Uplo} is @code{CblasUpper} then the upper triangle
and diagonal of @var{A} are used, and when @var{Uplo} is
@code{CblasLower} then the lower triangle and diagonal of @var{A} are
used.
@end deftypefun

@deftypefun int gsl_blas_chemv (CBLAS_UPLO_t @var{Uplo}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_vector_complex_float * @var{X}, const gsl_complex_float @var{beta}, gsl_vector_complex_float * @var{Y})
@deftypefunx int gsl_blas_zhemv (CBLAS_UPLO_t @var{Uplo}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_vector_complex * @var{X}, const gsl_complex @var{beta}, gsl_vector_complex * @var{Y})
@cindex HEMV, Level-2 BLAS
These functions compute the matrix-vector product and sum @math{Y =
\alpha A X + \beta Y} for the hermitian matrix @var{A}.  Since the
matrix @var{A} is hermitian only its upper half or lower half need to be
stored.  When @var{Uplo} is @code{CblasUpper} then the upper triangle
and diagonal of @var{A} are used, and when @var{Uplo} is
@code{CblasLower} then the lower triangle and diagonal of @var{A} are
used.  The imaginary elements of the diagonal are automatically assumed
to be zero and are not referenced.
@end deftypefun

@deftypefun int gsl_blas_sger (float @var{alpha}, const gsl_vector_float * @var{X}, const gsl_vector_float * @var{Y}, gsl_matrix_float * @var{A})
@deftypefunx int gsl_blas_dger (double @var{alpha}, const gsl_vector * @var{X}, const gsl_vector * @var{Y}, gsl_matrix * @var{A})
@deftypefunx int gsl_blas_cgeru (const gsl_complex_float @var{alpha}, const gsl_vector_complex_float * @var{X}, const gsl_vector_complex_float * @var{Y}, gsl_matrix_complex_float * @var{A})
@deftypefunx int gsl_blas_zgeru (const gsl_complex @var{alpha}, const gsl_vector_complex * @var{X}, const gsl_vector_complex * @var{Y}, gsl_matrix_complex * @var{A})
@cindex GER, Level-2 BLAS
@cindex GERU, Level-2 BLAS
These functions compute the rank-1 update @math{A = \alpha X Y^T + A} of
the matrix @var{A}.
@end deftypefun

@deftypefun int gsl_blas_cgerc (const gsl_complex_float @var{alpha}, const gsl_vector_complex_float * @var{X}, const gsl_vector_complex_float * @var{Y}, gsl_matrix_complex_float * @var{A})
@deftypefunx int gsl_blas_zgerc (const gsl_complex @var{alpha}, const gsl_vector_complex * @var{X}, const gsl_vector_complex * @var{Y}, gsl_matrix_complex * @var{A})
@cindex GERC, Level-2 BLAS
These functions compute the conjugate rank-1 update @math{A = \alpha X
Y^H + A} of the matrix @var{A}.
@end deftypefun

@deftypefun int gsl_blas_ssyr (CBLAS_UPLO_t @var{Uplo}, float @var{alpha}, const gsl_vector_float * @var{X}, gsl_matrix_float * @var{A})
@deftypefunx int gsl_blas_dsyr (CBLAS_UPLO_t @var{Uplo}, double @var{alpha}, const gsl_vector * @var{X}, gsl_matrix * @var{A})
@cindex SYR, Level-2 BLAS
These functions compute the symmetric rank-1 update @math{A = \alpha X
X^T + A} of the symmetric matrix @var{A}.  Since the matrix @var{A} is
symmetric only its upper half or lower half need to be stored.  When
@var{Uplo} is @code{CblasUpper} then the upper triangle and diagonal of
@var{A} are used, and when @var{Uplo} is @code{CblasLower} then the
lower triangle and diagonal of @var{A} are used.
@end deftypefun

@deftypefun int gsl_blas_cher (CBLAS_UPLO_t @var{Uplo}, float @var{alpha}, const gsl_vector_complex_float * @var{X}, gsl_matrix_complex_float * @var{A})
@deftypefunx int gsl_blas_zher (CBLAS_UPLO_t @var{Uplo}, double @var{alpha}, const gsl_vector_complex * @var{X}, gsl_matrix_complex * @var{A})
@cindex HER, Level-2 BLAS
These functions compute the hermitian rank-1 update @math{A = \alpha X
X^H + A} of the hermitian matrix @var{A}.  Since the matrix @var{A} is
hermitian only its upper half or lower half need to be stored.  When
@var{Uplo} is @code{CblasUpper} then the upper triangle and diagonal of
@var{A} are used, and when @var{Uplo} is @code{CblasLower} then the
lower triangle and diagonal of @var{A} are used.  The imaginary elements
of the diagonal are automatically set to zero.
@end deftypefun

@deftypefun int gsl_blas_ssyr2 (CBLAS_UPLO_t @var{Uplo}, float @var{alpha}, const gsl_vector_float * @var{X}, const gsl_vector_float * @var{Y}, gsl_matrix_float * @var{A})
@deftypefunx int gsl_blas_dsyr2 (CBLAS_UPLO_t @var{Uplo}, double @var{alpha}, const gsl_vector * @var{X}, const gsl_vector * @var{Y}, gsl_matrix * @var{A})
@cindex SYR2, Level-2 BLAS
These functions compute the symmetric rank-2 update @math{A = \alpha X
Y^T + \alpha Y X^T + A} of the symmetric matrix @var{A}.  Since the
matrix @var{A} is symmetric only its upper half or lower half need to be
stored.  When @var{Uplo} is @code{CblasUpper} then the upper triangle
and diagonal of @var{A} are used, and when @var{Uplo} is
@code{CblasLower} then the lower triangle and diagonal of @var{A} are
used.
@end deftypefun

@deftypefun int gsl_blas_cher2 (CBLAS_UPLO_t @var{Uplo}, const gsl_complex_float @var{alpha}, const gsl_vector_complex_float * @var{X}, const gsl_vector_complex_float * @var{Y}, gsl_matrix_complex_float * @var{A})
@deftypefunx int gsl_blas_zher2 (CBLAS_UPLO_t @var{Uplo}, const gsl_complex @var{alpha}, const gsl_vector_complex * @var{X}, const gsl_vector_complex * @var{Y}, gsl_matrix_complex * @var{A})
@cindex HER2, Level-2 BLAS
These functions compute the hermitian rank-2 update @math{A = \alpha X
Y^H + \alpha^* Y X^H A} of the hermitian matrix @var{A}.  Since the
matrix @var{A} is hermitian only its upper half or lower half need to be
stored.  When @var{Uplo} is @code{CblasUpper} then the upper triangle
and diagonal of @var{A} are used, and when @var{Uplo} is
@code{CblasLower} then the lower triangle and diagonal of @var{A} are
used.  The imaginary elements of the diagonal are automatically set to zero.
@end deftypefun

@node Level 3 GSL BLAS Interface
@subsection Level 3


@deftypefun int gsl_blas_sgemm (CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_TRANSPOSE_t @var{TransB}, float @var{alpha}, const gsl_matrix_float * @var{A}, const gsl_matrix_float * @var{B}, float @var{beta}, gsl_matrix_float * @var{C})
@deftypefunx int gsl_blas_dgemm (CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_TRANSPOSE_t @var{TransB}, double @var{alpha}, const gsl_matrix * @var{A}, const gsl_matrix * @var{B}, double @var{beta}, gsl_matrix * @var{C})
@deftypefunx int gsl_blas_cgemm (CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_TRANSPOSE_t @var{TransB}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_matrix_complex_float * @var{B}, const gsl_complex_float @var{beta}, gsl_matrix_complex_float * @var{C})
@deftypefunx int gsl_blas_zgemm (CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_TRANSPOSE_t @var{TransB}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_matrix_complex * @var{B}, const gsl_complex @var{beta}, gsl_matrix_complex * @var{C})
@cindex GEMM, Level-3 BLAS
These functions compute the matrix-matrix product and sum @math{C =
\alpha op(A) op(B) + \beta C} where @math{op(A) = A}, @math{A^T},
@math{A^H} for @var{TransA} = @code{CblasNoTrans}, @code{CblasTrans},
@code{CblasConjTrans} and similarly for the parameter @var{TransB}.
@end deftypefun


@deftypefun int gsl_blas_ssymm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, float @var{alpha}, const gsl_matrix_float * @var{A}, const gsl_matrix_float * @var{B}, float @var{beta}, gsl_matrix_float * @var{C})
@deftypefunx int gsl_blas_dsymm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, double @var{alpha}, const gsl_matrix * @var{A}, const gsl_matrix * @var{B}, double @var{beta}, gsl_matrix * @var{C})
@deftypefunx int gsl_blas_csymm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_matrix_complex_float * @var{B}, const gsl_complex_float @var{beta}, gsl_matrix_complex_float * @var{C})
@deftypefunx int gsl_blas_zsymm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_matrix_complex * @var{B}, const gsl_complex @var{beta}, gsl_matrix_complex * @var{C})
@cindex SYMM, Level-3 BLAS
These functions compute the matrix-matrix product and sum @math{C =
\alpha A B + \beta C} for @var{Side} is @code{CblasLeft} and @math{C =
\alpha B A + \beta C} for @var{Side} is @code{CblasRight}, where the
matrix @var{A} is symmetric.  When @var{Uplo} is @code{CblasUpper} then
the upper triangle and diagonal of @var{A} are used, and when @var{Uplo}
is @code{CblasLower} then the lower triangle and diagonal of @var{A} are
used.
@end deftypefun

@deftypefun int gsl_blas_chemm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_matrix_complex_float * @var{B}, const gsl_complex_float @var{beta}, gsl_matrix_complex_float * @var{C})
@deftypefunx int gsl_blas_zhemm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_matrix_complex * @var{B}, const gsl_complex @var{beta}, gsl_matrix_complex * @var{C})
@cindex HEMM, Level-3 BLAS
These functions compute the matrix-matrix product and sum @math{C =
\alpha A B + \beta C} for @var{Side} is @code{CblasLeft} and @math{C =
\alpha B A + \beta C} for @var{Side} is @code{CblasRight}, where the
matrix @var{A} is hermitian.  When @var{Uplo} is @code{CblasUpper} then
the upper triangle and diagonal of @var{A} are used, and when @var{Uplo}
is @code{CblasLower} then the lower triangle and diagonal of @var{A} are
used.  The imaginary elements of the diagonal are automatically set to
zero.
@end deftypefun

@deftypefun int gsl_blas_strmm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, float @var{alpha}, const gsl_matrix_float * @var{A}, gsl_matrix_float * @var{B})
@deftypefunx int gsl_blas_dtrmm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, double @var{alpha}, const gsl_matrix * @var{A}, gsl_matrix * @var{B})
@deftypefunx int gsl_blas_ctrmm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, gsl_matrix_complex_float * @var{B})
@deftypefunx int gsl_blas_ztrmm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, gsl_matrix_complex * @var{B})
@cindex TRMM, Level-3 BLAS
These functions compute the matrix-matrix product @math{B = \alpha op(A)
B} for @var{Side} is @code{CblasLeft} and @math{B = \alpha B op(A)} for
@var{Side} is @code{CblasRight}.  The matrix @var{A} is triangular and
@math{op(A) = A}, @math{A^T}, @math{A^H} for @var{TransA} =
@code{CblasNoTrans}, @code{CblasTrans}, @code{CblasConjTrans} When
@var{Uplo} is @code{CblasUpper} then the upper triangle of @var{A} is
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
of @var{A} is used.  If @var{Diag} is @code{CblasNonUnit} then the
diagonal of @var{A} is used, but if @var{Diag} is @code{CblasUnit} then
the diagonal elements of the matrix @var{A} are taken as unity and are
not referenced.
@end deftypefun


@deftypefun int gsl_blas_strsm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, float @var{alpha}, const gsl_matrix_float * @var{A}, gsl_matrix_float * @var{B})
@deftypefunx int gsl_blas_dtrsm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, double @var{alpha}, const gsl_matrix * @var{A}, gsl_matrix * @var{B})
@deftypefunx int gsl_blas_ctrsm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, gsl_matrix_complex_float * @var{B})
@deftypefunx int gsl_blas_ztrsm (CBLAS_SIDE_t @var{Side}, CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{TransA}, CBLAS_DIAG_t @var{Diag}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, gsl_matrix_complex * @var{B})
@cindex TRSM, Level-3 BLAS
These functions compute the matrix-matrix product @math{B = \alpha op(inv(A))
B} for @var{Side} is @code{CblasLeft} and @math{B = \alpha B op(inv(A))} for
@var{Side} is @code{CblasRight}.  The matrix @var{A} is triangular and
@math{op(A) = A}, @math{A^T}, @math{A^H} for @var{TransA} =
@code{CblasNoTrans}, @code{CblasTrans}, @code{CblasConjTrans} When
@var{Uplo} is @code{CblasUpper} then the upper triangle of @var{A} is
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
of @var{A} is used.  If @var{Diag} is @code{CblasNonUnit} then the
diagonal of @var{A} is used, but if @var{Diag} is @code{CblasUnit} then
the diagonal elements of the matrix @var{A} are taken as unity and are
not referenced.
@end deftypefun

@deftypefun int gsl_blas_ssyrk (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, float @var{alpha}, const gsl_matrix_float * @var{A}, float @var{beta}, gsl_matrix_float * @var{C})
@deftypefunx int gsl_blas_dsyrk (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, double @var{alpha}, const gsl_matrix * @var{A}, double @var{beta}, gsl_matrix * @var{C})
@deftypefunx int gsl_blas_csyrk (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_complex_float @var{beta}, gsl_matrix_complex_float * @var{C})
@deftypefunx int gsl_blas_zsyrk (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_complex @var{beta}, gsl_matrix_complex * @var{C})
@cindex SYRK, Level-3 BLAS
These functions compute a rank-k update of the symmetric matrix @var{C},
@math{C = \alpha A A^T + \beta C} when @var{Trans} is
@code{CblasNoTrans} and @math{C = \alpha A^T A + \beta C} when
@var{Trans} is @code{CblasTrans}.  Since the matrix @var{C} is symmetric
only its upper half or lower half need to be stored.  When @var{Uplo} is
@code{CblasUpper} then the upper triangle and diagonal of @var{C} are
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
and diagonal of @var{C} are used.
@end deftypefun

@deftypefun int gsl_blas_cherk (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, float @var{alpha}, const gsl_matrix_complex_float * @var{A}, float @var{beta}, gsl_matrix_complex_float * @var{C})
@deftypefunx int gsl_blas_zherk (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, double @var{alpha}, const gsl_matrix_complex * @var{A}, double @var{beta}, gsl_matrix_complex * @var{C})
@cindex HERK, Level-3 BLAS
These functions compute a rank-k update of the hermitian matrix @var{C},
@math{C = \alpha A A^H + \beta C} when @var{Trans} is
@code{CblasNoTrans} and @math{C = \alpha A^H A + \beta C} when
@var{Trans} is @code{CblasTrans}.  Since the matrix @var{C} is hermitian
only its upper half or lower half need to be stored.  When @var{Uplo} is
@code{CblasUpper} then the upper triangle and diagonal of @var{C} are
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
and diagonal of @var{C} are used.  The imaginary elements of the
diagonal are automatically set to zero.
@end deftypefun

@deftypefun int gsl_blas_ssyr2k (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, float @var{alpha}, const gsl_matrix_float * @var{A}, const gsl_matrix_float * @var{B}, float @var{beta}, gsl_matrix_float * @var{C})
@deftypefunx int gsl_blas_dsyr2k (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, double @var{alpha}, const gsl_matrix * @var{A}, const gsl_matrix * @var{B}, double @var{beta}, gsl_matrix * @var{C})
@deftypefunx int gsl_blas_csyr2k (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_matrix_complex_float * @var{B}, const gsl_complex_float @var{beta}, gsl_matrix_complex_float * @var{C})
@deftypefunx int gsl_blas_zsyr2k (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_matrix_complex * @var{B}, const gsl_complex @var{beta}, gsl_matrix_complex *@var{C})
@cindex SYR2K, Level-3 BLAS
These functions compute a rank-2k update of the symmetric matrix @var{C},
@math{C = \alpha A B^T + \alpha B A^T + \beta C} when @var{Trans} is
@code{CblasNoTrans} and @math{C = \alpha A^T B + \alpha B^T A + \beta C} when
@var{Trans} is @code{CblasTrans}.  Since the matrix @var{C} is symmetric
only its upper half or lower half need to be stored.  When @var{Uplo} is
@code{CblasUpper} then the upper triangle and diagonal of @var{C} are
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
and diagonal of @var{C} are used.
@end deftypefun

@deftypefun int gsl_blas_cher2k (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, const gsl_complex_float @var{alpha}, const gsl_matrix_complex_float * @var{A}, const gsl_matrix_complex_float * @var{B}, float @var{beta}, gsl_matrix_complex_float * @var{C})
@deftypefunx int gsl_blas_zher2k (CBLAS_UPLO_t @var{Uplo}, CBLAS_TRANSPOSE_t @var{Trans}, const gsl_complex @var{alpha}, const gsl_matrix_complex * @var{A}, const gsl_matrix_complex * @var{B}, double @var{beta}, gsl_matrix_complex * @var{C})
@cindex HER2K, Level-3 BLAS
These functions compute a rank-2k update of the hermitian matrix @var{C},
@math{C = \alpha A B^H + \alpha^* B A^H + \beta C} when @var{Trans} is
@code{CblasNoTrans} and @math{C = \alpha A^H B + \alpha^* B^H A + \beta C} when
@var{Trans} is @code{CblasTrans}.  Since the matrix @var{C} is hermitian
only its upper half or lower half need to be stored.  When @var{Uplo} is
@code{CblasUpper} then the upper triangle and diagonal of @var{C} are
used, and when @var{Uplo} is @code{CblasLower} then the lower triangle
and diagonal of @var{C} are used.  The imaginary elements of the
diagonal are automatically set to zero.
@end deftypefun

@node CBLAS Library
@section CBLAS Library
@cindex Low-level CBLAS
@cindex CBLAS, Low-level interface

The prototypes for the low-level @sc{cblas} functions are specified in
the file @code{gsl_cblas.h}.  For the definition of the functions
consult the papers listed in the references or the documentation
available from Netlib.

@menu
* Level 1 CBLAS Functions::     
* Level 2 CBLAS Functions::     
* Level 3 CBLAS Functions::     
@end menu

@node Level 1 CBLAS Functions
@subsection Level 1 

@deftypefun float cblas_sdsdot (const int @var{N}, const float @var{alpha}, const float *@var{X}, const int @var{incX}, const float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun double cblas_dsdot (const int @var{N}, const float *@var{X}, const int @var{incX}, const float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun float cblas_sdot (const int @var{N}, const float *@var{X}, const int @var{incX}, const float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun double cblas_ddot (const int @var{N}, const double *@var{X}, const int @var{incX}, const double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_cdotu_sub (const int @var{N}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{dotu})
@end deftypefun

@deftypefun void cblas_cdotc_sub (const int @var{N}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{dotc})
@end deftypefun

@deftypefun void cblas_zdotu_sub (const int @var{N}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{dotu})
@end deftypefun

@deftypefun void cblas_zdotc_sub (const int @var{N}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{dotc})
@end deftypefun

@deftypefun float cblas_snrm2 (const int @var{N}, const float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun float cblas_sasum (const int @var{N}, const float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun double cblas_dnrm2 (const int @var{N}, const double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun double cblas_dasum (const int @var{N}, const double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun float cblas_scnrm2 (const int @var{N}, const void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun float cblas_scasum (const int @var{N}, const void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun double cblas_dznrm2 (const int @var{N}, const void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun double cblas_dzasum (const int @var{N}, const void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun CBLAS_INDEX cblas_isamax (const int @var{N}, const float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun CBLAS_INDEX cblas_idamax (const int @var{N}, const double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun CBLAS_INDEX cblas_icamax (const int @var{N}, const void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun CBLAS_INDEX cblas_izamax (const int @var{N}, const void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_sswap (const int @var{N}, float *@var{X}, const int @var{incX}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_scopy (const int @var{N}, const float *@var{X}, const int @var{incX}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_saxpy (const int @var{N}, const float @var{alpha}, const float *@var{X}, const int @var{incX}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_dswap (const int @var{N}, double *@var{X}, const int @var{incX}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_dcopy (const int @var{N}, const double *@var{X}, const int @var{incX}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_daxpy (const int @var{N}, const double @var{alpha}, const double *@var{X}, const int @var{incX}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_cswap (const int @var{N}, void *@var{X}, const int @var{incX}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_ccopy (const int @var{N}, const void *@var{X}, const int @var{incX}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_caxpy (const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_zswap (const int @var{N}, void *@var{X}, const int @var{incX}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_zcopy (const int @var{N}, const void *@var{X}, const int @var{incX}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_zaxpy (const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_srotg (float *@var{a}, float *@var{b}, float *@var{c}, float *@var{s})
@end deftypefun

@deftypefun void cblas_srotmg (float *@var{d1}, float *@var{d2}, float *@var{b1}, const float @var{b2}, float *@var{P})
@end deftypefun

@deftypefun void cblas_srot (const int @var{N}, float *@var{X}, const int @var{incX}, float *@var{Y}, const int @var{incY}, const float @var{c}, const float @var{s})
@end deftypefun

@deftypefun void cblas_srotm (const int @var{N}, float *@var{X}, const int @var{incX}, float *@var{Y}, const int @var{incY}, const float *@var{P})
@end deftypefun

@deftypefun void cblas_drotg (double *@var{a}, double *@var{b}, double *@var{c}, double *@var{s})
@end deftypefun

@deftypefun void cblas_drotmg (double *@var{d1}, double *@var{d2}, double *@var{b1}, const double @var{b2}, double *@var{P})
@end deftypefun

@deftypefun void cblas_drot (const int @var{N}, double *@var{X}, const int @var{incX}, double *@var{Y}, const int @var{incY}, const double @var{c}, const double @var{s})
@end deftypefun

@deftypefun void cblas_drotm (const int @var{N}, double *@var{X}, const int @var{incX}, double *@var{Y}, const int @var{incY}, const double *@var{P})
@end deftypefun

@deftypefun void cblas_sscal (const int @var{N}, const float @var{alpha}, float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_dscal (const int @var{N}, const double @var{alpha}, double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_cscal (const int @var{N}, const void *@var{alpha}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_zscal (const int @var{N}, const void *@var{alpha}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_csscal (const int @var{N}, const float @var{alpha}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_zdscal (const int @var{N}, const double @var{alpha}, void *@var{X}, const int @var{incX})
@end deftypefun

@node Level 2 CBLAS Functions
@subsection Level 2 

@deftypefun void cblas_sgemv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float *@var{X}, const int @var{incX}, const float @var{beta}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_sgbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const int @var{KL}, const int @var{KU}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float *@var{X}, const int @var{incX}, const float @var{beta}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_strmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const float *@var{A}, const int @var{lda}, float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_stbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const float *@var{A}, const int @var{lda}, float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_stpmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const float *@var{Ap}, float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_strsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const float *@var{A}, const int @var{lda}, float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_stbsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const float *@var{A}, const int @var{lda}, float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_stpsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const float *@var{Ap}, float *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_dgemv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double *@var{X}, const int @var{incX}, const double @var{beta}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_dgbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const int @var{KL}, const int @var{KU}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double *@var{X}, const int @var{incX}, const double @var{beta}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_dtrmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const double *@var{A}, const int @var{lda}, double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_dtbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const double *@var{A}, const int @var{lda}, double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_dtpmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const double *@var{Ap}, double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_dtrsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const double *@var{A}, const int @var{lda}, double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_dtbsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const double *@var{A}, const int @var{lda}, double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_dtpsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const double *@var{Ap}, double *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_cgemv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_cgbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const int @var{KL}, const int @var{KU}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_ctrmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ctbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ctpmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{Ap}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ctrsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ctbsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ctpsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{Ap}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_zgemv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_zgbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_TRANSPOSE @var{TransA}, const int @var{M}, const int @var{N}, const int @var{KL}, const int @var{KU}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_ztrmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ztbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ztpmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{Ap}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ztrsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ztbsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const int @var{K}, const void *@var{A}, const int @var{lda}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ztpsv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{N}, const void *@var{Ap}, void *@var{X}, const int @var{incX})
@end deftypefun

@deftypefun void cblas_ssymv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float *@var{X}, const int @var{incX}, const float @var{beta}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_ssbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const int @var{K}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float *@var{X}, const int @var{incX}, const float @var{beta}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_sspmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const float *@var{Ap}, const float *@var{X}, const int @var{incX}, const float @var{beta}, float *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_sger (const enum CBLAS_ORDER @var{order}, const int @var{M}, const int @var{N}, const float @var{alpha}, const float *@var{X}, const int @var{incX}, const float *@var{Y}, const int @var{incY}, float *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_ssyr (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const float *@var{X}, const int @var{incX}, float *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_sspr (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const float *@var{X}, const int @var{incX}, float *@var{Ap})
@end deftypefun

@deftypefun void cblas_ssyr2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const float *@var{X}, const int @var{incX}, const float *@var{Y}, const int @var{incY}, float *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_sspr2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const float *@var{X}, const int @var{incX}, const float *@var{Y}, const int @var{incY}, float *@var{A})
@end deftypefun

@deftypefun void cblas_dsymv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double *@var{X}, const int @var{incX}, const double @var{beta}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_dsbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const int @var{K}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double *@var{X}, const int @var{incX}, const double @var{beta}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_dspmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const double *@var{Ap}, const double *@var{X}, const int @var{incX}, const double @var{beta}, double *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_dger (const enum CBLAS_ORDER @var{order}, const int @var{M}, const int @var{N}, const double @var{alpha}, const double *@var{X}, const int @var{incX}, const double *@var{Y}, const int @var{incY}, double *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_dsyr (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const double *@var{X}, const int @var{incX}, double *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_dspr (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const double *@var{X}, const int @var{incX}, double *@var{Ap})
@end deftypefun

@deftypefun void cblas_dsyr2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const double *@var{X}, const int @var{incX}, const double *@var{Y}, const int @var{incY}, double *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_dspr2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const double *@var{X}, const int @var{incX}, const double *@var{Y}, const int @var{incY}, double *@var{A})
@end deftypefun

@deftypefun void cblas_chemv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_chbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_chpmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{Ap}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_cgeru (const enum CBLAS_ORDER @var{order}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_cgerc (const enum CBLAS_ORDER @var{order}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_cher (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const void *@var{X}, const int @var{incX}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_chpr (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const float @var{alpha}, const void *@var{X}, const int @var{incX}, void *@var{A})
@end deftypefun

@deftypefun void cblas_cher2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_chpr2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{Ap})
@end deftypefun

@deftypefun void cblas_zhemv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_zhbmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_zhpmv (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{Ap}, const void *@var{X}, const int @var{incX}, const void *@var{beta}, void *@var{Y}, const int @var{incY})
@end deftypefun

@deftypefun void cblas_zgeru (const enum CBLAS_ORDER @var{order}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_zgerc (const enum CBLAS_ORDER @var{order}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_zher (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const void *@var{X}, const int @var{incX}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_zhpr (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const double @var{alpha}, const void *@var{X}, const int @var{incX}, void *@var{A})
@end deftypefun

@deftypefun void cblas_zher2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{A}, const int @var{lda})
@end deftypefun

@deftypefun void cblas_zhpr2 (const enum CBLAS_ORDER @var{order}, const enum CBLAS_UPLO @var{Uplo}, const int @var{N}, const void *@var{alpha}, const void *@var{X}, const int @var{incX}, const void *@var{Y}, const int @var{incY}, void *@var{Ap})
@end deftypefun

@node Level 3 CBLAS Functions
@subsection Level 3 


@deftypefun void cblas_sgemm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_TRANSPOSE @var{TransB}, const int @var{M}, const int @var{N}, const int @var{K}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float *@var{B}, const int @var{ldb}, const float @var{beta}, float *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_ssymm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const int @var{M}, const int @var{N}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float *@var{B}, const int @var{ldb}, const float @var{beta}, float *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_ssyrk (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float @var{beta}, float *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_ssyr2k (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, const float *@var{B}, const int @var{ldb}, const float @var{beta}, float *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_strmm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, float *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_strsm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const float @var{alpha}, const float *@var{A}, const int @var{lda}, float *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_dgemm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_TRANSPOSE @var{TransB}, const int @var{M}, const int @var{N}, const int @var{K}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double *@var{B}, const int @var{ldb}, const double @var{beta}, double *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_dsymm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const int @var{M}, const int @var{N}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double *@var{B}, const int @var{ldb}, const double @var{beta}, double *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_dsyrk (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double @var{beta}, double *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_dsyr2k (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, const double *@var{B}, const int @var{ldb}, const double @var{beta}, double *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_dtrmm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, double *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_dtrsm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const double @var{alpha}, const double *@var{A}, const int @var{lda}, double *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_cgemm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_TRANSPOSE @var{TransB}, const int @var{M}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_csymm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_csyrk (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_csyr2k (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_ctrmm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, void *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_ctrsm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, void *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_zgemm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_TRANSPOSE @var{TransB}, const int @var{M}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_zsymm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_zsyrk (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_zsyr2k (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_ztrmm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, void *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_ztrsm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{TransA}, const enum CBLAS_DIAG @var{Diag}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, void *@var{B}, const int @var{ldb})
@end deftypefun

@deftypefun void cblas_chemm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_cherk (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const float @var{alpha}, const void *@var{A}, const int @var{lda}, const float @var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_cher2k (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const float @var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_zhemm (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_SIDE @var{Side}, const enum CBLAS_UPLO @var{Uplo}, const int @var{M}, const int @var{N}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const void *@var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_zherk (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const double @var{alpha}, const void *@var{A}, const int @var{lda}, const double @var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_zher2k (const enum CBLAS_ORDER @var{Order}, const enum CBLAS_UPLO @var{Uplo}, const enum CBLAS_TRANSPOSE @var{Trans}, const int @var{N}, const int @var{K}, const void *@var{alpha}, const void *@var{A}, const int @var{lda}, const void *@var{B}, const int @var{ldb}, const double @var{beta}, void *@var{C}, const int @var{ldc})
@end deftypefun

@deftypefun void cblas_xerbla (int @var{p}, const char *@var{rout}, const char *@var{form}, ...)
@end deftypefun

@node BLAS Examples
@section Examples

The following program computes the product of two matrices using the
Level-3 blas function @sc{sgemm},

@tex
\beforedisplay
$$
\left(
\matrix{0.11&0.12&0.13\cr
0.21&0.22&0.23\cr}
\right)
\left(
\matrix{1011&1012\cr
1021&1022\cr
1031&1031\cr}
\right)
=
\left(
\matrix{367.76&368.12\cr
674.06&674.72\cr}
\right)
$$
\afterdisplay
@end tex
@ifinfo
@example
[ 0.11 0.12 0.13 ]  [ 1011 1012 ]     [ 367.76 368.12 ]
[ 0.21 0.22 0.23 ]  [ 1021 1022 ]  =  [ 674.06 674.72 ]
                    [ 1031 1032 ]
@end example
@end ifinfo
@noindent
The matrices are stored in row major order but could be stored in column
major order if the first argument of the call to @code{cblas_sgemm} was
changed to @code{CblasColMajor}.

@example
#include <stdio.h>
#include <gsl/gsl_cblas.h>

int
main ()
@{
  int lda = 3;

  float A[] = @{ 0.11, 0.12, 0.13,
                0.21, 0.22, 0.23 @};

  int ldb = 2;
  
  float B[] = @{ 1011, 1012,
                1021, 1022,
                1031, 1032 @};

  int ldc = 2;

  float C[] = @{ 0.00, 0.00,
                0.00, 0.00 @};

  /* Compute C = A B */

  cblas_sgemm (CblasRowMajor, CblasNoTrans, CblasNoTrans, 2, 2, 3,
               1.0, A, lda, B, ldb, 0.0, C, ldc);

  printf("[ %g, %g\n", C[0], C[1]);
  printf("  %g, %g ]\n", C[2], C[3]);
  
@}
@end example
@noindent
To compile the program use the following command line,

@example
gcc demo.c -lgslcblas
@end example
@noindent
There is no need to link with the main library @code{-lgsl} in this
case as the CBLAS library is an independent unit. Here is the output
from the program,
@example
$ ./a.out
[ 367.76, 368.12
  674.06, 674.72 ]
@end example

@node BLAS References and Further Reading
@section References and Further Reading

Information on the BLAS standards, including both the legacy and draft
interface standards, is available online from the BLAS Homepage and BLAS
Technical Forum web-site.

@itemize @asis
@item
@cite{BLAS Homepage} 
@url{http://www.netlib.org/blas/}
@item
@cite{BLAS Technical Forum} 
@url{http://www.netlib.org/cgi-bin/checkout/blast/blast.pl}
@end itemize
@noindent
The following papers contain the specifications for Level 1, Level 2 and
Level 3 BLAS.

@itemize @asis
@item
C. Lawson, R. Hanson, D. Kincaid, F. Krogh, "Basic Linear Algebra
Subprograms for Fortran Usage", @cite{ACM Transactions on Mathematical
Software}, Vol. 5 (1979), Pages 308-325.

@item
J.J. Dongarra, J. DuCroz, S. Hammarling, R. Hanson, "An Extended Set of
Fortran Basic Linear Algebra Subprograms", @cite{ACM Transactions on
Mathematical Software}, Vol. 14, No. 1 (1988), Pages 1-32.

@item
J.J. Dongarra, I. Duff, J. DuCroz, S. Hammarling, "A Set of
Level 3 Basic Linear Algebra Subprograms", @cite{ACM Transactions on
Mathematical Software}, Vol. 16 (1990), Pages 1-28.
@end itemize
@noindent
Postscript versions of the latter two papers are available from
@url{http://www.netlib.org/blas/}. A CBLAS wrapper for Fortran BLAS
libraries is available from the same location.
