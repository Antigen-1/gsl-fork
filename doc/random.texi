@cindex random number generators

The @value{GSL} provides a large collection of random number generators
which can be accessed through a uniform interface. Environment variables
allow you to select different generators and seeds at runtime, so that
you can easily switch between generators without needing to recompile
your program. Each instance of a generator keeps track of its own state,
allowing the generators to be used in multi-threaded programs.
Additional functions are available for transforming uniform random
numbers into samples from continuous or discrete probability
distributions such as the gaussian, log-normal or poisson distributions.

@menu
* General comments on random numbers::  
* The Random Number Generator Interface::  
* Available random number generator algorithms::  
* Random Number Distributions::  
* Shuffling and Sampling::      
* Random Number References and Further Reading::  
* Random Number Acknowledgements::  
@end menu

@node General comments on random numbers
@section General comments on random numbers

In 1988, Park and Miller wrote a paper entitled ``Random number
generators: good ones are hard to find.'' [Commun. ACM, 31, 1192--1201].
Fortunately, some excellent random number generators are available,
though poor ones are still in common use.  You may be happy with the
system-supplied random number generator on your computer, but you should
be aware that as computers get faster, requirements on random number
generators increase.  Nowadays, a simulation that calls a random number
generator millions of times can often finish before you can make it down
the hall to the coffee machine and back.

A very nice review of random number generators was written by Pierre
L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, Jerry Banks,
ed. (Wiley, 1997). The chapter is available in postscript from from
L'Ecuyer's ftp site (see references). Knuth's volume on Seminumerical
Algorithms (originally published in 1968) devotes 170 pages to random
number generators, and has recently been updated in its 3rd edition
(1997).
@c is only now starting to show its age.
@c Nonetheless, 
It is brilliant, a classic. If you don't own it, you should stop reading
right now, run to the nearest bookstore, and buy it.

A good random number generator will satisfy both theoretical and
statistical properties.  Theoretical properties are often hard to obtain
(they require real math!), but one prefers a random number generator
with a long period, low serial correlation, and a tendency @emph{not} to
``fall mainly on the planes.''  Statistical tests are performed with
numerical simulations.  Generally, a random number generator is used to
estimate some quantity for which the theory of probability provides an
exact answer.  Comparison to this exact answer provides a measure of
``randomness''.

@node The Random Number Generator Interface
@section The Random Number Generator Interface

@menu
* Random number generator initialization::  
* Sampling from a random number generator::  
* Auxiliary random number generator functions::  
* Random number environment variables::  
* Saving and restoring random number generator state::  
@end menu

@node Random number generator initialization
@subsection Random number generator initialization

It is important to remember that a random number generator is not a
``real'' function like sine or cosine.  Unlike real functions, successive
calls to a random number generator yield different return values.  Of
course that is just what you want for a random number generator, but to
achieve this effect, the generator must keep track of some kind of
``state'' variable.  Sometimes this state is just an integer (sometimes
just the value of the previously generated random number), but often it
is more complicated than that and may involve a whole array of numbers,
possibly with some indices thrown in.  To use the random number
generators, you do not need to know the details of what comprises the
state, and besides that varies from algorithm to algorithm.

The random number generator library uses two special structs,
@code{gsl_rng_type} which holds static information about each type of
generator and @code{gsl_rng} which describes an instance of a generator
created from a given @code{gsl_rng_type}.

The functions described in this section are declared in the header file
@file{gsl_rng.h}.

@deftypefn Random {gsl_rng *} gsl_rng_alloc (gsl_rng_type * @var{T})
This function returns a pointer to a newly-created
instance of a random number generator of type @var{T}.
For example, the following code creates an instance of the Tausworthe
generator,

@example
gsl_rng * r = gsl_rng_alloc (gsl_rng_taus);
@end example

If there is insufficient memory to create the generator then the
function returns a null pointer and the error handler is invoked with an
error code of @code{GSL_ENOMEM}.

The generator is automatically initialized with the default seed,
@code{gsl_rng_default_seed}. This is zero by default but can be changed
either directly or usubf the environment variable @code{GSL_RNG_SEED},
@pxref{Random number environment variables}.

The defined generator types are,

@example
gsl_rng_cmrg, gsl_rng_minstd, gsl_rng_mrg, gsl_rng_mt19937,
gsl_rng_r250, gsl_rng_ran0, gsl_rng_ran1, gsl_rng_ran2,
gsl_rng_ran3, gsl_rng_rand, gsl_rng_rand48,
gsl_rng_random_bsd, gsl_rng_random_glibc2,
gsl_rng_random_libc5, gsl_rng_randu, gsl_rng_ranf,
gsl_rng_ranlux, gsl_rng_ranlux389, gsl_rng_ranmar,
gsl_rng_slatec, gsl_rng_taus, gsl_rng_tds, gsl_rng_tt800,
gsl_rng_uni, gsl_rng_uni32, gsl_rng_vax, gsl_rng_zuf
@end example
The details of each generator are given later in this chapter.
@end deftypefn

@deftypefn Random void gsl_rng_set (const gsl_rng * @var{r}, unsigned long int @var{s})
This function initializes (or `seeds') the random number generator. If
the generator is seeded with the same value of @var{s} on two different
runs, the same stream of random numbers will be generated by successive
calls to the routines below. If different values of @var{s} are
supplied, then the generated streams of random numbers should be
completely different. If the seed @var{s} is zero then the standard seed
from the original implementation is used instead. For example, the
original Fortran source code for the @code{ranlux} generator used a seed
of 314159265, and so choosing @var{s} equal to zero reproduces this when
using @code{gsl_rng_ranlux}.
@end deftypefn

@deftypefn Random void gsl_rng_free (gsl_rng * @var{r})
This function frees all the memory associated with the generator
@var{r}.
@end deftypefn

@node  Sampling from a random number generator
@subsection Sampling from a random number generator

The following functions return uniformly distributed random numbers,
either as integers or double precision floating point numbers. To obtain
non-uniform distributions @pxref{Random Number Distributions}.

@deftypefn Random {unsigned long int} gsl_rng_get (const gsl_rng * @var{r})
This function returns a random integer from the generator @var{r}.  All
integers in the range [@var{min},@var{max}] are equally likely.  The
maximum and minimum values, @var{max} and @var{min}, depend on the
algorithm used. They can determined using the auxilliary functions
@code{gsl_rng_max (r)} and @code{gsl_rng_min (r)}.
@end deftypefn

@deftypefn Random double gsl_rng_uniform (const gsl_rng * @var{r})
This function returns a double precision floating point number uniformly
distributed in the range [0,1). The range includes 0.0 but excludes 1.0.
The value is typically obtained by dividing the result of
@code{gsl_rng_get(r)} by @code{gsl_rng_max(r) + 1.0} in double
precision. Some generators compute this ratio internally so that they
can provide floating point numbers with more than 32 bits of randomness
(the maximum number of bits that can be portably represented in a single
@code{unsigned long int}).
@end deftypefn

@deftypefn Random double gsl_rng_uniform_pos (const gsl_rng * @var{r})
This function returns a positive double precision floating point number
uniformly distributed in the range (0,1), excluding both 0.0 and 1.0.
The number is obtained by sampling the generator with the algorithm of
@code{gsl_rng_uniform} until a non-zero value is obtained. You can use
this function if you need to avoid a singularity at 0.0.
@end deftypefn

@deftypefn Random {unsigned long int} gsl_rng_uniform_int (const gsl_rng * @var{r}, unsigned long int @var{n})
This function returns a random integer from 0 to @var{n-1} inclusive.
All integers in the range [0,@var{n-1}] are equally likely, regardless
of the generator used. An offset correction is applied so that zero is
always returned with the correct probability, for any minimum value of
the underlying generator.

If @var{n} is larger than the range of the generator then the function
calls the error handler with an error code of @code{GSL_EINVAL} and
returns zero.
@end deftypefn

@node Auxiliary random number generator functions
@subsection Auxiliary random number generator functions
The following functions provide information about an existing
generator. You should use them in preference to hard-coding the generator
parameters into your own code.

@deftypefn Random {const char *} gsl_rng_name (const gsl_rng * @var{r})
This function returns a pointer to the name of the generator.
For example,
@example
printf("r is a '%s' generator\n", gsl_rng_name (r)) ;
@end example
@noindent
would print something like @code{r is a 'taus' generator}
@end deftypefn

@deftypefn Random {unsigned long int} gsl_rng_max (const gsl_rng * @var{r})
@code{gsl_rng_max} returns the largest value that @code{gsl_rng_get}
can return.
@end deftypefn

@deftypefn Random {unsigned long int} gsl_rng_min (const gsl_rng * @var{r})
@code{gsl_rng_min} returns the smallest value that @code{gsl_rng_get}
can return. Usually this value is zero. There are some generators with
algorithms that cannot return zero, and for these generators the minimum
value is 1.
@end deftypefn

@deftypefn Random {void *} gsl_rng_state (const gsl_rng * @var{r})
@deftypefnx Random size_t gsl_rng_size (const gsl_rng * @var{r})
These function return a pointer to the state of generator @var{r} and
its size. You can use this information to access the state directly. For
example, the following code will write the state of a generator to a
stream,

@example
void * state = gsl_rng_state (r);
size_t n = gsl_rng_size (r);
fwrite (state, n, 1, stream);
@end example

@end deftypefn

@node Random number environment variables
@subsection Random number environment variables

The library allows you to choose a default generator and seed from the
environment variables @code{GSL_RNG_TYPE} and @code{GSL_RNG_SEED} and
the function @code{gsl_rng_env_setup}. This makes it easy try out
different generators and seeds without having to recompile your program.

@deftypefun {const gsl_rng_type *} gsl_rng_env_setup (void)
This function reads the environment variables @code{GSL_RNG_TYPE} and
@code{GSL_RNG_SEED} and uses their values to set the corresponding
library variables @code{gsl_rng_default} and
@code{gsl_rng_default_seed}. These global variables are defined as
follows,

@example
extern const gsl_rng_type *gsl_rng_default
extern unsigned long int gsl_rng_default_seed
@end example

The environment variable @code{GSL_RNG_TYPE} should be the name of a
generator, such as @code{taus} or @code{mt19937}. The environment
variable @code{GSL_RNG_SEED} should contain the desired seed value. It
is converted to an @code{unsigned long int} using the C library function
@code{strtoul}.

If you don't specify a generator for @code{GSL_RNG_TYPE} then
@code{gsl_rng_mt19937} is used as the default. The initial value of
@code{gsl_rng_default_seed} is zero.

@end deftypefun
@noindent
Here is a short program which shows how to create a global
generator using the environment variables @code{GSL_RNG_TYPE} and
@code{GSL_RNG_SEED},

@example
#include <stdio.h>
#include <gsl_rng.h>

gsl_rng * r ;  /* global generator */

int 
main ()
@{
  gsl_rng_env_setup() ;

  r = gsl_rng_alloc (gsl_rng_default);
  
  printf("generator type: %s\n", gsl_rng_name (r));
  printf("seed = %u\n", gsl_rng_default_seed);
  printf("first value = %u\n", gsl_rng_get (r)) ;
@}
@end example
@noindent
Running the program without any environment variables uses the initial
defaults, an @code{mt19937} generator with a seed of 0,
@example
bjg|zeke> ./a.out 
generator type: mt19937
seed = 0
first value = 3510405877
@end example
@noindent
By setting the two variables on the command line we can
change the default generator and the seed,
@example
bjg|zeke> GSL_RNG_TYPE="taus" GSL_RNG_SEED=123 ./a.out 
GSL_RNG_TYPE=taus
GSL_RNG_SEED=123
generator type: taus
seed = 123
first value = 2720986350
@end example

@node Saving and restoring random number generator state
@subsection Saving and restoring random number generator state

The above methods ignore the random number `state' which changes from
call to call.  It is often useful to be able to save and restore the
state.  To permit these practices, a few somewhat more advanced
functions are supplied.  These include:

@deftypefn Random {gsl_rng *} gsl_rng_cpy (gsl_rng * @var{dest}, const gsl_rng * @var{src})
This function copies the random number generator @var{src} into the
pre-exisiting generator @var{dest}, making @var{dest} into an exact copy
of @var{src}. It returns @var{dest} if successful and a null pointer if
sufficient memory could not be allocated.
@end deftypefn

@deftypefn Random {gsl_rng *} gsl_rng_clone (const gsl_rng * @var{r})
This function returns a pointer to a newly created generator which is an
exact copy of the generator @var{r}.
@end deftypefn

@deftypefn Random void gsl_rng_print_state (const gsl_rng * @var{r})
This function prints a hex-dump of the state of the generator @var{r} to
stdout. At the moment its only use is for debugging.
@end deftypefn

@node Available random number generator algorithms
@section Available random number generator algorithms

The functions described above make no reference to the actual algorithm
used. This is deliberate so that you can switch algorithms without
having to change any of your application source code. The library
provides a large number of generators of different types, including
simulation quality generators, generators provided for compatibility
with other libraries and historical generators from the past.

@menu
* Simulation quality generators::  
* Generators provided for compatibility::  
@end menu

@node Simulation quality generators
@subsection Simulation quality generators

The following generators are recommended for use in simulation. They
have extremely long periods and pass most statistical tests.

@deffn {Generator} gsl_rng_mt19937
@cindex MT19937 random number generator
The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is a
variant of the twisted generalized feedback shift-register algorithm,
and is known as the "Mersenne Twister" generator. It has a Mersenne
prime period of @math{2^@{19937@} - 1} (about @math{10^@{6000@}}) and is
equi-distributed in 623 dimensions. It has passed the @sc{diehard}
statistical tests. It uses 624 words of state per generator and is
comparable in speed to the other generators. The original generator used
a default seed of 4357 and choosing @var{s} equal to zero in
@code{gsl_rng_set} reproduces this.

For more information see,
@itemize @asis
@item
Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A
623-dimensionally equidistributerd uniform pseudorandom number
generator". @cite{ACM Transactions on Modeling and Computer
Simulation}, Vol. 8, No. 1 (Jan. 1998), Pages 3-30
@end itemize
@end deffn

@deffn {Generator} gsl_rng_ranlux
@deffnx {Generator} gsl_rng_ranlux389
@cindex RANLUX random number generator
The @code{ranlux} generator uses the lagged-fibonacci-with-skipping
algorithm of Luscher to produce "luxury random numbers". It is a 24-bit
generator, originally designed for single-precision IEEE floating point
numbers. The period of the generator is about @math{10^@{171@}}. The
generator is slow, but the algorithm has mathematically proven
properties. It can provide truly decorrelated numbers at a known level
of randomness. The default level of decorrelation recommended by Luscher
is provided by @code{gsl_rng_ranlux}, while @code{gsl_rng_ranlux389}
gives the highest level of randomness, with all 24 bits decorrelated.
Both types of generator use 24 words of state per generator.

For more information see,
@itemize @asis
@item
M. Luscher, "A portable high-quality random number generator for
lattice field theory calculations", @cite{Computer Physics
Communications}, 79 (1994) 100-110.
@item
F. James, "RANLUX: A Fortran implementation of the high-quality
pseudo-random number generator of Luscher", @cite{Computer Physics
Communications}, 79 (1994) 111-114
@end itemize
@end deffn

@deffn {Generator} gsl_rng_cmrg
@cindex CMRG, combined multiple recursive random number generator
This is a combined multiple recursive generator by L'Ecuyer. 
Its sequence is,
@c
@c THIS IS HORRIBLE!
@macro mod 
\hbox@{ mod @}
@end macro
@c
@macro and
\&
@end macro
@c
@equation
z_n = (x_n - y_n) @mod m_1
@end equation
@noindent
where the two underlying generators @math{x_n} and @math{y_n} are,
@c
@equation
x_n = (a_1 x_@{n-1@} + a_2 x_@{n-2@} + a_3 x_@{n-3@}) @mod m_1
@end equation
and
@equation
y_n = (b_1 y_@{n-1@} + b_2 y_@{n-2@} + b_3 y_@{n-3@}) @mod m_2
@end equation
@noindent
with coefficients @math{a_1 = 0}, @math{a_2 = 63308}, @math{a_3 =
-183326}, @math{b_1 = 86098}, @math{b_2 = 0}, @math{b_3 = -539608},
and moduli @math{m_1 = 2^@{31@} - 1 = 2147483647} and @math{m_2 =
2145483479}.

The period of this generator is @math{2^@{205@}} (about
@math{10^@{61@}}). It uses 6 words of state per generator. For more
information see,

@itemize @asis
@item
P. L'Ecuyer, "Combined Multiple Recursive Random Number
Generators," @cite{Operations Research}, 44, 5 (1996), 816--822.
@end itemize
@end deffn

@deffn {Generator} gsl_rng_mrg
@cindex MRG, multiple recursive random number generator
This is a fifth-order multiple recursive generator by L'Ecuyer, Blouin
and Coutre.  Its sequence is,
@c
@equation
   x_n = (a_1 x_@{n-1@} + a_5 x_@{n-5@}) @mod m
@end equation
@noindent
with @math{a_1 = 107374182}, @math{a_2 = a_3 = a_4 = 0}, @math{a_5 = 104480}
and @math{m = 2^@{31@}-1}.

The period of this generator is about @math{10^@{46@}}. It uses 5 words
of state per generator. More information can be found in the following
paper,
@itemize @asis
@item
P. L'Ecuyer, F. Blouin, and R. Coutre, "A search for good multiple
recursive random number generators", @cite{ACM Transactions on Modeling and
Computer Simulation} 3, 87-98 (1993).
@end itemize
@end deffn

@deffn {Generator} gsl_rng_taus
@cindex Tausworthe random number generator
This is a maximally equidistributed combined Tausworthe generator by
L'Ecuyer. The sequence is,
@c
@equation
x_n = (s^1_n \oplus s^2_n \oplus s^3_n) 
@end equation
@noindent
where,
@c
@equation
s^1_@{n+1@} = (((s^1_n @and 4294967294) <<12) \oplus (((s^1_n <<13) \oplus s^1_n) >>19))
@end equation
@equation
s^2_@{n+1@} = (((s^2_n @and 4294967288) << 4) \oplus (((s^2_n << 2) \oplus s^2_n) >>25))
@end equation
@equation
s^3_@{n+1@} = (((s^3_n @and 4294967280) <<17) \oplus (((s^3_n << 3) \oplus s^3_n) >>11))
@end equation
@noindent
computed modulo @math{2^@{32@}}. In the formulas above @math{\oplus}
denotes ``exclusive-or''. Note that the algorithm relies on the properties
of 32-bit unsigned integers and has been implemented using a bitmask
of @code{0xFFFFFFFF} to make it work on 64 bit machines.

The period of this generator is @math{2^@{88@}} (about
@math{10^@{26@}}). It uses 3 words of state per generator. For more
information see,

@itemize @asis
@item
P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe
Generators", @cite{Mathematics of Computation}, 65, 213 (1996), 203--213.
@end itemize
@end deffn

@deffn {Generator} gsl_rng_gfsr4
@cindex Four-tap Generalized Feedback Shift Register
The @code{gfsr4} generator is like a lagged-fibonacci generator, and 
produces each number as an @code{xor}'d sum of four previous values.
@equation
 r_n = r_@{n-A@} \oplus r_@{n-B@} \oplus r_@{n-C@} \oplus r_@{n-D@}
@end equation

Ziff (ref below) notes that "it is now widely known" that two-tap
registers (such as R250, which is described below)
have serious flaws, the most obvious one being the three-point
correlation that comes from the defn of the generator.  Nice
mathematical properties can be derived for GFSR's, and numerics bears
out the claim that 4-tap GFSR's with appropriately chosen offsets are as
random as can be measured, using the author's test.

This implementation uses the values suggested the the example on p392 of
Ziff's article: A=471, B=1586, C=6988, D=9689.

If the offsets are appropriately chosen (such the one ones in
this implementation), then the sequence is said to be maximal.
I'm not sure what that means, but I would guess that means all
states are part of the same cycle, which would mean that the
period for this generator is astronomical; it is
@math{(2^K)^D \approx 10^@{93334@}}
where @math{K=32} is the number of bits in the word, and D is the longest
lag.  This would also mean that any one random number could 
easily be zero; ie @math{0 \le r \lt 2^@{32@}}.

Ziff doesn't say so, but it seems to me that the bits are
completely independent here, so one could use this as an efficient
bit generator; each number supplying 32 random bits.

For more information see,
@itemize @asis
@item
Robert M. Ziff, "Four-tap shift-register-sequence random-number 
generators", @cite{Computers in Physics}, 12(4), Jul/Aug
1998, pp 385-392.
@end itemize
@end deffn

@node Generators provided for compatibility
@subsection Generators provided for compatibility

The generators in this section are provided for compatibility with
existing libraries. If you are converting an existing program to use GSL
then you can select these generators to check your new implementation
against the original one, using the same random number generator. After
verifying that your new program reproduces the original results you can
then switch to a higher-quality generator.

Note that most of the generators in this section are based on single
linear congruence relations, which are the least sophisticated type of
generator. In particular, linear congruences have poor properties when
used with a non-prime modulus, as several of these routines do (e.g.
with a power of two modulus, @math{2^@{31@}} or @math{2^@{32@}}). This
leads to periodicity in the least significant bits of each number,
with only the higher bits having any randomness. Thus if you want to
produce a random bitstream it is best to avoid using the least
significant bits.

@menu
* Unix random number generators::  
* Numerical Recipes generators::  
* Other random number generators::  
@end menu

@node Unix random number generators
@subsubsection Unix random number generators

The standard Unix random number generators @code{rand}, @code{random}
and @code{rand48} are provided as part of GSL. Although these
generators are widely available individually often they aren't all
available on the same platform. This makes it difficult to write
portable code using them and so we have included the complete set of
Unix generators in GSL for convenience. Note that these generators
don't produce high-quality randomness and aren't suitable for work
requiring accurate statistics. However, if you won't be measuring
statistical quantities and just want to introduce some variation into
your program then these generators are quite acceptable.

@cindex BSD random number generator, rand
@cindex Unix random number generators, rand
@cindex Unix random number generators, rand48

@deffn {Generator} gsl_rng_rand
@cindex BSD random number generator
This is the BSD @code{rand()} generator. Its sequence is
@c
@equation
x_@{n+1@} = (a x_n + c) @mod m
@end equation
@noindent
with @math{a = 1103515245}, @math{c = 12345} and @math{m = 2^@{31@}}.
The seed specifies the initial value, @math{x_1}. The period of this
generator is @math{2^@{31@}}, and it uses 1 word of storage per
generator.
@end deffn

@deffn {Generator} gsl_rng_random_bsd
@deffnx {Generator} gsl_rng_random_libc5
@deffnx {Generator} gsl_rng_random_glibc2
These generators implement the @code{random()} family of functions, a
set of linear feedback shift register generators originally used in BSD
Unix. There are several versions of @code{random()} in use today: the
original BSD version (e.g. on SunOS4), a libc5 version (common on
existing GNU/Linux systems) and a glibc2 version. Each version uses a
different seeding procedure, and thus produces different sequences.

The original BSD routines accepted a variable length buffer for the
generator state, with longer buffers providing higher-quality
randomness. The @code{random()} function implemented algorithms for
buffer lengths of 8, 32, 64, 128 and 256 bytes, and the algorithm with
the largest length that would fit into the user-supplied buffer was
used. To support these algorithms additional generators are available
with the following names,
@c
@example
gsl_rng_random8_bsd
gsl_rng_random32_bsd
gsl_rng_random64_bsd
gsl_rng_random128_bsd
gsl_rng_random256_bsd
@end example
@noindent
where the numeric suffix indicates the buffer length. The original BSD
@code{random} function used a 128-byte default buffer and so
@code{gsl_rng_random_bsd} has been made equivalent to
@code{gsl_rng_random128_bsd}. Corresponding versions of the @code{libc5}
and @code{glibc2} generators are also avaliable, with the names
@code{gsl_rng_random8_libc5}, @code{gsl_rng_random8_glibc2}, etc.
@end deffn

@deffn {Generator} gsl_rng_rand48
@cindex rand48 random number generator
This is the Unix @code{rand48} generator. Its sequence is
@c
@equation
x_@{n+1@} = (a x_n + c) @mod m
@end equation
@noindent
defined on 48-bit unsigned integers with @math{a = 25214903917}, @math{c
= 11} and @math{m = 2^@{48@}}. The seed specifies the upper 32 bits of
the initial value, @math{x_1}, with the lower 16 bits set to
@code{0x330E}. The function @code{gsl_rng_get} returns the upper 32 bits
from each term of the sequence. This does not have a direct parallel in
the original @code{rand48} functions, but forcing the result to type
@code{long int} reproduces the output of @code{mrand48}. The function
@code{gsl_rng_uniform} uses the full 48 bits of internal state to return
the double precision number @math{x_n/m}, which is equivalent to the
function @code{drand48}. Note that some versions of the GNU C Library
contained a bug in @code{mrand48} function which caused it to produce
different results (only the lower 16-bits of the return value were set).
@end deffn

@node Numerical Recipes generators
@subsubsection Numerical Recipes generators
@cindex Random number generators, Numerical recipes
@cindex Numerical recipes, random number generators
@c
The following generators are provided for compatibility with
@cite{Numerical Recipes}. Note that the original Numerical Recipes
functions used single precision while we use double precision. This will
lead to minor discrepancies, but only at the level of single-precision
rounding error. If necessary you can force the returned values to single
precision by storing them in a @code{volatile float}, which prevents the
value being held in a register with double or extended precision. Apart
from this difference the underlying algorithms for the integer part of
the generators are the same.

@deffn {Generator} gsl_rng_ran0 
Numerical recipes @code{ran0} implements Park and Miller's @sc{minstd}
algorithm with a modified seeding procedure.
@end deffn

@deffn {Generator} gsl_rng_ran1 
Numerical recipes @code{ran1} implements Park and Miller's @sc{minstd}
algorithm with a 32-element Bayes-Durham shuffle box.
@end deffn

@deffn {Generator} gsl_rng_ran2 
Numerical recipes @code{ran2} implements a L'Ecuyer combined recursive
generator with a 32-element Bayes-Durham shuffle-box.
@end deffn

@deffn {Generator} gsl_rng_ran3 
Numerical recipes @code{ran3} implements Knuth's portable
subtractive generator.
@end deffn

@node Other random number generators
@subsubsection Other random number generators

The following generator is provided for compatibility with the CRAY
MATHLIB routine RANF. It produces double precision floating point
numbers which should be identical to those from the original RANF.

@deffn {Generator} gsl_rng_ranf
@cindex RANF random number generator
@cindex CRAY random number generator, RANF
This is the CRAY random number generator @code{RANF}. Its
sequence is
@c
@equation
x_@{n+1@} = (a x_n) @mod m
@end equation
@noindent
defined on 48-bit unsigned integers with @math{a = 44485709377909} and
@math{m = 2^@{48@}}.  The seed specifies the lower 32 bits of the
initial value, @math{x_1}, with the lowest bit set to prevent the seed
taking an even value.  The upper 16 bits of @math{x_1} are set to 0. A
consequence of this procedure is that the pairs of seeds 2 and 3, 4 and
5, etc produce the same sequences.

There is a subtlety in the implementation of the seeding. The initial
state is reversed through one step, by multiplying by the modular
inverse of @math{a} mod @math{m}. This is done for compatibility with
the original CRAY implementation.

Note that you can only seed the generator with integers up to
@math{2^@{32@}}, while the original CRAY implementation uses
non-portable wide integers which can cover all @math{2^@{48@}} states of
the generator.

The function @code{gsl_rng_get} returns the upper 32 bits from each term
of the sequence.  The function @code{gsl_rng_uniform} uses the full 48
bits to return the double precision number @math{x_n/m}.

The period of this generator is @math{2^@{46@}}.
@end deffn

@deffn {Generator} gsl_rng_ranmar
@cindex RANMAR random number generator
This is the RANMAR lagged-fibonacci generator of Marsaglia, Zaman and
Tsang.  It is a 24-bit generator, originally designed for
single-precision IEEE floating point numbers. It was included in the
CERNLIB high-energy physics library.
@end deffn

@deffn {Generator} gsl_rng_r250
@cindex shift-register random number generator
@cindex R250 shift-register random number generator
This is the shift-register generator of Kirkpatrick and Stoll. The
sequence is
@c
@equation
x_n = x_@{n-103@} \oplus x_@{n-250@}
@end equation
@noindent
where @math{\oplus} denote ``exclusive-or'', defined on 32-bit
words. The period of this generator is about @math{2^@{250@}} and it
uses 250 words of state per generator.

For more information see,
@itemize @asis
@item
S. Kirkpatrick and E. Stoll, "A very fast shift-register sequence random
number generator", @cite{Journal of Computational Physics}, 40, 517-526
(1981)
@end itemize
@end deffn

@deffn {Generator} gsl_rng_tt800
@cindex TT800 random number generator
This is an earlier version of the twisted generalized feedback
shift-register generator, and has been superseded by the development of
MT19937. However, it is still an acceptable generator in its own
right. It has a period of @math{2^@{800@}} and uses 33 words of storage
per generator.

For more information see,
@itemize @asis
@item
From: Makoto Matsumoto and Yoshiharu Kurita, "Twisted GFSR Generators
II", @cite{ACM Transactions on Modelling and Computer Simulation},
Vol. 4, No. 3, 1994, pages 254-266.
@end itemize
@end deffn

@c The following generators are included only for historical reasons, so
@c that you can reproduce results from old programs which might have used
@c them. These generators should not be used for real simulations since
@c they have poor statistical properties by modern standards.

@deffn {Generator} gsl_rng_vax
@cindex VAX random number generator
This is the VAX generator @code{MTH$RANDOM}. Its sequence is,
@c
@equation
x_@{n+1@} = (a x_n + c) @mod m
@end equation
@noindent
with @math{a = 69069}, @math{c = 1} and @math{m = 2^@{32@}}. The seed
specifies the initial value, @math{x_1}. The period of this generator is
@math{2^@{32@}} and it uses 1 word of storage per generator.
@end deffn

@deffn {Generator} gsl_rng_transputer
This is the random number generator from the INMOS Transputer
Development system.  Its sequence is,
@c
@equation
x_@{n+1@} = (a x_n) @mod m
@end equation
@noindent
with @math{a = 1664525} and @math{m = 2^@{32@}}. The seed specifies the initial
value, @math{x_1}.
@end deffn

@deffn {Generator} gsl_rng_randu
@cindex RANDU random number generator
This is the IBM @code{RANDU} generator. Its sequence is
@c
@equation
x_@{n+1@} = (a x_n) @mod m
@end equation
@noindent
with @math{a = 65539} and @math{m = 2^@{31@}}. The seed specifies the
initial value, @math{x_1}. The period of this generator was only
@math{2^@{29@}}. It has become a textbook example of a poor generator.
@end deffn

@deffn {Generator} gsl_rng_minstd
@cindex RANMAR random number generator
This is Park and Miller's "minimal standard" @sc{minstd} generator, a
simple linear congruence which takes care to avoid the major pitfalls of
such algorithms. Its sequence is,
@c
@equation
x_@{n+1@} = (a x_n) @mod m
@end equation
@noindent
with @math{a = 16807} and @math{m = 2^@{31@} - 1 = 2147483647}. The seed
specifies the initial value, @math{x_1}. The period of this generator is
about @math{2^@{31@}}.

This generator is used in the IMSL Library (subroutine RNUN) and in
MATLAB (the RAND function). It is also sometimes known by the acronym
"GGL" (I'm not sure what that stands for).

For more information see,
@itemize @asis
@item
Park and Miller, "Random Number Generators: Good ones are hard to find",
@cite{Communications of the ACM}, October 1988, Volume 31, No 10, pages
1192-1201.
@end itemize
@end deffn

@deffn {Generator} gsl_rng_uni
@deffnx {Generator} gsl_rng_uni32
This is a reimplementation of the 16-bit SLATEC random number generator
RUNIF. A generalisation of the generator to 32 bits is provided by
@code{gsl_rng_uni32}. The original source code is available from NETLIB.
@end deffn

@deffn {Generator} gsl_rng_slatec
This is the SLATEC random number generator RAND. It is ancient. The
original source code is available from NETLIB.
@end deffn


@deffn {Generator} gsl_rng_zuf
This is the ZUFALL lagged Fibonacci series generator of Peterson.  Its
sequence is,
@c
@equation
t    = u_@{n-273@} + u_@{n-607@}
@end equation
@equation
u_n  = t - floor(t)
@end equation
The original source code is available from NETLIB.  For more information
see,
@itemize @asis
@item
W. Petersen, "Lagged Fibonacci Random Number Generators for the NEC
SX-3", @cite{International Journal of High Speed Computing} (1994).
@end itemize
@end deffn

@section Performance

@c
@c I made the plot like this
@c ./benchmark > tmp ; cat tmp | perl -n -e '($n,$s) = split(" ",$_) ; printf("%17s ",$n); print "-" x ($s/1e5), "\n";'
@c

@smallexample
 ranlux389 --
    ranlux ---
      cmrg ----
       mrg --------
   mt19937 ------------
     tt800 ----------------
      taus ------------------

      ran0 ----------
      ran1 -----------
      ran2 -----
      ran3 -----------------

      ranf --------
    rand48 ---------

    ranmar --------------
       zuf --------------
    slatec ---------------
      r250 --------------------
    random --------------------

    minstd ------------
       uni -----------------
     uni32 ------------------
       vax -----------------------
transputer -----------------------
      rand -------------------------
   random8 -------------------------
     randu ---------------------------

          |---------|---------|---------|
          0         1         2         3

          Millions of random numbers per second
@end smallexample

@page
@node Random Number Distributions
@section Random Number Distributions
@cindex random number distributions


Distributions of random numbers can be obtained from any of the
generators using the functions described in this section. In the
simplest cases a non-uniform distribution can be obtained analytically
from the uniform distribution with an appropriate transformation. This
method uses one call to the random number generator.


More complicated distributions are created by the
@dfn{acceptance-rejection} method, which compares the desired
distribution against a distribution which is similar and known
analytically. This usually requires several samples from the generator.

The functions described in this section are declared in
@file{gsl_randist.h}.


@c ----------------------------------------------------------------------
@menu
* The Gaussian Distribution::   
* The Bivariate Gaussian Distribution::  
* The Exponential Distribution::  
* The Laplace Distribution::    
* The Exponential Power Distribution::  
* The Cauchy Distribution::     
* The Rayleigh Distribution::   
* The Rayleigh Tail Distribution::  
* The Symmetric Levy Distribution::  
* The Gamma Distribution::      
* The Flat (Uniform) Distribution::  
* The Lognormal Distribution::  
* The Chi-squared Distribution::  
* The F-distribution::          
* The t-distribution::          
* The Beta Distribution::       
* The Logistic Distribution::   
* The Pareto Distribution::     
* The Spherical Distribution (2D & 3D)::  
* The Weibull Distribution::    
* The Gumbel Distribution::     
* General Discrete Distributions::
* The Poisson Distribution::    
* The Bernoulli Distribution::  
* The Binomial Distribution::   
* The Negative Binomial Distribution::  
* The Geometric Distribution::  
* The Hypergeometric Distribution::  
* The Logarithmic Distribution::  
@end menu

@page
@node The Gaussian Distribution
@subsection The Gaussian Distribution
@deftypefn Random double gsl_ran_gaussian (const gsl_rng * @var{r}, double @var{sigma})
@cindex Gaussian random numbers
This function returns a gaussian random number, with mean zero and
standard deviation @var{sigma}. The probability
distribution for gaussian random numbers is,
@c
@equation
p(z) dz = @{1 \over \sqrt@{2 \pi \sigma^2@}@} 
            \exp (-(z-\mu)^2 / 2\sigma^2) dz
@end equation
@noindent
for @math{x} in the range @math{-\infty} to @math{+\infty}. Use the
transformation @math{z = \mu + x} on the numbers returned by
@code{gsl_ran_gaussian} to obtain a gaussian distribution with mean
@math{\mu}.
@end deftypefn

@deftypefun double gsl_ran_gaussian_pdf (double @var{x}, double @var{sigma})
This function computes the probability density @math{p(x)} at @var{x}
for a gaussian distribution with standard deviation @var{sigma}, using
the formula given above.
@end deftypefun

@deftypefun double gsl_ran_ugaussian_tail (const gsl_rng * @var{r}, double @var{tail})
This function provides random numbers distributed as a unit-variance gaussian,
but only provides values larger than @var{tail}.  For large values of @var{tail},
it would be inefficient to use @code{gsl_ran_gaussian} and then reject all
values less than @var{tail}.  The algorithm used is based on Marsaglia's
famous rectangle-wedge-tail algorithm (Ann Math Stat 32, 894-899 (1961)),
with this aspect explained in Knuth, v2, 3rd ed, p139,586 (exercise 11).

@end deftypefun

@tex
\centerline{\input rand-gaussian.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{\mu},
Variance = @math{\sigma^2},
Skewness = 0,
Excess = 0

@item
Cumulants, @math{\kappa_1=\mu}, @math{\kappa_2=\sigma^2},
@math{\kappa_n=0} for @math{n>2}

@item
Characteristic function, @math{\phi(t) = \exp(-i\mu t - \sigma^2 t^2/2)}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_@{-\infty@}^x p(x') dx' = @{1 \over 2 @}(1 - \hbox@{erf@}((x-m)/\sqrt@{2\sigma^2@}))}
@item
Confidence limits:

@math{p(|x-\mu| < \sigma) = 0.683},
@math{p(|x-\mu| < 2\sigma) = 0.954},
@math{p(|x-\mu| < 3\sigma) = 0.9973}

@item
Useful integral:
@equation
\int_@{-\infty@}^@{+\infty@} x^@{2n@} p(x) dx 
= 2^n \sigma^@{2n+1@} \Gamma(n+ @{1 \over 2@}) / \sqrt\pi
@end equation

@end itemize

@page
@node The Bivariate Gaussian Distribution
@subsection The Bivariate Gaussian Distribution
@c
@deftypefn Random void gsl_ran_bivariate_gaussian (const gsl_rng * @var{r}, double @var{sigma_x}, double @var{sigma_y}, double @var{rho}, double * @var{x}, double * @var{y})
@cindex Gaussian random numbers
This function generates a pair of correlated gaussian variates, with
mean zero, correlation coefficient @var{rho} and standard deviations
@var{sigma_x} and @var{sigma_y} in the @math{x} and @math{y} directions.
The probability distribution for bivariate gaussian random numbers is,
@c
@equation
p(x,y) dx dy = @{1 \over 2 \pi \sigma_x \sigma_y \sqrt@{1-\rho^2@}@} 
\exp (-(x^2 + y^2 - 2 \rho x y)/2\sigma_x^2\sigma_y^2 (1-\rho^2)) dz
@end equation
@noindent
for @math{x,y} in the range @math{-\infty} to @math{+\infty}.
The correlation coefficient @var{rho} should lie between @math{1} and
@math{-1}.
@end deftypefn

@deftypefun double gsl_ran_bivariate_gaussian_pdf (double @var{x}, double @var{y}, double @var{sigma_x}, double @var{sigma_y}, double @var{rho})
This function computes the probability density @math{p(x,y)} at
(@var{x},@var{y}) for a bivariate gaussian distribution with standard
deviations @var{sigma_x}, @var{sigma_y} and correlation coefficient
@var{rho}, using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-bivariate-gaussian.tex}
@end tex

@c ----------------------------------------------------------------------
@page
@node The Exponential Distribution
@subsection The Exponential Distribution
@deftypefn Random double gsl_ran_exponential (const gsl_rng * @var{r}, double @var{mu})
@cindex Exponential random numbers
This function returns a random number from the exponential distribution
with mean @var{mu}.
@c
@equation
p(x) dx = @{1 \over \mu@} \exp(-x/\mu) dx
@end equation
@noindent
for @math{x \ge 0}. 
@end deftypefn

@deftypefun double gsl_ran_exponential_pdf (double @var{x}, double @var{mu})
This function computes the probability density @math{p(x)} at @var{x}
for an exponential distribution with mean @var{mu}, using the formula
given above.
@end deftypefun

@tex
\centerline{\input rand-exponential.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{\mu}, Variance = @math{\mu^2}, Skewness = 2, Excess = 6

@item
Cumulants, @math{\kappa_1=\mu}, @math{\kappa_n=\mu^n \Gamma(n)},
for @math{n>1}

@item
Characteristic function, @math{\phi(t) = 1/(1-i\mu t)}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = 1 - \exp(-x/\mu)}
@item
Confidence limits:

@math{p(x < \mu) = 0.632},
@math{p(x < 2\mu) = 0.865},
@math{p(x < 3\mu) = 0.950}

@item
Useful integral:
@equation
\int_0^\infty x^n p(x) dx 
= n! \mu^@{n+1@}
@end equation

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Laplace Distribution
@subsection The Laplace Distribution
@deftypefn Random double gsl_ran_laplace (const gsl_rng * @var{r}, double @var{mu})
@cindex two-sided exponential random numbers
@cindex Laplace distribution random numbers
This function returns a random number from the the Laplace distribution
with width @var{mu}. The distribution is,
@equation
p(x) dx = @{1 \over 2 \mu@}  \exp(-|x/\mu|) dx
@end equation
@noindent
for @math{-\infty < x < \infty}.
@end deftypefn

@deftypefun double gsl_ran_laplace_pdf (double @var{x}, double @var{mu})
This function computes the probability density @math{p(x)} at @var{x}
for a Laplace distribution with mean @var{mu}, using the formula
given above.
@end deftypefun

@tex
\centerline{\input rand-laplace.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{0}, Variance = @math{2\mu^2}, Skewness = @math{0}, Excess =
@math{6}

@item
Cumulants, @math{\kappa_1=0}, @math{\kappa_2=2 \mu^2},
@math{\kappa_@{2n+1@}=0}, @math{\kappa_@{2n@}=(2n)!\mu^@{2n@}/n}

@item
Characteristic function, @math{\phi(t) = 1/(1+\mu^2 t^2}

@item
Cumulative distribution function, @math{CDF(x) = \int_0^x p(x') dx' =
@{1 \over 2@} \exp(-|x|)} for @math{x<0} and @math{1 - @{1 \over 2@}
\exp(-|x|)} for @math{x>0}.
@item
Confidence limits:

@item
Useful integral:

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Exponential Power Distribution
@subsection The Exponential Power Distribution
@deftypefn Random double gsl_ran_exppow (const gsl_rng * @var{r}, double @var{mu}, double @var{a})
@cindex Exponential power distribution, random numbers
This function returns a random number from the exponential power distribution
with scale parameter @var{mu} and exponent @var{a}.
@c
@equation
p(x) dx = @{1 \over 2 \mu \Gamma(1+1/a)@} \exp(-|x/\mu|^a) dx
@end equation
@noindent
for @math{x \ge 0}. For @math{a = 1} this reduces to the laplace
distribution. For @math{a = 2} it has the same form as a gaussian
distribution, but with @math{\mu = \sqrt@{2@} \sigma}.
@end deftypefn

@deftypefun double gsl_ran_exppow_pdf (double @var{x}, double @var{mu}, double @var{a})
This function computes the probability density @math{p(x)} at @var{x}
for an exponential power distribution with scale parameter @var{mu}
and exponent @var{a}, using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-exppow.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{0}, Variance = @math{\mu^2 \Gamma(3/a)/\Gamma(1/a)},
Skewness = @math{0}, Excess = @math{\Gamma(5/a)\Gamma(1/a)/\Gamma(3/a)^2}

@item
Cumulants, @math{\kappa_1=FIXME}, @math{\kappa_n=FIXME},
for @math{n>1}

@item
Characteristic function, @math{\phi(t) = FIXME}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = FIXME}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Cauchy Distribution
@subsection The Cauchy Distribution
@deftypefn Random double gsl_ran_cauchy (const gsl_rng * @var{r}, double @var{mu})
@cindex Cauchy random numbers
This function returns a random number from the Cauchy distribution with
scale parameter @var{mu}. The probability distribution for Cauchy
random numbers is,
@c
@equation
p(x) dx = @{1 \over \mu\pi (1 + (x/\mu)^2) @} dx
@end equation
@noindent
for @math{x} in the range @math{-\infty} to @math{+\infty}.  The Cauchy
distribution is also known as the Lorentz distribution.
@end deftypefn

@deftypefun double gsl_ran_cauchy_pdf (double @var{x}, double @var{mu})
This function computes the probability density @math{p(x)} at @var{x}
for an Cauchy distribution with scale parameter @var{mu}, using the formula
given above.
@end deftypefun

@tex
\centerline{\input rand-cauchy.tex}
@end tex

@subheading Properties
@itemize @asis
@item
The Cauchy distribution decreases as @math{1/|x|^2} for large
@math{x}. This makes the variance infinite. Other higher moments are
either infinite or undefined.

@item
Characteristic function, @math{\phi(t) = \exp(-i\alpha t - \beta |t|)}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_@{-\infty@}^x p(x') dx' = @{1 \over 2 @} + @{1\over \pi@} \arctan(x/\mu)}

@item
Confidence limits:

@math{p(|x| < \mu) = 0.5},
@math{p(|x| < 2\mu) = 0.705},
@math{p(|x| < 3\mu) = 0.795}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Rayleigh Distribution
@subsection The Rayleigh Distribution
@deftypefn Random double gsl_ran_rayleigh (const gsl_rng * @var{r}, double @var{sigma})
@cindex Rayleigh random numbers
This function returns a random number from the Rayleigh distribution with
scale parameter @var{sigma}. The probability distribution for Rayleigh
random numbers is,
@c
@equation
p(x) dx = @{x \over \sigma^2@} \exp(- x^2/(2 \sigma^2)) dx
@end equation
@noindent
for @math{x>0}.
@end deftypefn

@deftypefun double gsl_ran_rayleigh_pdf (double @var{x}, double @var{sigma})
This function computes the probability density @math{p(x)} at @var{x}
for an Rayleigh distribution with scale parameter @var{sigma}, using the
formula given above.
@end deftypefun

@tex
\centerline{\input rand-rayleigh.tex}
@end tex

@subheading Properties
@itemize @asis
@item

@c @item
@c Characteristic function, @math{\phi(t) = \exp(-i\alpha t - \beta |t|)}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_@{-\infty@}^x p(x') dx' = 1 - \exp(-x^2/(2 \sigma^2))}

@c @item
@c Confidence limits:

@c @math{p(|x| < \mu) = 0.5},
@c @math{p(|x| < 2\mu) = 0.705},
@c @math{p(|x| < 3\mu) = 0.795}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Rayleigh Tail Distribution
@subsection The Rayleigh Tail Distribution
@deftypefn Random double gsl_ran_rayleigh_tail (const gsl_rng * @var{r}, double @var{a} double @var{sigma})
@cindex Rayleigh Tail random numbers
This function returns a random number from the tail of the Rayleigh
distribution with scale parameter @var{sigma} and a lower limit of
@var{a}. The probability distribution for Rayleigh tail random numbers
is,
@c
@equation
p(x) dx = @{x \over \sigma^2@} \exp ((a^2 - x^2) /(2 \sigma^2)) dx
@end equation
@noindent
for @math{x>a}.
@end deftypefn

@deftypefun double gsl_ran_rayleigh_tail_pdf (double @var{x}, double @var{a}, double @var{sigma})
This function computes the probability density @math{p(x)} at @var{x}
for an Rayleigh tail distribution with scale parameter @var{sigma} and
lower limit @var{a}, using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-rayleigh-tail.tex}
@end tex

@subheading Properties
@itemize @asis
@item

@c @item
@c Characteristic function, @math{\phi(t) = \exp(-i\alpha t - \beta |t|)}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_@{-\infty@}^x p(x') dx' = 1 - \exp((a^2-x^2)/(2 \sigma^2))}

@c @item
@c Confidence limits:

@c @math{p(|x| < \mu) = 0.5},
@c @math{p(|x| < 2\mu) = 0.705},
@c @math{p(|x| < 3\mu) = 0.795}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Symmetric Levy Distribution
@subsection The Symmetric Levy Distribution
@deftypefn Random double gsl_ran_levy (const gsl_rng * @var{r}, double @var{mu}, double @var{a})
@cindex Levy distribution, random numbers
This function returns a random number from the symmetric Levy
distribution with scale @var{mu} and exponent @var{a}. The symmetric
Levy probability distribution is defined by a fourier transform,
@c
@equation
p(x) = @{1 \over 2 \pi@} \int_@{-\infty@}^@{+\infty@} dt \exp(it(\mu-x)- |t|^a) 
@end equation
@noindent
There is no explicit solution for the form of @math{p(x)}. For @math{a =
1} the distribution reduces to the Cauchy distribution. For @math{a = 2}
it is a Gaussian distribution with @math{\sigma = \sqrt@{2@} \mu}. For
@math{a < 1} the tails of the distribution become extremely wide.

The algorithm only works for @math{0 < a \le 2}.
@end deftypefn

@deftypefun double gsl_ran_levy_pdf (double @var{x}, double @var{mu})
This function computes the probability density @math{p(x)} at @var{x}
for a symmetric Levy distribution with scale parameter @var{mu} and
exponent @var{a}, using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-levy.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{0}, Variance = @math{FIXME}, Skewness = @math{0}, Excess = FIXME

@item
Cumulants, @math{\kappa_1=FIXME}, @math{\kappa_n=FIXME},
for @math{n>1}

@item
Characteristic function, @math{\phi(t) = FIXME}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = FIXME}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Gamma Distribution
@subsection The Gamma Distribution
@deftypefn Random double gsl_ran_gamma (const gsl_rng * @var{r}, double @var{a}, double @var{b})
@cindex Gamma distribution random numbers
This function returns a random number from the gamma
distribution.  The distribution function is
@c
@equation
p(x) dx = @{1 \over \Gamma(a) b^a@} x^@{a-1@} e^@{-x/b@} dx
@end equation
@c If @math{X} and @math{Y} are independent gamma-distributed random
@c variables of order @math{a} and @math{b}, then @math{X+Y} has a gamma
@c distribution of order @math{a+b}.
@end deftypefn

@deftypefun double gsl_ran_gamma_pdf (double @var{x}, double @var{a}, double @var{b})
This function computes the probability density @math{p(x)} at @var{x}
for a gamma distribution with parameters @var{a} and @var{b}, using the
formula given above.
@end deftypefun

@tex
\centerline{\input rand-gamma.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{ab}, Variance = @math{ab^2}, Skewness =
@math{2/\sqrt@{a@}}, Excess = @math{6/a}

@item
Cumulants, @math{\kappa_1=ab}, @math{\kappa_n=a\Gamma(n) b^n},
for @math{n>1}

@item
Characteristic function, @math{\phi(t) = 1 - i bt }

@end itemize

@c @c ----------------------------------------------------------------------
@c @page
@c @node The Erlang distribution
@c @subsection The Erlang distribution
@c The Erlang distribution is the sum of @math{n} exponential variates,
@c each with mean @math{a}. 

@c @deftypefn Random double gsl_ran_erlang (const gsl_rng * @var{r}, double @var{a}, double @var{n})
@c @cindex Erlang random numbers
@c This function returns a random number from the Erlang distribution.
@c @c
@c @equation
@c p(x) dx = @{x^@{n-1@} \over (n-1)! a^n @} \exp (-x/a)  dx
@c @end equation
@c @noindent
@c for @math{x \ge 0}. 
@c @end deftypefn
@c @tex
@c \centerline{\input rand-erlang.tex}
@c @end tex

@c ----------------------------------------------------------------------
@page
@node The Flat (Uniform) Distribution
@subsection The Flat (Uniform) Distribution
@deftypefn Random double gsl_ran_flat (const gsl_rng * @var{r}, double @var{a}, double @var{b})
@cindex flat distribution random numbers
This function returns a random number from the flat (uniform)
distribution from @var{a} to @var{b}.
@c
@equation
p(x) dx = @{1 \over (b-a)@} dx
@end equation
@noindent
if @math{a \le x < b} and 0 otherwise.
@end deftypefn

@deftypefun double gsl_ran_flat_pdf (double @var{x}, double @var{a}, double @var{b})
This function computes the probability density @math{p(x)} at @var{x}
for a uniform distribution from @var{a} to @var{b}, using the formula
given above.
@end deftypefun

@tex
\centerline{\input rand-flat.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{(a+b)/2}, Variance = @math{(b-a)^2/12}, Skewness =
@math{0}, Excess = @math{-6/5} 

@item
Cumulants, @math{\kappa_1=(a+b)/2}, @math{\kappa_@{2n+1@}=0},
@math{\kappa_@{2n@}=(b-a)^@{2n@} B_@{2n@} / (2n)},

@item
Characteristic function, @math{\phi(t) = (2 \sin(ht/2)/(ht)) \exp(i t (b+a)/2)}
where @math{h = (b - a)}.

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Lognormal Distribution
@subsection The Lognormal Distribution
@deftypefn Random double gsl_ran_lognormal (const gsl_rng * @var{r}, double @var{zeta}, double @var{sigma})
@cindex Lognormal random numbers
This function returns a random number from the lognormal
distribution.  The distribution function is
@c
@equation
p(x) dx = @{1 \over x \sqrt@{2 \pi \sigma^2@} @} \exp(-(\ln(x) - \zeta)^2/2 \sigma^2) dx
@end equation
for @math{x > 0}
@end deftypefn

@deftypefun double gsl_ran_lognormal_pdf (double @var{x}, double @var{zeta}, double @var{sigma})
This function computes the probability density @math{p(x)} at @var{x}
for a lognormal distribution with parameters @var{zeta} and @var{sigma},
using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-lognormal.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{st}, 
Variance = @math{s(s-1)t^2}, 
Skewness = @math{(s+2)\sqrt@{s-1@}}, 
Excess = @math{(s-1)(s^3+3s^2+6s+6)}

where @math{s = \exp(\sigma^2)} and @math{t = \exp(\zeta)}.

The mode (maximum) occurs at @math{x = \exp(\zeta - \sigma^2)}.

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = @{1 \over 2@} erfc((\zeta-\ln(x))/ (\sqrt@{2@} \sigma))}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Chi-squared Distribution
@subsection The Chi-squared Distribution
The chi-squared distribution arises in statistics If @math{Y_i} are
@math{n} independent gaussian random numbers with unit variance then the
sum-of-squares,
@equation
X_i = \sum_i Y_i^2
@end equation
has a chi-squared distribution with @math{n} degrees of freedom.

@deftypefn Random double gsl_ran_chisq (const gsl_rng * @var{r}, double @var{nu})
@cindex Chi-squared random numbers
This function returns a random number from the chi-squared distribution
with @var{nu} degrees of freedom.
@c
@equation
p(x) dx = @{1 \over \Gamma(\nu/2) @} (x/2)^@{\nu/2 - 1@} \exp(-x/2) dx
@end equation
@noindent
for @math{x \ge 0}. 
@end deftypefn

@deftypefun double gsl_ran_chisq_pdf (double @var{x}, double @var{nu})
This function computes the probability density @math{p(x)} at @var{x}
for a chi-squared distribution with @var{nu} degrees of freedom, using
the formula given above.
@end deftypefun

@tex
\centerline{\input rand-chisq.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{\nu}, 
Variance = @math{2\nu}, 
Skewness = @math{2\sqrt@{2/\nu@}}, 
Excess = @math{12/\nu}

@item
Cumulants, @math{\kappa_1=FIXME}, @math{\kappa_n=FIXME},
for @math{n>1}

@item
Characteristic function, @math{\phi(t) = FIXME}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = FIXME}
@item
Confidence limits:

@item
Useful integral:

@end itemize

@c ----------------------------------------------------------------------
@page
@node The F-distribution
@subsection The F-distribution
The F-distribution arises in statistics. If @math{Y_1} and @math{Y_2} are
chi-squared deviates with @math{\nu_1} and @math{\nu_2} degrees of freedom
then the ratio,
@c
@equation
X = @{ (Y_1 / \nu_1) \over (Y_2 / \nu_2) @}
@end equation
@noindent
has an F-distribution @math{F(x;\nu_1,\nu_2)}.

@deftypefn Random double gsl_ran_fdist (const gsl_rng * @var{r}, double @var{nu1}, double @var{nu2})
@cindex F-distribution random numbers
This function returns a random number from the F-distribution with degrees of freedom @var{nu1} and @var{nu2}.
@c
@equation
p(x) dx = 
   @{ \Gamma((\nu_1 + \nu_2)/2)
        \over \Gamma(\nu_1/2) \Gamma(\nu_2/2) @} 
   \nu_1^@{\nu_1/2@} \nu_2^@{\nu_2/2@} 
   x^@{\nu_1/2 - 1@} (\nu_2 + \nu_1 x)^@{-\nu_1/2 -\nu_2/2@}
@end equation
@noindent
for @math{x \ge 0}. 
@end deftypefn

@deftypefun double gsl_ran_fdist_pdf (double @var{x}, double @var{nu1}, double @var{nu2})
This function computes the probability density @math{p(x)} at @var{x}
for an F-distribution with @var{nu1} and @var{nu2} degrees of freedom,
using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-fdist.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{\nu_2/(\nu_2 - 2)} (for @math{\nu_2 > 2}), Variance =
@math{2\nu_2^2 (\nu_1 + \nu_2 - 2)/(\nu_1 (\nu_2 - 2)^2 (\nu_2 - 4))}
(for @math{\nu_2 > 4})

@end itemize

@c ----------------------------------------------------------------------
@page
@node The t-distribution
@subsection The t-distribution
The t-distribution arises in statistics. If @math{Y_1} has a normal
distribution and @math{Y_2} has a  chi-squared distribution with @math{\nu}
degrees of freedom then the ratio

@equation
X = @{ Y_1 \over \sqrt@{Y_2 / \nu@} @}
@end equation
@noindent
has a t-distribution @math{t(x;\nu)} with @math{\nu} degrees of freedom.

@deftypefn Random double gsl_ran_tdist (const gsl_rng * @var{r}, double @var{nu})
@cindex t-distribution random numbers
This function returns a random number from the t-distribution. The
distribution is,
@equation
p(x) dx = @{\Gamma((\nu + 1)/2) \over \sqrt@{\pi \nu@} \Gamma(\nu/2)@}
   (1 + x^2/\nu)^@{-(\nu + 1)/2@} dx
@end equation
@noindent
@end deftypefn

@deftypefun double gsl_ran_tdist_pdf (double @var{x}, double @var{nu})
This function computes the probability density @math{p(x)} at @var{x}
for a t-distribution with @var{nu} degrees of freedom, using the formula
given above.
@end deftypefun

@tex
\centerline{\input rand-tdist.tex}
@end tex

@c ----------------------------------------------------------------------
@page
@node The Beta Distribution
@subsection The Beta Distribution
@deftypefn Random double gsl_ran_beta (const gsl_rng * @var{r}, double @var{a}, double @var{b})
@cindex Beta distribution random numbers
This function returns a random number from the beta
distribution.  The distribution function is
@c
@equation
p(x) dx = @{\Gamma(a+b) \over \Gamma(a) \Gamma(b)@} x^@{a-1@} (1-x)^@{b-1@} dx
@end equation
@end deftypefn

@deftypefun double gsl_ran_beta_pdf (double @var{x}, double @var{a}, double @var{b})
This function computes the probability density @math{p(x)} at @var{x}
for a beta distribution with parameters @var{a} and @var{b}, using the
formula given above.
@end deftypefun

@tex
\centerline{\input rand-beta.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{a/(a+b)}, Variance = @math{ab/((a+b)^2 (a+b+1))}, Skewness =
@math{2(a-b)/(a+b+2)}, Excess = @math{\sqrt@{(a+b+1) \over ab@}
\left( @{3(a+b+1)(2(a+b)^2 + ab(a+b-6)) \over ab(a+b+2)(a+b+3)@} - 3 \right)}

In the symmetric case @math{a=b} these results simplify to,

Mean = @math{1/2}, Variance = @math{1/(4(2a+1))}, Skewness = @math{0},
Excess = @math{-6 \sqrt@{2a + 1@}/(a(2a+3))}
@end itemize

@c ----------------------------------------------------------------------
@page
@node The Logistic Distribution
@subsection The Logistic Distribution

@deftypefn Random double gsl_ran_logistic (const gsl_rng * @var{r}, double @var{mu})
@cindex Logistic random numbers
This function returns a random number from the logistic
distribution.  The distribution function is
@c
@equation
p(x) dx = @{ \exp(-x/\mu) \over \mu (1 + \exp(-x/\mu))^2 @} dx
@end equation
for @math{x > 0}
@end deftypefn

@deftypefun double gsl_ran_logistic_pdf (double @var{x}, double @var{mu})
This function computes the probability density @math{p(x)} at @var{x}
for a logistic distribution with scale parameter @var{mu}, using the
formula given above.
@end deftypefun

@tex
\centerline{\input rand-logistic.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{0}, Variance = @math{\pi^2 \mu^2 / 3}, Skewness =
@math{0}, Excess = @math{6/5}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_@{-\infty@}^x p(x') dx' = 1/(1+\exp(-x/\mu))}
@item
Confidence limits:

@item
Useful integral:

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Pareto Distribution
@subsection The Pareto Distribution
@deftypefn Random double gsl_ran_pareto (const gsl_rng * @var{r}, double @var{a}, double @var{b})
@cindex Lognormal random numbers
This function returns a random number from the Pareto distribution of
order @var{a}.  The distribution function is,
@c
@equation
p(x) dx = a b^a / x^@{a+1@} dx
@end equation
for @math{x \ge b}
@end deftypefn

@deftypefun double gsl_ran_pareto_pdf (double @var{x}, double @var{a}, double @var{b})
This function computes the probability density @math{p(x)} at @var{x}
for a Pareto distribution with exponent @var{a} and scale @var{b}, using
the formula given above.
@end deftypefun

@tex
\centerline{\input rand-pareto.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{ab/(a-1)} (for @math{a>1}), 
Variance = @math{a b^2/((a-2)(a-1)^2)} (for @math{a>2},
Skewness = @math{2(a+1)\sqrt@{(a-2)/a@}/(a-3)} (for @math{a>3}),
Excess = @math{6(a(a^2+a-6)-2)/(a(a-3)(a-4))} (for @math{a>4}),  
Mode = @math{b}

@item
Cumulants, @math{\kappa_1=FIXME}, @math{\kappa_n=FIXME},
for @math{n>1}

@item
Characteristic function, @math{\phi(t) = FIXME}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = 1 - (b / x)^a}
@item
Confidence limits:

@item
Useful integral:

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Spherical Distribution (2D & 3D)
@subsection The Spherical Distribution (2D & 3D)

The spherical distributions generate random vectors, located on a
spherical surface. They can be used as random directions, for example in
the steps of a random walk.

@deftypefn Random void gsl_ran_dir_2d (const gsl_rng * @var{r}, double *@var{x}, double *@var{y})
@cindex 2D random direction vector
@cindex direction vector, random 2D
@cindex spherical random numbers, 2D
This function returns a random direction vector @math{v} =
(@var{x},@var{y}) in two dimenions. The vector is normalized
such that @math{|v|^2 = x^2 + y^2 = 1}.
The obvious way to do this is to take a uniform random number between 
0 and @math{2\pi} and let @var{x} and @var{y} be the sine and cosine
respectively.  Two trig functions would have been expensive in the old
days, but with modern hardware implementations, this is sometimes the
fastest way to go.  This is the case for my home Pentium (but not the
case for my Sun Sparcstation 20 at work).  Once can 
avoid the trig evaluations by choosing @var{x} and @var{y} in the
interior of a unit circle (choose them at random from the interior
of the enclosing square, and then reject those that are outside the
unit circle), and then dividing by @math{\sqrt@{x^2 + y^2@}}.
A much
cleverer approach,  attributed to von Neumann (See Knuth, v2, 3rd ed, p140, 
exercise 23), requires neither trig nor a square root.  In this approach,
@var{u} and @var{v} are chosen at random from the interior of a unit
circle, and then @math{x=(u^2-v^2)/(u^2+v^2)} and @math{y=uv/(u^2+v^2)}.
@end deftypefn

@deftypefn Random void gsl_ran_dir_3d (const gsl_rng * @var{r}, double *@var{x}, double *@var{y}, double * @var{z})
@cindex 3D random direction vector
@cindex direction vector, random 3D
@cindex spherical random numbers, 3D
This function returns a random direction vector @math{v} =
(@var{x},@var{y},@var{z}) in three dimenions. The vector is
normalized such that @math{|v|^2 = x^2 + y^2 + z^2 = 1}.
The method employed is due to Robert E. Knop (CACM 13, 326 (1970)),
and explained in Knuth, v2, 3rd ed, p136.  It uses the 
surprising fact that the distribution projected along any axis is 
actually uniform (this is only true for 3d).
@end deftypefn

@deftypefn Random void gsl_ran_dir_nd (const gsl_rng * @var{r}, int @var{n}, double *@var{x})
@cindex N-dimensional random direction vector
@cindex direction vector, random N-dimensional
@cindex spherical random numbers, N-dimensional
This function returns a random direction vector @math{v} =
@math{x_1,x_2,\ldots,x_n} in @var{n} dimenions. The vector is
normalized such that @math{|v|^2 = x_1^2 + x_2^2 + \cdots + x_n^2 = 1}.
The method uses the fact that a multivariate gaussian distribution
is spherically symmetric.  Each component is generated to have a gaussian
distribution, and then the components are normalized.  The method
is described by Knuth, v2, 3rd ed, p135-136, and attributed to
G. W. Brown, Modern Mathematics for the Engineer (1956).
@end deftypefn

@noindent
The follwing program generates a random walk in two dimensions.

@example
#include <stdio.h>
#include <gsl_rng.h>
#include <gsl_randist.h>

main ()
@{
  gsl_rng * r = gsl_rng_alloc (gsl_rng_env_setup()) ;
  int i ;
  double x = 0, y = 0, dx, dy;

  printf("%g %g\n", x, y) ;

  for (i = 0; i < 10; i++)
    @{
      gsl_ran_dir_2d (r, &dx, &dy) ;
      x += dx ; y += dy; 
      printf("%g %g\n", x, y) ;
    @}
@}
@end example
@noindent
Example output from the program, three 10-step random walks from the origin.

@tex
%\centerline{\input random-walk.tex}      
@end tex


@c ----------------------------------------------------------------------
@page
@node The Weibull Distribution
@subsection The Weibull Distribution
@deftypefn Random double gsl_ran_weibull (const gsl_rng * @var{r}, double @var{mu}, double @var{a})
@cindex Weibull distribution random numbers
This function returns a random number from the Weibull distribution. The
distribution is,
@equation
p(x) dx = @{a \over \mu^a@} x^@{a-1@}  \exp(-(x/\mu)^a) dx
@end equation
@noindent
for @math{-\infty < x < \infty}.
@end deftypefn

@deftypefun double gsl_ran_weibull_pdf (double @var{x}, double @var{mu}, double @var{a})
This function computes the probability density @math{p(x)} at @var{x}
for a Weibull distribution with scale @var{mu} and exponent @var{a},
using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-weibull.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{\Gamma(1+1/a) \mu}, 
Variance = @math{(\Gamma(1+2/a)-\Gamma(1+1/a))\mu^2}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = 1 - \exp(-(x/\mu)^a)}
@end itemize

@c ----------------------------------------------------------------------
@page
@node The Gumbel Distribution
@subsection The Gumbel Distribution
@deftypefn Random double gsl_ran_gumbel1 (const gsl_rng * @var{r}, double @var{a}, double @var{b})
@deftypefnx Random double gsl_ran_gumbel2 (const gsl_rng * @var{r}, double @var{a}, double @var{b})
@cindex Gumbel distribution, random numbers
These functions return random numbers from the Type-1 and Type-2 Gumbel
distributions. The Type-1 Gumbel distribution is,
@equation
p(x) dx = a b \exp(-(b \exp(-ax) + ax)) dx
@end equation
@noindent
for @math{-\infty < x < \infty}. The Type-2 Gumbel distribution is,
@equation
p(x) dx = a b x^@{-a-1@} \exp(-b x^@{-a@}) dx
@end equation
@noindent
for @math{0 < x < \infty}.
@end deftypefn

@deftypefun double gsl_ran_gumbel1_pdf (double @var{x}, double @var{a}, double @var{b})
@deftypefunx double gsl_ran_gumbel2_pdf (double @var{x}, double @var{a}, double @var{b})
These function computes the probability density @math{p(x)} at @var{x}
for a Type-1 or Type-2 Gumbel distribution with parameters @var{a} and
@var{b}, using the formulas given above.
@end deftypefun

@tex
\centerline{\input rand-gumbel.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{\Gamma(1+1/a) \mu}, 
Variance = @math{(\Gamma(1+2/a)-\Gamma(1+1/a))\mu^2}

@item
Cumulative distribution function, 
@math{CDF(x) = \int_0^x p(x') dx' = 1 - \exp(-(x/\mu)^a)}
@end itemize

@c ----------------------------------------------------------------------
@page
@section Discrete distributions

@c ----------------------------------------------------------------------
@node General Discrete Distributions
@subsection General Discrete Distributions

Given @var{K} discrete events with different probabilities @var{P[k]},
produce a random value @var{k} consistent with its probability.

The obvious way to do this is to preprocess the probability list by
generating a cumulative probability array with @math{K+1} elements:
@code{C[0] = 0; C[k+1] = C[k]+P[k]}.  Note that this construction
produces @math{C[K]=1}.  Now choose a uniform deviate @var{u} between 0
and 1, and find the value of @var{k} such that @math{C[k]\le u <
C[k+1]}.  Although this in principle requires of order @math{\log K}
steps per random number generation, they are fast steps, and if you use
something like @math{\lfloor uK\rfloor} as a starting point, you can
often do pretty well.

But faster methods have been devised.  Again, the idea is to preprocess
the probability list, and save the result in some form of lookup table;
then the individual calls for a random discrete event can go rapidly.
An approach invented by G. Marsaglia (Generating discrete random numbers
in a computer, Comm ACM 6, 37-38 (1963)) is very clever, and readers
interested in examples of good algorithm design are directed to this
short and well-written paper.  Unfortuantely, for large @var{K},
Marsaglia's lookup table can be quite large.  A much better approach is
due to Alastair J. Walker (An efficient method for generating discrete
random variables with general distributions, ACM Trans on Mathematical
Software 3, 253-256 (1977); see also Knuth, v2, 3rd ed, p120-121,139).
This requires two lookup tables, one floating point and one integer, but
both only of size @var{K}.  After preprocessing, the random numbers are
generated in O(1) time, even for large @var{K}.  The preprocessing
suggested by Walker requires @math{O(K^2)} effort, but that is not
actually necessary, and the implementation provided here only takes
@math{O(K)} effort.  In general, more preprocessing leads to faster
generation of the individual random numbers, but a diminishing return
is reached pretty early.  Knuth points out that the optimal preprocessing
is combinatorially difficult for large @var{K}.

This method can be used to speed up some of the discrete random number
generators below, such as the binomial distribution.  To use if for
something like the Poisson Distribution, a modification would have to
be made, since it only takes a finite set of @var{K} outcomes.

@deftypefn Random {gsl_ran_discrete_t *} gsl_ran_discrete_preproc (int @var{K}, const 
double * @var{P})
@cindex Discrete random numbers
@cindex Discrete random numbers, preprocessing
This function returns a pointer to a structure that contains the lookup
table for the discrete random number generator.  The array @code{P[]} contains
the probabilities of the discrete events; these array elements must all be 
positive, but they needn't add up to one (so you can think of them more
generally as "weights") -- the preprocessor will normalize appropriately.
This return value is used
as an argument for the @code{gsl_ran_discrete} function below.
@end deftypefn

@deftypefn Random {int} gsl_ran_discrete (const gsl_rng * @var{r}, const gsl_ran_discrete_t * @var{g})
@cindex Discrete random numbers
After the preprocessor, above, has been called, you use this function to
get the discrete random numbers.
@end deftypefn

@deftypefn Random {double} gsl_ran_discrete_pdf (int @var{k}, const gsl_ran_discrete_t * @var{g})
@cindex Discrete random numbers
Returns the probability @var{P[k]} of observing the variable @var{k}.
Since @var{P[k]} is not stored as part of the lookup table, it must be
recomputed; this computation takes @var{O(K)}, so if @var{K} is large
and you care about the original array @var{P[k]} used to create the
lookup table, then you should just
keep this original array @var{P[k]} around.
@end deftypefn

@deftypefn Random {void} gsl_ran_discrete_free (gsl_ran_discrete_t * @var{g})
@cindex Discrete random numbers
De-allocates the lookup table pointed to by @var{g}.
@end deftypefn

@c ----------------------------------------------------------------------
@node The Poisson Distribution
@subsection The Poisson Distribution
@deftypefn Random {unsigned int} gsl_ran_poisson (const gsl_rng * @var{r}, double @var{mu})
@cindex Poisson random numbers
This function returns a random integer from the Poisson distribution
with mean @var{mu}. The probability distribution for Poisson random
numbers is,
@c
@equation
p(k) = @{\mu^k \over k!@} \exp(-\mu)
@end equation
@noindent
for @math{k \ge 0}.
@end deftypefn

@deftypefun double gsl_ran_poisson_pdf (unsigned int @var{k}, double @var{mu})
This function computes the probability @math{p(k)} of obtaining  @var{k}
from a Poisson distribution with mean @var{mu}, using the formula
given above.
@end deftypefun

@tex
\centerline{\input rand-poisson.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{\mu}, Variance = @math{\mu^2}, Skewness =
@math{1/\sqrt\mu}, Excess = @math{1/\mu}

@item
Cumulants, @math{\kappa_n=m} for all @math{n}

@item
Characteristic function, @math{\phi(t) = \exp(m(e^@{it@}-1))}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Bernoulli Distribution
@subsection The Bernoulli Distribution
@deftypefn Random {unsigned int} gsl_ran_bernoulli (const gsl_rng * @var{r}, double @var{p})
@cindex Bernoulli trial, random numbers
This function returns the result either 0 or 1, the result of a
Bernoulli trial with probability @var{p}. The probability distribution
for a Bernoulli trial is,
@c
@equation
p(0) = 1 - p
@end equation
@equation
p(1) = p
@end equation
@end deftypefn

@deftypefun double gsl_ran_bernoulli_pdf (unsigned int @var{k}, double @var{p})
This function computes the probability @math{p(k)} of obtaining
@var{k} from a Bernoulli distribution with probability parameter
@var{p}, using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-bernoulli.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{p}, Variance = @math{p(1-p)}, Skewness =
@math{(1-2p)/\sqrt@{p(1-p)@}}, Excess = @math{1-6p(1-p))/(p(1-p))}

@item
Cumulants, @math{\kappa_n=FIXME} for all @math{n}

@item
Characteristic function, @math{\phi(t) = FIXME}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Binomial Distribution
@subsection The Binomial Distribution
@deftypefn Random {unsigned int} gsl_ran_binomial (const gsl_rng * @var{r}, double @var{p}, unsigned int @var{n})
@cindex Binomial random numbers
This function returns a random integer from the binomial distribution,
the number of successes in @var{n} independent trials with probability
@var{p}. The probability distribution for binomial random numbers is,
@c
@equation
p(k) = @{n! \over k! (n-k)! @} p^k (1-p)^@{n-k@}
@end equation
@noindent
for @math{0 \le k \le n}.
@end deftypefn

@deftypefun double gsl_ran_binomial_pdf (unsigned int @var{k}, double @var{p}, unsigned int @var{n})
This function computes the probability @math{p(k)} of obtaining @var{k}
from a binomial distribution with parameters @var{p} and @var{n}, using
the formula given above.
@end deftypefun

@tex
\centerline{\input rand-binomial.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{np}, Variance = @math{np(1-p)}, Skewness =
@math{(1-2p)/\sqrt@{np(1-p@}}, Excess = @math{(1-6p(1-p))/(np(1-p))}

@item
Cumulants, @math{\kappa_1=np}, @math{\kappa_@{r+1@}=p(1-p)(d\kappa_r/dp)},
for @math{n>1}

@item
Characteristic function, @math{\phi(t) = (1-p + p\exp(it))^n}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Negative Binomial Distribution
@subsection The Negative Binomial Distribution
@deftypefn Random {unsigned int} gsl_ran_negative_binomial (const gsl_rng * @var{r}, double @var{p}, double @var{n})
@cindex Negative Binomial distribution, random numbers
This function returns a random integer from the negative binomial
distribution, the number of failures occurring before @var{n} successes
in independent trials with probability @var{p} of success. The
probability distribution for negative binomial random numbers is,
@c
@equation
p(k) = @{\Gamma(n + k) \over \Gamma(k+1) \Gamma(n) @} p^n (1-p)^k
@end equation
@noindent
Note that @math{k} is not required to be an integer.
@end deftypefn

@deftypefun double gsl_ran_nbinomial_pdf (unsigned int @var{k}, double @var{p}, double  @var{n})
This function computes the probability @math{p(k)} of obtaining @var{k}
from a negative binomial distribution with parameters @var{p} and
@var{n}, using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-nbinomial.tex}
@end tex

@deftypefn Random {unsigned int} gsl_ran_pascal (const gsl_rng * @var{r}, double @var{p}, unsigned int @var{k})
This function returns a random integer from the Pascal distribution. The
Pascal distribution is simply a negative binomial distribution with an
integer value of @math{n}.
@equation
p(k) = @{(n + k - 1)! \over k! (n -1)! @} p^n (1-p)^k
@end equation
@end deftypefn

@deftypefun double gsl_ran_pascal_pdf (unsigned int @var{k}, double @var{p}, unsigned int @var{n})
This function computes the probability @math{p(k)} of obtaining @var{k}
from a Pascal distribution with parameters @var{p} and
@var{n}, using the formula given above.
@end deftypefun

@subheading Properties
@itemize @asis
@item
Mean = @math{n(1-p)/p}, Variance = @math{n(1-p)/p^2}, Skewness =
@math{(2-p)/\sqrt@{n(1-p)@}}, Excess = @math{(1/n)(6+@{p^2 \over 1 -
p@})}
@end itemize

@c ----------------------------------------------------------------------
@page
@node The Geometric Distribution
@subsection The Geometric Distribution
@deftypefn Random {unsigned int} gsl_ran_geometric (const gsl_rng * @var{r}, double @var{p})
@cindex Geometric random numbers
This function returns a random integer from the geometric distribution,
the number of independent trials with probability @var{p} until the
first success. The probability distribution for geometric random numbers
is,
@c
@equation
p(k) =  p (1-p)^k
@end equation
@noindent
for @math{k \ge 1}.
@end deftypefn

@deftypefun double gsl_ran_geometric_pdf (unsigned int @var{k}, double @var{p})
This function computes the probability @math{p(k)} of obtaining @var{k}
from a geometric distribution with probability parameter @var{p}, using
the formula given above.
@end deftypefun

@tex
\centerline{\input rand-geometric.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{(1-p)/p}, Variance = @math{(1-p)/p^2}, Skewness =
@math{(2-p)/\sqrt@{1-p@}}, Excess = @math{6+(p^2/(1-p))}

@item
Cumulants, @math{\kappa_1=(1-p)/p},
@math{\kappa_@{r+1@}=-(1-p)(d\kappa_r/dp)}, for @math{r>1}

@item
Characteristic function, @math{\phi(t) = p/(1 - (1-p)\exp(it)}

@end itemize

@c ----------------------------------------------------------------------
@page
@node The Hypergeometric Distribution
@subsection The Hypergeometric Distribution
@deftypefn Random {unsigned int} gsl_ran_hypergeometric (const gsl_rng * @var{r}, unsigned int @var{n1}, unsigned int @var{n2}, unsigned int @var{t})
@cindex Geometric random numbers
This function returns a random integer from the hypergeometric
distribution. The probability distribution for hypergeometric
random numbers is,
@c
@equation
p(k) =  C(n1,k) C(n2, t-k) / C(n1+n2,k)
@end equation
@noindent
where @math{C(a,b) = a!/(b!(a-b)!)}. The domain of @math{k} is
@math{max(0,t-n_2)}, ..., @math{max(t,n_1)}.
@end deftypefn

@deftypefun double gsl_ran_hypergeometric_pdf (unsigned int @var{k}, unsigned int @var{n1}, unsigned int @var{n2}, unsigned int @var{t})
This function computes the probability @math{p(k)} of obtaining @var{k}
from a hypergeometric distribution with parameters @var{n1}, @var{n2},
@var{n3}, using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-hypergeometric.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{t n_1 / N}, Variance = @math{t n_1 n_2 (N-t)/(N^2(N-1))},
Skewness = @math{(n_2 - n_1)(N-2t) \sqrt@{(N-1)/(t n_1 n_2 (N-t))@}}, where
@math{N = n_1 + n_2}.
@end itemize

@c ----------------------------------------------------------------------
@page
@node The Logarithmic Distribution
@subsection The Logarithmic Distribution
@deftypefn Random {unsigned int} gsl_ran_logarithmic (const gsl_rng * @var{r}, double @var{p})
@cindex Logarithmic random numbers
This function returns a random integer from the logarithmic
distribution. The probability distribution for logarithmic random numbers
is,
@c
@equation
p(k) = @{-1 \over \log(1-p)@} @{\left( p^k \over k \right)@}
@end equation
@noindent
for @math{n \ge 1}.
@end deftypefn

@deftypefun double gsl_ran_logarithmic_pdf (unsigned int @var{k}, double @var{p})
This function computes the probability @math{p(k)} of obtaining @var{k}
from a logarithmic distribution with probability parameter @var{p},
using the formula given above.
@end deftypefun

@tex
\centerline{\input rand-logarithmic.tex}
@end tex

@subheading Properties
@itemize @asis
@item
Mean = @math{a p / (1-p)}, Variance = @math{a p (1-a p)/(1-p)^2}
where @math{a = -1/\log(1-p)}
@end itemize

@c ----------------------------------------------------------------------
@c @deftypefn Random void gsl_ran_poisson_array (const gsl_rng * @var{r}, double @var{mu}, int @var{N}, int *@var{p})
@c @code{gsl_ran_poisson_array} places an array of @var{N}
@c poisson--distributed random numbers with mean @var{mu} into the array
@c @var{p}.
@c @end deftypefn

@page
@node Shuffling and Sampling
@section Shuffling and Sampling

@deftypefn Random void gsl_ran_shuffle (const gsl_rng * @var{r}, void * @var{base}, size_t @var{n}, size_t @var{size})

This function randomly shuffles the order of @var{n} objects, each of
size @var{size}, stored in the array @var{base}[0..@var{n}-1].

The following code shows how to shuffle the numbers from 0 to 51,

@example
int a[52];

for (i = 0; i < 52; i++)
  @{
    a[i] = i ;
  @}

gsl_ran_shuffle (r, a, 52, sizeof (int));
@end example

@end deftypefn

@deftypefn Random {void *} gsl_ran_choose (const gsl_rng * @var{r}, void * @var{dest}, size_t @var{k}, void * @var{src}, size_t @var{n}, size_t @var{size})
This function fills the array @var{dest[k]} with @var{k} objects taken
randomly from the @var{n} elements of the array @var{src[n]}. The
objects are each of size @var{size}. The objects are sampled without
replacement, thus each object can only appear once in @var{dest[k]}.  It
is required that @var{k} be less than or equal to @code{n}. The objects
in @var{dest} will be in the same relative order as those in @var{src}.
You will need to call @code{gsl_ran_shuffle(r, dest, n, size)} if you
want to randomize the order.

The following code shows how to select a random sample of three unique
numbers from the set 0 to 99,

@example
double a[3], b[100];

for (i = 0; i < 100; i++)
  @{
    b[i] = (double) i ;
  @}

gsl_ran_choose (r, a, 3, b, 100, sizeof (double));
@end example


@end deftypefn

@node Random Number References and Further Reading
@section Random Number References and Further Reading
@noindent

@url{ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/handsim.ps}.

@itemize @asis
@item
Donald E. Knuth, @cite{The Art of Computer Programming: Seminumerical
Algorithms} (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.
@end itemize
@noindent

@itemize @asis
@item
Luc Devroye, @cite{Non-Uniform Random Variate Generation},
Springer-Verlag, ISBN 0-387-96305-7.
@end itemize
@noindent

See the pLab home page (http://random.mat.sbg.ac.at/) for a lot of information
on the state-of-the-art in random number generation, and for numerous links
to various "random" WWW sites.  

For physicists the Particle Data Group provides a useful short review of
techniques for generating distributions of random numbers in the
"Monte Carlo" section of its Annual Review of Particle Physics.

@itemize @asis
@item
@cite{Review of Particle Properties}
R.M. Barnett et al., Physical Review D54, 1 (1996)
@url{http://pdg.lbl.gov/}.
@end itemize
@noindent
The Review of Particle Physics is available online in postscript and pdf
format.

The source code for the @sc{diehard} random number generator tests is also
available online.

@itemize @asis
@item
@cite{DIEHARD source code} 
G. Marsaglia
@url{http://stat.fsu.edu/pub/diehard/}
@end itemize

@node Random Number Acknowledgements
@section Random Number Acknowledgements
@noindent
Thanks to Makoto Matsumoto, Takuji Nishimura and Yoshiharu Kurita for
making the source code to their generators (MT19937, MM&TN; TT800,
MM&YK) available under the GNU General Public License.

@c lcg
@c [ LCG(n) := n * 69069 mod (2^32) ]
@c First 6: [69069, 475559465, 2801775573, 1790562961, 3104832285, 4238970681]
@c %2^31-1   69069, 475559465, 654291926, 1790562961, 957348638, 2091487034
@c mrg
@c [q([x1, x2, x3, x4, x5]) := [107374182 mod 2147483647 * x1 + 104480 mod 2147483647 * x5, x1, x2, x3, x4]]
@c
@c cmrg
@c [q1([x1,x2,x3]) := [63308 mod 2147483647 * x2 -183326 mod 2147483647 * x3, x1, x2],
@c  q2([x1,x2,x3]) := [86098 mod 2145483479 * x1 -539608 mod 2145483479 * x3, x1, x2] ]
@c  intial for q1 is [69069, 475559465, 654291926]
@c  intial for q2 is  [1790562961, 959348806, 2093487202]

@c tausworthe
@c    [ b1(x) := rsh(xor(lsh(x, 13), x), 19),
@c      q1(x) := xor(lsh(and(x, 4294967294), 12), b1(x)),
@c      b2(x) := rsh(xor(lsh(x, 2), x), 25),
@c      q2(x) := xor(lsh(and(x, 4294967288), 4), b2(x)),
@c      b3(x) := rsh(xor(lsh(x, 3), x), 11),
@c      q3(x) := xor(lsh(and(x, 4294967280), 17), b3(x)) ]
@c      [s1, s2, s3] = [600098857, 1131373026, 1223067536] 
@c [2948905028, 441213979, 394017882]
