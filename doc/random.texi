@cindex random
@cindex gaussian
@cindex uniform
@cindex poisson

@menu
* General comments on random numbers::  
* Routines for the casual user::  
* Somewhat more advanced functions::  
* Algorithm-specific random number generators::  
* How to link::                 
* How to incorporate a new random number generator algorithm into this scheme::  
@end menu

@node General comments on random numbers
@section General comments on random numbers

In 1988, Park and Miller wrote a paper entitled ``Random number
generators: good ones are hard to find.'' [Commun. ACM, 31, 1192--1201].
Fortunately, some excellent RNG's are available, though poor ones are
still in common use.  You may be happy with the system-supplied random
number generator on your computer, but you should be aware that as
computers get faster, requirements on random number generators increase.
Nowadays, a simulation that calls a random number generator millions of
times can often finish before you can make it down the hall to the
coffee machine and back. 

A very nice review of random number generators was written by 
Pierre L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, 
Jerry Banks, ed. (Wiley, 1997).  The chapter is available in postscript
from from L'Ecuyer's ftp site:
(ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/handsim.ps).
Volume 2 of Knuth's SemiNumerical Algorithms series (originally
published in 1968) devotes 170 pages to random number genertors,
and is only now starting to show its age.  Nonetheless,
it is brilliant, a classic.  If you don't own it, you should stop
reading right now, run to the nearest bookstore, and buy it.

See the pLab home page (http://random.mat.sbg.ac.at/) for a lot of information
on the state-of-the-art in random number generation, and for numerous links
to various "random" WWW sites.  

A good random number generator will satisfy both theoretical and
statistical properties.  Theoretical properties are often hard to obtain
(they require real math!), but one prefers a random number generator
with a long period, low serial correlation, and a tendency @emph{not} to
``fall mainly on the planes.''  Statistical tests are performed with
numerical simulations.  Generally, a random number generator is used to
estimate some quantity for which the Theory of Probability provides an
exact answer.  Comparison to this exact answer provides a measure of
"randomness".

The @value{GSL} provides a collection of generators, of varying
quality.  My favorite is 'taus', which is based on a combined Tausworthe
generator.  The 'mrg' and 'cmrg' (a multiple recursive generator, and a
combined mrg) algorithms are of high quality, but are computationally
more expensive than some of the others.  The 'uni' and 'zuf' algorithms
are both based on a Fibonacci scheme; the former involves a lag of only
17 and is not recommended, while the second has a lag of over 600 and
seems to have good statistical properties.  More details for each of
the algorithms are available in the source code.

@node Routines for the casual user
@section Routines for the casual user

@deftypefn Random void gsl_ran_seed(int s)
@code{gsl_ran_seed} initializes (or `seeds') the random number
generator.  In general, it is recommended that
this routine be called before any random numbers are generated. We have
tried to set up the generators so that they will still produce sensible
random numbers even if the seed has not been explicitly set (in
particular, we have default initialized them as if the seed was
set with @code{s=1}), but you should
not trust us.  What we do guarantee is: If the
random number generator is seeded with the same value of @code{s} on two
different runs, the same stream of random numbers should be generated (by
successive calls to the routines below).  If (even
slightly) different values of @code{s} are supplied, then the generated
streams of random numbers should be 
completely different, uncorrelated, and independent of each other.
@end deftypefn

@deftypefn Random {unsigned long} gsl_ran_random()
@code{gsl_ran_random} returns a random positive integer.
All integers between 1 [FIXME: Is 0 ever a return value??] 
and the maximum value are equally likely.
The maximum value depends on the algorithm used for random number generation,
and it is given by...
@end deftypefn

@deftypefn Random double gsl_ran_max()
@code{gsl_ran_max} returns the maximum value that @code{gsl_ran_random}
can return.
@end deftypefn

@deftypefn Random double gsl_ran_uniform()
@code{gsl_ran_uniform} returns a (@code{double} precision) floating point 
number uniformly distributed between zero and one.  Usually (but not always) 
this is implemented as:
@code{
double gsl_ran_uniform() @{ return (double)gsl_ran_random()*dx; @}
}
where @code{dx} is @code{1./gsl_ran_max()}.
@end deftypefn

@deftypefn Random double gsl_ran_gaussian()
@code{gsl_ran_gaussian} returns a gaussian random number, with mean zero and
variance one.
@end deftypefn

@deftypefn Random double gsl_ran_poisson (double @var{mu})
@code{gsl_ran_poisson} returns a poisson--distributed random number,
with mean @var{mu}.
@end deftypefn

@deftypefn Random void gsl_ran_poisson_array (double @var{mu}, int @var{N}, int *@var{p})
@code{gsl_ran_poisson_array} places an array of @var{N}
poisson--distributed random numbers with mean @var{mu} into the array
@var{p}.
@end deftypefn

@deftypefn Random double gsl_ran_exponential (double @var{mu})
@code{gsl_ran_exponential} returns a poisson--distributed random number,
with mean @var{mu}.  This is calculated with @math{-mu*log(x)}.
@end deftypefn

@deftypefn Random {int *} gsl_ran_shuffle(int N, int *x)
@code{gsl_ran_shuffle} takes an array of N integers x[0..N-1] and 
randomly shuffles their order.  @code{x} is altered and is returned.
if @code{x} is supplied as NULL, then memory is allocated for
@code{x[]}, and it is filled with a random permutation of the 
numbers 0,...,N-1.  
@end deftypefn

@deftypefn Random {int *} gsl_ran_choose(int K, int N, int *x)
@code{gsl_ran_choose} fills the array @code{x[K]} with @code{K}
integers taken randomly from 0,...,N-1.  It is required that 
@code{K} be less than or equal to @code{N}. The numbers will be
in numerical order.  You will need to call @code{gsl_ran_shuffle(K,x)}
if you want them in random order.
@end deftypefn

@node Somewhat more advanced functions
@section Somewhat more advanced functions

It is important to remember that a function like @code{gsl_ran_uniform()}
is not a "real" function like the sine or cosine.  Unlike real
functions, successive calls to @code{gsl_ran_uniform()} yield different
return values.  Of course that is just what you want for a random number
generator, but to achieve this effect, the generator must keep track of
some kind of "state" variable.  Sometimes this state is just an integer
(sometimes just the value of the previously generated random number),
but often it is more complicated than that and may involve a whole array
of numbers, possibly with some indices thrown in.  To use the random
number generators, you do not need to know the details of what comprises
the state, and besides that varies from algorithm to algorithm.  

The above methods blithely ignore the random number `state' which
changes from call to call.  But it is often practical to be able to
"save" and "restore" the state.  Or to maintain independent streams of
random numbers in which each refers to its own (and not to a single
common) state.  To permit these practices, a few somewhat more advanced
functions are supplied.  These include:

@deftypefn Random {void *} gsl_ran_getRandomState ()
@code{gsl_ran_getRandomState} returns a pointer to a @emph{copy} of the
@code{static} random number state used by @code{gsl_ran_random()},
@code{gsl_ran_uniform()}, etc.  Note that a @code{void *} pointer is
returned, so that we don't have to be specific about the type that
the state is.  Also, note that @code{calloc()} is used to allocate
memory for the copy of the random state, and that too many calls to this
function can lead to a problem with memory leaking.  You can alleviate this
problem by @code{cfree}'ing the memory after you are finished with it.
@end deftypefn

@deftypefn Random void gsl_ran_setRandomState (void *@var{vState})
@code{gsl_ran_setRandomState} copies the state pointed to by
@var{vState} into the @code{static} random number state.  After doing
this, you may want to @code{cfree((char *)vState)} to recover the
memory.
@end deftypefn

@deftypefn Random void gsl_ran_seed_wstate (void *@var{vState}, int @var{s})
@code{gsl_ran_seed_wstate} initializes the random number whose state
is pointed to by @code{vState}.
@end deftypefn

@deftypefn Random {unsigned long} gsl_ran_random_wstate(void *vState)
@code{gsl_ran_random_wstate} updates the state pointed to by @code{vState},
and returns the integer random number resulting from that update.
@end deftypefn

@deftypefn Random double gsl_ran_uniform_wstate(void *vState)
@code{gsl_ran_uniform_wstate} updates the state pointed to by @code{vState},
and returns the uniformly distributed real random number 
resulting from that update.
@end deftypefn

@deftypefn Random void gsl_ran_printState(void *vState)
@code{gsl_ran_printState} writes the current state of the random number
generator to @code{stdout}.  Depending on the random number generator,
this can may be an integer or two, or a list with hundreds of
twenty-four digit floating point numbers.  It's only conceivable use is
for debugging.
@end deftypefn

@node Algorithm-specific random number generators
@section Algorithm-specific random number generators

The above functions make no reference to the actual algorithm used.
This is deliberate so that you can change algorithms without having to
change any of your application source code.  Simply link against another
object file.

Among the algorithms available are: 

mrg       Multiple recursive

cmrg      Combined MRG

taus      Combined Tausworthe

uni       Fibonacci subtraction

uni32     32 bit version of uni

zuf       Another Fibonacci subtraction method, but with a much longer
lag than uni.

rand      Linear congruental 

To invoke these routines, use @code{gsl_ran_xxx_yyyyy()}, where @code{xxx}
is the algorithm, and @code{yyyyy} describes what is wanted.  For instance,
@code{gsl_ran_taus_uniform()} returns a uniform random number generated by
the combined Tausworthe method.

It is also possible to choose, for example, the @code{mrg} algorithm as the
default used by, for instance, @code{gsl_ran_uniform()}, by using the call
@code{gsl_ran_use_mrg()}. 

@node How to link
@section How to link

This is not set in stone yet, but for now link against @code{xxx.o
xxx-gen.o} to cause the generic calls to use algorithm @code{xxx}.  Link
against @code{xxx1.o xxx2.o ... xxxN.o switch.o} to permit the use of
@code{gsl_ran_use_xxx1()}, ..., @code{gsl_ran_use_xxxN()} in order to
specify the algorithm at run-time.  Note that this second scheme
involves an extra step of indirection and might not be as efficient (but
then again, function call overhead may well be small compared to the
calculations involved to generate a good random number)

The library @code{libgslrandom.a} contains code for all of the random number
generators.   If you link using `@code{-lgslrandom}', that will be equivalent to
using @code{xxx1.o xxx2.o ... xxxN.o switch.o}, with all incorporated
generators included, and one of them the default. [*FIXME: Not sure which
one...use the @code{gsl_ran_use_xxx()} to set it explicitly before you call
any random number generators *]

Your code should also have an @code{#include "gsl_ran.h"} in it.

@node How to incorporate a new random number generator algorithm into this scheme
@section How to incorporate a new random number generator algorithm into this scheme

Suppose you run across a nifty article describing a new algorithm for
generating a random number.  You can place it in the scheme here by
doing the following:

Easy first step is to think of a short name for the generator.  It should
be less than ten characters, involve no whitespace, and `xxx' isn't allowed.
Let's say you choose `cool'.

You will want to make a file called `cool.c';  the easiest place to start
is by copying the file `xxx.c' over to `cool.c', and then replacing every
occurrence of `xxx' in that file with `cool'.   Then you'll have to do some
real editing.

Determine the "state" of the generator.  Sometimes this isn't obvious,
but generally the state variables will either be @code{static} or
external to the subroutine that returns the random numbers.  Create a
@code{struct} with all the state variables.  Do not use pointers!  When
the state is copied, you don't want the pointers pointing to values in
another state.  The @code{struct} should be typedef'd to have the name
@code{gsl_ran_cool_randomState}.  
Create a @code{static} realization of this state called @code{state}.

Write functions @code{unsigned long gsl_ran_cool_random_wstate(void *vState)}, 
@code{void gsl_ran_cool_seed_wstate(void *vState,int)}, 
@code{double gsl_ran_cool_uniform_wstate(void *vState)}, and
@code{static void gsl_ran_cool_printState_p(gsl_ran_cool_randomState *rState)},
and include them in the @code{cool.c} file.   Add the line 
`@code{#include "cool-state.c"}' as the last line of the @code{cool.c}
file.  The file @code{cool-state.c} will be automatically generated,
and it will contain code for the "stateless" versions of the 
random number generator, such as
@code{double gsl_ran_cool_uniform()}, as well as code for getting and
setting the state.  (Since that code, at the source level, doesn't depend
on the details of the @code{state} structure, there is no point in having
to write it yourself.)

Add `@code{cool}' to the list in the `@code{ALLRAN=...}' line of the file
@code{Makefile.ami}.

Now you can `@code{make cool}', or `@code{make test-cool}', or 
`@code{make bench-cool}', to get executable files for using/testing your
cool new random number generator.

Having made 'test-cool', you have done everything that is necessary.
But it is recommended that you run it with a random seed of 1, and record
the state in a temporary file.  Update the @code{cool.c} code by
initializing the static random state with these values.  Then you'll
have to remake routines that depend on @code{cool.c}.  This way, you'll
maintain the convention in the GSL random number package that not
initializing a random number generator is equivalent to initializing
with a seed of 1.
