@cindex random
@cindex gaussian
@cindex uniform
@cindex poisson

The @value{GSL} provides a large collection of random number generators
which can be accessed through a uniform interface. Environment variables
allow you to select different generators and seeds at runtime, so that
you can easily switch between generators without needing to recompile
your program. Each instance of a generator keeps track of its own state,
allowing the generators to be used in multi-threaded programs.
Additional functions are available for transforming uniform random
numbers into samples from continuous or discrete probability
distributions such as the gaussian, log-normal or poisson distributions.

@menu
* General comments on random numbers::  
* Random number generator initialization::  
* Sampling from a random number generator::  
* Random number environment::   
* Saving and restoring random number generator state::  
* Available random number generator algorithms::  
* Random Number Distributions::  
* Random Number References and Further Reading::  
* Random Number Acknowledgements::  
@end menu

@node General comments on random numbers
@section General comments on random numbers

In 1988, Park and Miller wrote a paper entitled ``Random number
generators: good ones are hard to find.'' [Commun. ACM, 31, 1192--1201].
Fortunately, some excellent random number generators are available,
though poor ones are still in common use.  You may be happy with the
system-supplied random number generator on your computer, but you should
be aware that as computers get faster, requirements on random number
generators increase.  Nowadays, a simulation that calls a random number
generator millions of times can often finish before you can make it down
the hall to the coffee machine and back.

A very nice review of random number generators was written by Pierre
L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, Jerry Banks,
ed. (Wiley, 1997).  The chapter is available in postscript from from
L'Ecuyer's ftp site (see references).  Knuth's volume on Seminumerical
Algorithms (originally published in 1968) devotes 170 pages to random
number generators, and is only now starting to show its age.
Nonetheless, it is brilliant, a classic.  If you don't own it, you
should stop reading right now, run to the nearest bookstore, and buy it.

A good random number generator will satisfy both theoretical and
statistical properties.  Theoretical properties are often hard to obtain
(they require real math!), but one prefers a random number generator
with a long period, low serial correlation, and a tendency @emph{not} to
``fall mainly on the planes.''  Statistical tests are performed with
numerical simulations.  Generally, a random number generator is used to
estimate some quantity for which the theory of probability provides an
exact answer.  Comparison to this exact answer provides a measure of
"randomness".

@node Random number generator initialization
@section Random number generator initialization

It is important to remember that a random number generator is not a
"real" function like sine or cosine.  Unlike real functions, successive
calls to a random number generator yield different return values.  Of
course that is just what you want for a random number generator, but to
achieve this effect, the generator must keep track of some kind of
"state" variable.  Sometimes this state is just an integer (sometimes
just the value of the previously generated random number), but often it
is more complicated than that and may involve a whole array of numbers,
possibly with some indices thrown in.  To use the random number
generators, you do not need to know the details of what comprises the
state, and besides that varies from algorithm to algorithm.

The random number generator library uses two special structs,
@code{gsl_rng} and @code{gsl_rng_type}. The struct @code{gsl_rng_type}
holds generic information about an algorithm, or type of generator. The
struct @code{gsl_rng} contains an instance of a generator created from
the specifications in a given @code{gsl_rng_type}.

The random number functions described in this section are declared in
the header file @file{gsl_rng.h}.

@deftypefn Random {gsl_rng *} gsl_rng_alloc (gsl_rng_type * @var{T})
This function returns a pointer to a newly-created instance of a random
number generator of type @var{T}. The generator is automatically
initialized with the default seed. 

For example, the following code creates an instance of the Tausworthe
generator,

@example
gsl_rng * r = gsl_rng_alloc (gsl_rng_taus);
@end example

If there is insufficient memory to create the generator then the
function returns a null pointer and the error handler is invoked with an
error code of @code{GSL_ENOMEM}.

The defined generator types are currently,

@example
gsl_rng_bad_rand, gsl_rng_bad_randu, gsl_rng_cmrg, gsl_rng_minstd,
gsl_rng_mrg, gsl_rng_mt19937, gsl_rng_ran0, gsl_rng_ran1, gsl_rng_ran2,
gsl_rng_ran3, gsl_rng_rand, gsl_rng_ranlux, gsl_rng_ranlux389,
gsl_rng_r250, gsl_rng_taus, gsl_rng_tt800, gsl_rng_uni, gsl_rng_uni32,
gsl_rng_vax, gsl_rng_zuf
@end example
@end deftypefn

@deftypefn Random void gsl_rng_set (const gsl_rng * @var{r}, unsigned long int @var{s})
@code{gsl_rng_set} initializes (or `seeds') the random number generator.
If the random number generator is seeded with the same value of @var{s}
on two different runs, the same stream of random numbers will be
generated (by successive calls to the routines below). If different
values of @code{s} are supplied, then the generated streams of random
numbers should be completely different. If the seed @var{s} is zero then
the generator is initialized to its ``conventional'' state, whatever
that might be. For example, the Fortran source code for the original
@code{ranlux} generator used a seed of 314159265, and so choosing
@var{s} equal to zero reproduces this.
@end deftypefn

@deftypefn Random void gsl_rng_free (gsl_rng * @var{r})
This function frees all the memory associated with the generator
@var{r}.
@end deftypefn

@node  Sampling from a random number generator
@section Sampling from a random number generator

@deftypefn Random {unsigned long int} gsl_rng_get (const gsl_rng * @var{r})
This function returns a random integer from the generator @var{r} and
advances its state.  All integers in the range of the generator should
be equally likely.  The maximum and minimum values depends on the
algorithm used for random number generation.
@end deftypefn

@deftypefn Random double gsl_rng_uniform (const gsl_rng * @var{r})
This function returns a double precision floating point number uniformly
distributed between zero and one. The value is obtained by dividing the
result of @code{gsl_rng_get(r)} by @code{gsl_rng_max(r)}.
@end deftypefn

@deftypefn Random double gsl_rng_uniform_pos (const gsl_rng * @var{r})
This function returns a positive double precision floating point number
uniformly distributed in the range (0,1] (i.e. excluding zero). The
number is obtained by sampling the generator until it returns a non-zero
value. This value is then divided by @code{gsl_rng_max(r)}. 
@end deftypefn

The following functions provide information about the generator.

@deftypefn Random {const char *} gsl_rng_name (const gsl_rng * @var{r})
This function returns a pointer to the name of the generator.
For example,
@example
printf("r is a '%s' generator\n", gsl_rng_name (r)) ;
@end example
@noindent
would print something like @code{r is a 'taus' generator}
@end deftypefn

@deftypefn Random {unsigned long int} gsl_rng_max (const gsl_rng * @var{r})
@code{gsl_rng_max} returns the maximum value that @code{gsl_rng_get}
can return.
@end deftypefn

@deftypefn Random {unsigned long int} gsl_rng_min (const gsl_rng * @var{r})
@code{gsl_rng_max} returns the minimum value that @code{gsl_rng_get}
can return. Usually this value is zero. There are some generators with
algorithms that cannot return zero, and for these generators the minimum
value is 1.
@end deftypefn


@node Random number environment
@section Random number environment

There are two variables which control the 

const gsl_rng_type * gsl_rng_env_setup (void);
extern const gsl_rng_type *gsl_rng_default;
extern unsigned long int gsl_rng_default_seed;

You can set the default generator and default seed using the environment
variables @code{GSL_RNG_TYPE} and @code{GSL_RNG_SEED} and the function 
@code{gsl_rng_env_setup}.

@node Saving and restoring random number generator state
@section Saving and restoring random number generator state

The above methods blithely ignore the random number `state' which
changes from call to call.  But it is often practical to be able to
"save" and "restore" the state.  To permit these practices, a few
somewhat more advanced functions are supplied.  These include:

@deftypefn Random {gsl_rng *} gsl_rng_cpy (gsl_rng * @var{dest}, const gsl_rng * @var{src})
This function copies the random number generator @var{src} into the
pre-exisiting generator @var{dest}, making @var{dest} into an exact copy
of @var{src}. It returns @var{dest} if successful and a null pointer if
sufficient memory could not be allocated.
@end deftypefn

@deftypefn Random {gsl_rng *} gsl_rng_clone (const gsl_rng * @var{r})
This function returns a pointer to a newly created generator which is an
exact copy of the generator @var{r}.
@end deftypefn

@deftypefn Random void gsl_rng_print_state (const gsl_rng * @var{r})
This function prints a hex-dump of the state of the generator @var{r} to
stdout. At the moment its only use is for debugging.
@end deftypefn

@node Available random number generator algorithms
@section Available random number generator algorithms

The above functions make no reference to the actual algorithm used.
This is deliberate so that you can switch algorithms without having to
change any of your application source code.

Among the algorithms available are: 
@deftypefn {Generator} mrg       Multiple recursive
@end deftypefn

@deftypefn {Generator} cmrg      Combined MRG
@end deftypefn

taus      Combined Tausworthe

uni       Fibonacci subtraction
uni32     32 bit version of uni

zuf       Another Fibonacci subtraction method, but with a much longer lag than uni.

rand      Linear congruential 

ran0 Numerical recipes ran0
ran1 Numerical recipes ran1
ran2 Numerical recipes ran2
ran3 Numerical recipes ran3

ranlux  Luschers luxury random number algorithm

minstd Park and Miller's minimal standard generator
mt19937
r250
tt800
vax

@node Random Number Distributions
@section Random Number Distributions

Given 

@deftypefn Random double gsl_ran_gaussian (const gsl_rng * @var{r})
@code{gsl_ran_gaussian} returns a gaussian random number, with mean zero and
variance one.
@end deftypefn

@deftypefn Random int gsl_ran_poisson (const gsl_rng * @var{r}, double @var{mu})
@code{gsl_ran_poisson} returns a poisson--distributed random number,
with mean @var{mu}.
@end deftypefn

@deftypefn Random void gsl_ran_poisson_array (const gsl_rng * @var{r}, double @var{mu}, int @var{N}, int *@var{p})
@code{gsl_ran_poisson_array} places an array of @var{N}
poisson--distributed random numbers with mean @var{mu} into the array
@var{p}.
@end deftypefn

@deftypefn Random double gsl_ran_exponential (const gsl_rng * @var{r}, double @var{mu})
@code{gsl_ran_exponential} returns a exponential--distributed random
number, with mean @var{mu}.  This is calculated with @math{-mu*log(x)}.
@end deftypefn

@deftypefn Random int gsl_ran_gamma (const gsl_rng * @var{r}, double @var{a})
@code{gsl_ran_gamma} returns a gamma-distributed random number.  The
distribution function is
@equation
F(x) = @{ @{1@} \over @{ \Gamma(a)@} \int_0^x t^@{a-1@} e^@{-t@} dt @}
@end equation
@end deftypefn

@deftypefn Random {int *} gsl_ran_shuffle (int N, int *x)
@code{gsl_ran_shuffle} takes an array of N integers x[0..N-1] and 
randomly shuffles their order.  @code{x} is altered and is returned.
if @code{x} is supplied as NULL, then memory is allocated for
@code{x[]}, and it is filled with a random permutation of the 
numbers 0,...,N-1.  
@end deftypefn

@deftypefn Random {int *} gsl_ran_choose (int K, int N, int *x)
@code{gsl_ran_choose} fills the array @code{x[K]} with @code{K}
integers taken randomly from 0,...,N-1.  It is required that 
@code{K} be less than or equal to @code{N}. The numbers will be
in numerical order.  You will need to call @code{gsl_ran_shuffle(K,x)}
if you want them in random order.
@end deftypefn


@node Random Number References and Further Reading
@section Random Number References and Further Reading
@noindent

@url{ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/handsim.ps}.

@itemize @asis
@item
Donald E. Knuth, @cite{The Art of Computer Programming: Seminumerical
Algorithms} (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.
@end itemize
@noindent


See the pLab home page (http://random.mat.sbg.ac.at/) for a lot of information
on the state-of-the-art in random number generation, and for numerous links
to various "random" WWW sites.  

@node Random Number Acknowledgements
@section Random Number Acknowledgements
Thanks to Makoto Matsumoto and Takuji Nishimura for making the source
code to their MT19937 generator available under the GNU Library General
Public License.

@c lcg
@c [ LCG(n) := n * 69069 mod (2^32) ]
@c First 6: [69069, 475559465, 2801775573, 1790562961, 3104832285, 4238970681]
@c %2^31-1   69069, 475559465, 654291926, 1790562961, 957348638, 2091487034
@c mrg
@c [q([x1, x2, x3, x4, x5]) := [107374182 mod 2147483647 * x1 + 104480 mod 2147483647 * x5, x1, x2, x3, x4]]
@c
@c cmrg
@c [q1([x1,x2,x3]) := [63308 mod 2147483647 * x2 -183326 mod 2147483647 * x3, x1, x2],
@c  q2([x1,x2,x3]) := [86098 mod 2145483479 * x1 -539608 mod 2145483479 * x3, x1, x2] ]
@c  intial for q1 is [69069, 475559465, 654291926]
@c  intial for q2 is  [1790562961, 959348806, 2093487202]

@c tausworthe
@c    [ b1(x) := rsh(xor(lsh(x, 13), x), 19),
@c      q1(x) := xor(lsh(and(x, 4294967294), 12), b1(x)),
@c      b2(x) := rsh(xor(lsh(x, 2), x), 25),
@c      q2(x) := xor(lsh(and(x, 4294967288), 4), b2(x)),
@c      b3(x) := rsh(xor(lsh(x, 3), x), 11),
@c      q3(x) := xor(lsh(and(x, 4294967280), 17), b3(x)) ]
@c      [s1, s2, s3] = [600098857, 1131373026, 1223067536] 
@c [2948905028, 441213979, 394017882]
