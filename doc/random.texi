@cindex random number generators

The @value{GSL} provides a large collection of random number generators
which can be accessed through a uniform interface. Environment variables
allow you to select different generators and seeds at runtime, so that
you can easily switch between generators without needing to recompile
your program. Each instance of a generator keeps track of its own state,
allowing the generators to be used in multi-threaded programs.
Additional functions are available for transforming uniform random
numbers into samples from continuous or discrete probability
distributions such as the gaussian, log-normal or poisson distributions.

@menu
* General comments on random numbers::  
* Random number generator initialization::  
* Sampling from a random number generator::  
* Auxiliary random number generator functions::  
* Random number environment::   
* Saving and restoring random number generator state::  
* Available random number generator algorithms::  
* Random Number Distributions::  
* Random Number References and Further Reading::  
* Random Number Acknowledgements::  
@end menu

@node General comments on random numbers
@section General comments on random numbers

In 1988, Park and Miller wrote a paper entitled ``Random number
generators: good ones are hard to find.'' [Commun. ACM, 31, 1192--1201].
Fortunately, some excellent random number generators are available,
though poor ones are still in common use.  You may be happy with the
system-supplied random number generator on your computer, but you should
be aware that as computers get faster, requirements on random number
generators increase.  Nowadays, a simulation that calls a random number
generator millions of times can often finish before you can make it down
the hall to the coffee machine and back.

A very nice review of random number generators was written by Pierre
L'Ecuyer, as Chapter 4 of the book: Handbook on Simulation, Jerry Banks,
ed. (Wiley, 1997).  The chapter is available in postscript from from
L'Ecuyer's ftp site (see references).  Knuth's volume on Seminumerical
Algorithms (originally published in 1968) devotes 170 pages to random
number generators, and is only now starting to show its age.
Nonetheless, it is brilliant, a classic.  If you don't own it, you
should stop reading right now, run to the nearest bookstore, and buy it.

A good random number generator will satisfy both theoretical and
statistical properties.  Theoretical properties are often hard to obtain
(they require real math!), but one prefers a random number generator
with a long period, low serial correlation, and a tendency @emph{not} to
``fall mainly on the planes.''  Statistical tests are performed with
numerical simulations.  Generally, a random number generator is used to
estimate some quantity for which the theory of probability provides an
exact answer.  Comparison to this exact answer provides a measure of
"randomness".

@node Random number generator initialization
@section Random number generator initialization

It is important to remember that a random number generator is not a
"real" function like sine or cosine.  Unlike real functions, successive
calls to a random number generator yield different return values.  Of
course that is just what you want for a random number generator, but to
achieve this effect, the generator must keep track of some kind of
"state" variable.  Sometimes this state is just an integer (sometimes
just the value of the previously generated random number), but often it
is more complicated than that and may involve a whole array of numbers,
possibly with some indices thrown in.  To use the random number
generators, you do not need to know the details of what comprises the
state, and besides that varies from algorithm to algorithm.

The random number generator library uses two special structs,
@code{gsl_rng} and @code{gsl_rng_type}. The struct @code{gsl_rng_type}
holds generic information about an algorithm, or type of generator. The
struct @code{gsl_rng} contains an instance of a generator created from
the specifications in a given @code{gsl_rng_type}.

The random number functions described in this section are declared in
the header file @file{gsl_rng.h}.

@deftypefn Random {gsl_rng *} gsl_rng_alloc (gsl_rng_type * @var{T})
This function returns a pointer to a newly-created instance of a random
number generator of type @var{T}. The generator is automatically
initialized with the default seed. 

For example, the following code creates an instance of the Tausworthe
generator,

@example
gsl_rng * r = gsl_rng_alloc (gsl_rng_taus);
@end example

If there is insufficient memory to create the generator then the
function returns a null pointer and the error handler is invoked with an
error code of @code{GSL_ENOMEM}.

The defined generator types are,

@example
gsl_rng_bsdrand, gsl_rng_cmrg, gsl_rng_minstd,
gsl_rng_mrg, gsl_rng_mt19937, gsl_rng_ran0, gsl_rng_ran1,
gsl_rng_ran2, gsl_rng_ran3, gsl_rng_rand, gsl_rng_randu,
gsl_rng_ranlux, gsl_rng_ranlux389, gsl_rng_r250,
gsl_rng_taus, gsl_rng_tt800, gsl_rng_uni, gsl_rng_uni32,
gsl_rng_vax, gsl_rng_zuf
@end example
@end deftypefn

@deftypefn Random void gsl_rng_set (const gsl_rng * @var{r}, unsigned long int @var{s})
@code{gsl_rng_set} initializes (or `seeds') the random number
generator.  If the random number generator is seeded with the same
value of @var{s} on two different runs, the same stream of random
numbers will be generated (by successive calls to the routines
below). If different values of @var{s} are supplied, then the
generated streams of random numbers should be completely different. If
the seed @var{s} is zero then the generator is initialized to its
``conventional'' state, whatever that might be. For example, the
Fortran source code for the original @code{ranlux} generator used a
seed of 314159265, and so choosing @var{s} equal to zero reproduces
this.
@end deftypefn

@deftypefn Random void gsl_rng_free (gsl_rng * @var{r})
This function frees all the memory associated with the generator
@var{r}.
@end deftypefn

@node  Sampling from a random number generator
@section Sampling from a random number generator

@deftypefn Random {unsigned long int} gsl_rng_get (const gsl_rng * @var{r})
This function returns a random integer from the generator @var{r} and
advances its state.  All integers in the range of the generator should
be equally likely.  The maximum and minimum values depends on the
algorithm used for random number generation.
@end deftypefn

@deftypefn Random double gsl_rng_uniform (const gsl_rng * @var{r})
This function returns a double precision floating point number uniformly
distributed between zero and one. The value is obtained by dividing the
result of @code{gsl_rng_get(r)} by @code{gsl_rng_max(r)}.
@end deftypefn

@deftypefn Random double gsl_rng_uniform_pos (const gsl_rng * @var{r})
This function returns a positive double precision floating point number
uniformly distributed in the range (0,1] (i.e. excluding zero). The
number is obtained by sampling the generator until it returns a non-zero
value. This value is then divided by @code{gsl_rng_max(r)}. 
@end deftypefn

@deftypefn Random double gsl_rng_uniform_gt0_lt1 (const gsl_rng * @var{r})
This function returns a uniformly distributed double
precision floating point number which is greater than zero
and less than one. The number is obtained by repeatedly
sampling the generator with the algorithm of
@code{gsl_rng_uniform} until a value between zero and one
is obtained.
@end deftypefn

@node Auxiliary random number generator functions
@section Auxiliary random number generator functions
The following functions provide information about the generator.

@deftypefn Random {const char *} gsl_rng_name (const gsl_rng * @var{r})
This function returns a pointer to the name of the generator.
For example,
@example
printf("r is a '%s' generator\n", gsl_rng_name (r)) ;
@end example
@noindent
would print something like @code{r is a 'taus' generator}
@end deftypefn

@deftypefn Random {unsigned long int} gsl_rng_max (const gsl_rng * @var{r})
@code{gsl_rng_max} returns the maximum value that @code{gsl_rng_get}
can return.
@end deftypefn

@deftypefn Random {unsigned long int} gsl_rng_min (const gsl_rng * @var{r})
@code{gsl_rng_max} returns the minimum value that @code{gsl_rng_get}
can return. Usually this value is zero. There are some generators with
algorithms that cannot return zero, and for these generators the minimum
value is 1.
@end deftypefn

@node Random number environment
@section Random number environment

There are two variables which control the 

const gsl_rng_type * gsl_rng_env_setup (void);
extern const gsl_rng_type *gsl_rng_default;
extern unsigned long int gsl_rng_default_seed;

You can set the default generator and default seed using the environment
variables @code{GSL_RNG_TYPE} and @code{GSL_RNG_SEED} and the function 
@code{gsl_rng_env_setup}.

@node Saving and restoring random number generator state
@section Saving and restoring random number generator state

The above methods ignore the random number `state' which changes from
call to call.  It is often useful to be able to "save" and "restore" the
state.  To permit these practices, a few somewhat more advanced
functions are supplied.  These include:

@deftypefn Random {gsl_rng *} gsl_rng_cpy (gsl_rng * @var{dest}, const gsl_rng * @var{src})
This function copies the random number generator @var{src} into the
pre-exisiting generator @var{dest}, making @var{dest} into an exact copy
of @var{src}. It returns @var{dest} if successful and a null pointer if
sufficient memory could not be allocated.
@end deftypefn

@deftypefn Random {gsl_rng *} gsl_rng_clone (const gsl_rng * @var{r})
This function returns a pointer to a newly created generator which is an
exact copy of the generator @var{r}.
@end deftypefn

@deftypefn Random void gsl_rng_print_state (const gsl_rng * @var{r})
This function prints a hex-dump of the state of the generator @var{r} to
stdout. At the moment its only use is for debugging.
@end deftypefn

@node Available random number generator algorithms
@section Available random number generator algorithms

The above functions make no reference to the actual algorithm used.
This is deliberate so that you can switch algorithms without having to
change any of your application source code. The library provides a
large number of generators of different types, including simulation
quality generators, generators provided for compatibility with other
libraries and historically famous (or infamous) generators known to
produce poor quality random numbers.

@subsection Simulation quality generators

The following generators are recommended for use in simulation. They
have extremely long periods and pass most statistical tests.

@deffn {Generator} gsl_rng_mt19937
@cindex MT19937 random number generator
The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is based
on a variant of the twisted generalized feedback shift-register
generator, with a Mersenne prime period of @math{2^@{19937@} - 1} (about
@math{10^@{6000@}}).  It is equi-distributed in 623 dimensions and has
passed the @sc{diehard} statistical tests. It uses 631 words of storage
state per generator and is comparable in speed to the other generators.

For more information see,
@itemize @asis
@item
Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A
623-dimensionally equidistributerd uniform pseudorandom number
generator". @cite{ACM Transactions on Modeling and Computer
Simulation}, Vol. 8, No. 1 (Jan. 1998), Pages 3-30
@end itemize
@end deffn

@deffn {Generator} gsl_rng_ranlux
@deffnx {Generator} gsl_rng_ranlux389
@cindex RANLUX random number generator
The @code{ranlux} generator uses the lagged-fibonacci "luxury random
number" algorithm of Luscher. It is a 24-bit generator, originally
designed for IEEE floating point numbers. The period of the generator
is about @math{10^@{171@}}. The generator is slow, but has the
advantage that the algorithm has been mathematically proven to provide
decorrelated numbers at a known level. The generator
@code{gsl_rng_ranlux} is the default level of decorrelation
recommended by Luscher and @code{gsl_rng_ranlux389} provides the
highest level of randomness, with all bits decorrelated. Both types of
generator use 35 words of storage per generator.

For more information see,
@itemize @asis
@item
M. Luscher, "A portable high-quality random number generator for
lattice field theory calculations", @cite{Computer Physics
Communications}, 79 (1994) 100-110.
@item
F. James, "RANLUX: A Fortran implementation of the high-quality
pseudo-random number generator of Luscher", @cite{Computer Physics
Communications}, 79 (1994) 111-114
@end itemize
@end deffn

@deffn {Generator} gsl_rng_cmrg
@cindex CMRG, combined multiple recursive random number generator
This is a combined multiple recursive generator by L'Ecuyer. 
Its sequence is,
@c
@c THIS IS HORRIBLE!
@macro mod 
@iftex
\hbox@{ mod @}
@end iftex
@ifnottex
mod @end ifnottex
@end macro
@c
@macro and
@iftex
\&
@end iftex
@ifnottex
& @end ifnottex
@end macro
@c
@equation
z_n = (x_n - y_n) @mod m_1
@end equation
@noindent
where the two underlying generators @math{x_n} and @math{y_n} are,
@c
@equation
x_n = (a_1 x_@{n-1@} + a_2 x_@{n-2@} + a_3 x_@{n-3@}) @mod m_1
@end equation
and
@equation
y_n = (b_1 y_@{n-1@} + b_2 y_@{n-2@} + b_3 y_@{n-3@}) @mod m_2
@end equation
@noindent
with coefficients @math{a_1 = 0}, @math{a_2 = 63308}, @math{a_3 =
-183326}, @math{b_1 = 86098}, @math{b_2 = 0}, @math{b_3 = -539608},
and moduli @math{m_1 = 2^@{31@} - 1 = 2147483647} and @math{m_2 =
2145483479}.

The period of this generator is about @math{2^@{205@}}. It uses 
13 words of storage per generator. For more information see,

@itemize @asis
@item
P. L'Ecuyer, "Combined Multiple Recursive Random Number
Generators," @cite{Operations Research}, 44, 5 (1996), 816--822.
@end itemize
@end deffn

@deffn {Generator} gsl_rng_mrg
@cindex MRG, multiple recursive random number generator
This is a fifth-order multiple recursive generator by L'Ecuyer, Blouin
and Coutre.  Its sequence is,
@c
@equation
   x_n = (a_1 x_@{n-1@} + a_5 x_@{n-5@}) @mod m
@end equation
@noindent
with @math{a_1 = 107374182}, @math{a_2 = a_3 = a_4 = 0}, @math{a_5 = 104480}
and @math{m = 2^@{31@}-1}.

The period of this generator is about @math{10^@{46@}}. It uses 13 words
of storage per generator. More information can be found in the following
paper,
@itemize @asis
@item
P. L'Ecuyer, F. Blouin, and R. Coutre, "A search for good multiple
recursive random number generators", @cite{ACM Transactions on Modeling and
Computer Simulation} 3, 87-98 (1993).
@end itemize
@end deffn

@deffn {Generator} gsl_rng_taus
@cindex Tausworthe random number generator
This is a maximally equidistributed combined Tausworthe generator by
L'Ecuyer. The sequence is,
@c
@equation
x_n = (s^1_n \oplus s^2_n \oplus s^3_n) 
@end equation
@noindent
where,
@c
@equation
s^1_@{n+1@} = (((s^1_n @and 4294967294) <<12) \oplus (((s^1_n <<13) \oplus s^1_n) >>19))
@end equation
@equation
s^2_@{n+1@} = (((s^2_n @and 4294967288) << 4) \oplus (((s^2_n << 2) \oplus s^2_n) >>25))
@end equation
@equation
s^3_@{n+1@} = (((s^3_n @and 4294967280) <<17) \oplus (((s^3_n << 3) \oplus s^3_n) >>11))
@end equation
@noindent
computed modulo @math{2^@{32@}}. In the formulas above @math{\oplus}
denotes ``exclusive-or''. Note that the algorithm relies on the properties
of 32-bit unsigned integers and has been implemented using a bitmask
of @code{0xFFFFFFFF} to make it work on 64 bit machines.

The period of this generator is about @math{2^@{88@}}. It uses 10 words
of storage per generator. For more information see,

@itemize @asis
@item
P. L'Ecuyer, "Maximally Equidistributed Combined Tausworthe
Generators", @cite{Mathematics of Computation}, 65, 213 (1996), 203--213.
@end itemize
@end deffn

@deffn {Generator} gsl_rng_tt800
@cindex TT800 random number generator
This is an earlier version of the twisted generalized feedback
shift-register generator, and has been superseded by the development of
MT19937. However, it is still an acceptable generator in its own
right. It has a period of @math{2^@{800@}} and uses 33 words of storage
per generator.

For more information see,
@itemize @asis
@item
From: Makoto Matsumoto and Yoshiharu Kurita, "Twisted GFSR Generators
II", @cite{ACM Transactions on Modelling and Computer Simulation},
Vol. 4, No. 3, 1994, pages 254-266.
@end itemize
@end deffn

@deffn {Generator} gsl_rng_r250
@cindex shift-register random number generator
@cindex R250 shift-register random number generator
This is the shift-register generator of Kirkpatrick and Stoll. The
sequence is
@c
@equation
x_n = x_@{n-103@} \oplus x_@{n-250@}
@end equation
@noindent
where @math{\oplus} denote ``exclusive-or'', defined on 32-bit
words. The period of this generator is about @math{2^@{250@}} and it
uses 258 words of storage per generator.

For more information see,
@itemize @asis
@item
S. Kirkpatrick and E. Stoll, "A very fast shift-register sequence random
number generator", @cite{Journal of Computational Physics}, 40, 517-526
(1981)
@end itemize
@end deffn


@subsection Generators provided for compatibility
@cindex Random number generators, Numerical recipes
@cindex Numerical recipes, random number generators
The following generators are provided for compatibility with
@cite{Numerical Recipes}. Although we have implemented the same
algorithms for the underlying integer generators there will be minor
discrepancies between the floating point values obtained from
@code{gsl_rng_uniform} and the corresponding routine from Numerical
Recipes. First, the original routines used single precision while we
use double precision. Second, some of the original routines have an
additional check to exclude 1.0 from the range of allowed return
values by substituting 0.99999988 in its place. We have not
implemented this feature so occasionally 1.0 will be returned when the
Numerical Recipes code would have returned 0.99999988.

@deffn {Generator} ran0 
Numerical recipes @code{ran0} implements Park and Miller's @sc{minstd}
algorithm.
@end deffn

@deffn {Generator} ran1 
Numerical recipes @code{ran1}
@end deffn

@deffn {Generator} ran2 
Numerical recipes @code{ran2}
@end deffn

@deffn {Generator} ran3 
Numerical recipes @code{ran3}
@end deffn

@subsection Historical generators

The following generators are included only for historical reasons, so
that you can reproduce results from old programs which might have used
them. These generators should not be used for real simulations since
they have poor statistical properties by modern standards.

@deffn {Generator} gsl_rng_vax
@cindex VAX random number generator
This is the old VAX generator @code{MTH$RANDOM}. Its sequence is,
@c
@equation
x_@{n+1@} = (a x_n + c) @mod m
@end equation
@noindent
with @math{a = 69069}, @math{c = 1} and @math{m = 2^@{32@}}. The seed
specifies the initial value, @math{x_1}. The period of this generator is
@math{2^@{32@}} and it uses 1 word of storage per generator.
@end deffn

@deffn {Generator} gsl_rng_bsdrand
@cindex BSD random number generator
This is the old BSD @code{rand()} generator. Its sequence is
@c
@equation
x_@{n+1@} = (a x_n + c) @mod m
@end equation
@noindent
with @math{a = 1103515245}, @math{c = 12345} and @math{m =
2^@{31@}}. The seed specifies the initial value, @math{x_1}.  The period
of this generator is 2^31, and it uses 1 word of storage per generator.
One of the problems with @code{rand()} was that the the low bits of
successive  numbers were correlated.
@end deffn

@deffn {Generator} gsl_rng_randu
@cindex RANDU random number generator
This is the infamous IBM @code{RANDU} generator. Its sequence is
@c
@equation
x_@{n+1@} = (a x_n) @mod m
@end equation
@noindent
with @math{a = 65539} and @math{m = 2^@{31@}}. The seed specifies the
initial value, @math{x_1}. The period of this generator is only 2^29.
Knuth described this generator as @emph{really horrible}.
@end deffn


uni       Fibonacci subtraction
uni32     32 bit version of uni
rand      Linear congruential 
zuf
minstd
minstd Park and Miller's minimal standard generator


@smallexample
    randu ------------------------------------------------
  bsdrand ---------------------------------------------
      vax ------------------------------------------
     r250 ---------------------------------------
     taus ----------------------------------
      uni ----------------------------------
    uni32 ---------------------------------
    tt800 -------------------------------
     rand ---------------------------
      zuf ---------------------------
  mt19937 -----------------------
   minstd ----------------------
      mrg ---------------
     cmrg --------
   ranlux -----
ranlux389 ---

          |------------------|--------------------|--------
          0                  1                    2        

          Millions of random numbers per second
@end smallexample

@node Random Number Distributions
@section Random Number Distributions
@cindex random number distributions

Distributions of random numbers can be obtained from any of the
generators using the following transformation functions. In the simplest
cases a non-uniform distribution can be obtained analytically from the
uniform distribution. This uses one call to the random number
generator. More complicated distributions are created by the
@dfn{acceptance-rejection} method which often requires multiple samples
from the generator.

@deftypefn Random double gsl_ran_gaussian (const gsl_rng * @var{r})
@cindex Gaussian random numbers
@code{gsl_ran_gaussian} returns a gaussian random number, with mean zero
and variance one. The probability distribution for gaussian random
numbers is,
@c
@equation
p(x) dx = @{1 \over \sqrt@{2 \pi@}@} \exp (-x^2/2) dx
@end equation
@noindent
for @math{x} in the range @math{-\infty} to @math{+\infty}.
@end deftypefn

@deftypefn Random int gsl_ran_poisson (const gsl_rng * @var{r}, double @var{mu})
@cindex Poisson random numbers
@code{gsl_ran_poisson} returns a poisson--distributed random integer,
with mean @var{mu}. The probability distribution for poisson random
numbers is,
@c
@equation
p(n) = @{\mu^n \over n!@} \exp(-\mu)
@end equation
@noindent
for @math{n \ge 0}.
@end deftypefn

@deftypefn Random void gsl_ran_poisson_array (const gsl_rng * @var{r}, double @var{mu}, int @var{N}, int *@var{p})
@code{gsl_ran_poisson_array} places an array of @var{N}
poisson--distributed random numbers with mean @var{mu} into the array
@var{p}.
@end deftypefn

@deftypefn Random double gsl_ran_exponential (const gsl_rng * @var{r}, double @var{mu})
@cindex Exponential random numbers
@code{gsl_ran_exponential} returns a exponential--distributed random
number, with mean @var{mu}.  
@c
@equation
p(x) dx = @{1 \over \mu@} \exp(-x/\mu) dx
@end equation
@noindent
for @math{x \ge 0}.

This is calculated with @math{-mu*log(x)}.
@end deftypefn

@deftypefn Random int gsl_ran_gamma (const gsl_rng * @var{r}, double @var{a})
@cindex Gamma distribution random numbers
@code{gsl_ran_gamma} returns a gamma-distributed random number.  The
distribution function is
@c
@equation
F(x) = @{ @{1@} \over @{ \Gamma(a)@} \int_0^x t^@{a-1@} e^@{-t@} dt @}
@end equation
@end deftypefn

@deftypefn Random {int *} gsl_ran_shuffle (int N, int *x)
@code{gsl_ran_shuffle} takes an array of N integers x[0..N-1] and 
randomly shuffles their order.  @code{x} is altered and is returned.
if @code{x} is supplied as NULL, then memory is allocated for
@code{x[]}, and it is filled with a random permutation of the 
numbers 0,...,N-1.  
@end deftypefn

@deftypefn Random {int *} gsl_ran_choose (int K, int N, int *x)
@code{gsl_ran_choose} fills the array @code{x[K]} with @code{K}
integers taken randomly from 0,...,N-1.  It is required that 
@code{K} be less than or equal to @code{N}. The numbers will be
in numerical order.  You will need to call @code{gsl_ran_shuffle(K,x)}
if you want them in random order.
@end deftypefn

@node Random Number References and Further Reading
@section Random Number References and Further Reading
@noindent

@url{ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/handsim.ps}.

@itemize @asis
@item
Donald E. Knuth, @cite{The Art of Computer Programming: Seminumerical
Algorithms} (Vol 2, 3rd Ed, 1997), Addison-Wesley, ISBN 0201896842.
@end itemize
@noindent


See the pLab home page (http://random.mat.sbg.ac.at/) for a lot of information
on the state-of-the-art in random number generation, and for numerous links
to various "random" WWW sites.  

For physicists the Particle Data Group provides a useful short review of
techniques for generating distributions of random numbers in the
"Monte Carlo" section of its Annual Review of Particle Physics.

@itemize @asis
@item
@cite{Review of Particle Properties}
R.M. Barnett et al., Physical Review D54, 1 (1996)
@end itemize
@noindent
The Review of Particle Physics is available online in postscript and pdf
format at @url{http://pdg.lbl.gov/}.


@node Random Number Acknowledgements
@section Random Number Acknowledgements
@noindent
Thanks to Makoto Matsumoto and Takuji Nishimura for making the source
code to their MT19937 generator available under the GNU Library General
Public License.

@c lcg
@c [ LCG(n) := n * 69069 mod (2^32) ]
@c First 6: [69069, 475559465, 2801775573, 1790562961, 3104832285, 4238970681]
@c %2^31-1   69069, 475559465, 654291926, 1790562961, 957348638, 2091487034
@c mrg
@c [q([x1, x2, x3, x4, x5]) := [107374182 mod 2147483647 * x1 + 104480 mod 2147483647 * x5, x1, x2, x3, x4]]
@c
@c cmrg
@c [q1([x1,x2,x3]) := [63308 mod 2147483647 * x2 -183326 mod 2147483647 * x3, x1, x2],
@c  q2([x1,x2,x3]) := [86098 mod 2145483479 * x1 -539608 mod 2145483479 * x3, x1, x2] ]
@c  intial for q1 is [69069, 475559465, 654291926]
@c  intial for q2 is  [1790562961, 959348806, 2093487202]

@c tausworthe
@c    [ b1(x) := rsh(xor(lsh(x, 13), x), 19),
@c      q1(x) := xor(lsh(and(x, 4294967294), 12), b1(x)),
@c      b2(x) := rsh(xor(lsh(x, 2), x), 25),
@c      q2(x) := xor(lsh(and(x, 4294967288), 4), b2(x)),
@c      b3(x) := rsh(xor(lsh(x, 3), x), 11),
@c      q3(x) := xor(lsh(and(x, 4294967280), 17), b3(x)) ]
@c      [s1, s2, s3] = [600098857, 1131373026, 1223067536] 
@c [2948905028, 441213979, 394017882]
