@comment
@node Special Function Usage
@section Special Function Usage

The special functions are available in two calling conventions, a
@dfn{natural form} which returns the numerical value of the function and
an @dfn{error-handling form} which returns an error code.  The two types
of function provide alternative ways of accessing the same underlying
code.

The @dfn{natural form} returns only the value of the function and can be
used directly in mathematical expressions..  For example, the following
function call will compute the value of the Bessel function
@math{J_0(x)},

@example
double y = gsl_sf_bessel_J0 (x);
@end example
@noindent
There is no way to access an error code or to estimate the error using
this method.  To allow access to this information the alternative
error-handling form stores the value and error in a modifiable argument,

@example
gsl_sf_result result;
int status = gsl_sf_bessel_J0_e (x, &result);
@end example
@noindent
The error-handling functions have the suffix @code{_e}. The returned
status value indicates error conditions such as overflow, underflow or
loss of precision.  If there are no errors the error-handling functions
return @code{GSL_SUCCESS}.

@node The gsl_sf_result struct
@section The gsl_sf_result struct
@cindex gsl_sf_result
@cindex gsl_sf_result_e10

The error handling form of the special functions always calculate an
error estimate along with the value of the result.  Therefore,
structures are provided for amalgating a value and error estimate.

The @code{gsl_sf_result} struct contains value and error fields.

@example
typedef struct
@{
  double val;
  double err;
@} gsl_sf_result;
@end example
@noindent
The field @var{val} contains the value and the field @var{err} contains
an estimate of the absolute error in the value.

In some cases, an overflow or underflow can be detected and handled by a
function.  In this case, it may be possible to return a scaling exponent
as well as an error/value pair in order to save the result from
exceeding the dynamic range of the built-in types.  The
@code{gsl_sf_result_e10} struct contains value and error fields as well
as an exponent field such that the actual result is obtained as
@code{result * 10^(e10)}.

@example
typedef struct
@{
  double val;
  double err;
  int    e10;
@} gsl_sf_result_e10;
@end example

@node Special Function Modes
@section Special Function Modes

The goal of the library is to acheive double precision accuracy wherever
possible.  However the cost of evaluating some special functions to
double precision can be significant, particularly where very high order
terms are required.  In these cases a @code{mode} argument allows the
accuracy of the function to be reduced in order to improve performance.
The following precision levels are available for the mode argument,

@table @code
@item GSL_PREC_DOUBLE
Double-precision, a relative accuracy of approximately 2.0e-16
@item GSL_PREC_SINGLE
Single-precision, a relative accuracy of approximately 1.0e-07
@item GSL_PREC_APPROX
Approximate values, a relative accuracy of approximately 5.0e-04
@end table
@noindent
The approximate mode provides the fastest evaluation at the lowest
accuracy.
