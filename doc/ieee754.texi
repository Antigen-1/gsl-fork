To be written

@c to turn on math exception handling use __setfpucw, see
@c /usr/include/i386/fpu_control.h

@c e.g.

@c #include <math.h>
@c #include <stdio.h>
@c #include <fpu_control.h>

@c double f (double x) ;

@c int main ()
@c {
@c   double a = 0 ;
@c   double y, z ;

@c   __setfpucw(0x1372); 


@deftypefun void gsl_ieee_printf_float (const float * @var{x})
@deftypefunx void gsl_ieee_printf_double (const double * @var{x})
@end deftypefun

@example
#include <stdio.h>
#include <gsl_ieee_utils.h>

main () 
@{
  float f = 1.0/3.0 ;
  double d = 1.0/3.0 ;

  double fd = f ; /* promote from float to double */
  
  printf("     float 1/3 = ") ; gsl_ieee_printf_float(&f) ; printf("\n") ;
  printf("promoted float = ") ; gsl_ieee_printf_double(&fd) ; printf("\n") ;
  printf("    double 1/3 = ") ; gsl_ieee_printf_double(&d) ; printf("\n") ;
@}
@end example


@example
     float 1/3 =  1.01010101010101010101011*2^-2
promoted float =  1.0101010101010101010101100000000000000000000000000000*2^-2
    double 1/3 =  1.0101010101010101010101010101010101010101010101010101*2^-2
@end example

To use these numbers in Calc, precede them by @code{2#} to indicate binary.
In @code{bc}, work with the mantissa separately from the exponent.

float vs double vs long double (how many digits are available for each)

importance of using 1.234L in long double calculations

int main (void)
{
  long double x = 1.0, y = 1.0 ;
  
  x = x + 0.2 ;
  y = y + 0.2L ;

  printf(" d %.20Lf\n",x) ;
  printf("ld %.20Lf\n",y) ;

  return 1;
}

 d 1.20000000000000001110
ld 1.20000000000000000004



control of rounding mode, precision, exception masks.

    sqrt(2) = 1.414213562373095048801688724209698078569671...
long double   1.4142135623730950488
     double   1.414213562373095
      float   1.4142135
