To be written

@c to turn on math exception handling use __setfpucw, see
@c /usr/include/i386/fpu_control.h

@c e.g.

@c #include <math.h>
@c #include <stdio.h>
@c #include <fpu_control.h>

@c double f (double x) ;

@c int main ()
@c {
@c   double a = 0 ;
@c   double y, z ;

@c   __setfpucw(0x1372); 


@deftypefun void gsl_ieee_printf_float (const float * @var{x})
@deftypefunx void gsl_ieee_printf_double (const double * @var{x})
@end deftypefun

@example
#include <stdio.h>
#include <gsl_ieee_utils.h>

main () 
@{
  float f = 1.0/3.0 ;
  double d = 1.0/3.0 ;

  double fd = f ; /* promote from float to double */
  
  printf("     float 1/3 = ") ; gsl_ieee_printf_float(&f) ; printf("\n") ;
  printf("promoted float = ") ; gsl_ieee_printf_double(&fd) ; printf("\n") ;
  printf("    double 1/3 = ") ; gsl_ieee_printf_double(&d) ; printf("\n") ;
@}
@end example


@example
     float 1/3 =  1.01010101010101010101011*2^-2
promoted float =  1.0101010101010101010101100000000000000000000000000000*2^-2
    double 1/3 =  1.0101010101010101010101010101010101010101010101010101*2^-2
@end example

To use these numbers in Calc, precede them by @code{2#} to indicate binary.
In @code{bc}, work with the mantissa separately from the exponent.

float vs double vs long double (how many digits are available for each)

importance of using 1.234L in long double calculations

@example
int main (void)
@{
  long double x = 1.0, y = 1.0 ;
  
  x = x + 0.2 ;
  y = y + 0.2L ;

  printf(" d %.20Lf\n",x) ;
  printf("ld %.20Lf\n",y) ;

  return 1;
@}

 d 1.20000000000000001110
ld 1.20000000000000000004
@end example



control of rounding mode, precision, exception masks.

    sqrt(2) = 1.414213562373095048801688724209698078569671...
long double   1.4142135623730950488
     double   1.414213562373095
      float   1.4142135


@section Setting up your IEEE environment

The IEEE standard defines several @dfn{modes} which control the behavior
of floating point operations. These modes specify three important
properties of computer arithmetic: the direction used for rounding
(e.g. round-up or round-down), the precision used for rounding
intermediate results and how the program should handle arithmetic
exceptions, such as division by zero.



Unfortunately the standard does not specify an API for controlling these
features -- each system has its own way of accessing them.  For example,
the Linux kernel uses the function @code{__setfpucw}
(@dfn{set-fpu-control-word}) to set IEEE modes, while HP-UX and Solaris
use the functions @code{fpsetround} and @code{fpsetmask}. To help you
write portable programs GSL allows you to put a platform-independent
description of the modes you want in the environment variable
@code{GSL_IEEE_MODE} and then attempts to take care of the necessary
machine-specific initialization for you.


@deftypefun void gsl_ieee_env_setup ()
This function reads the environment variable @code{GSL_IEEE_MODE} and
attempts to set up the corresponding specified IEEE modes. The
environment variable should have the form

@display
@code{GSL_IEEE_MODE} = "@var{keyword};@var{keyword};..."
@end display
@noindent
where @var{keyword} is one of the following modes,

@code{single-precision}
@code{double-precision}
extended-precision

@end deftypefun



round-to-nearest
round-down
round-up
round-to-zero
mask-all
mask-invalid
mask-denormalized
mask-division-by-zero
mask-overflow
trap-inexact
trap-common

For example,
        
@example
#include <math.h>
#include <stdio.h>
#include <gsl_ieee_utils.h>

int main (void)
@{
  double x = 1, sum = 0; 
  double oldsum
  int i = 0 ;

  gsl_ieee_env_setup () ;

  do 
    @{
      i++ ;
      
      oldsum = sum ;
      sum += x ;
      x = x / i ;
      
      printf("i=%2d sum=%.18f error=%g\n",i, sum, sum - M_E) ;
    @}  
  while (sum != oldsum) ;

}
@end example

@example
GSL_IEEE_MODE="round-to-nearest" ./a.out 
i= 1 sum=1.000000000000000000 error=-1.71828
i= 2 sum=2.000000000000000000 error=-0.718282
i= 3 sum=2.500000000000000000 error=-0.218282
i= 4 sum=2.666666666666666519 error=-0.0516152
....
i=18 sum=2.718281828459045535 error=4.44089e-16
i=19 sum=2.718281828459045535 error=4.44089e-16
@end example


@example
GSL_IEEE_MODE="round-down" ./a.out 
i= 1 sum=1.000000000000000000 error=-1.71828
....
i=19 sum=2.718281828459041094 error=-3.9968e-15
@end example

@example
GSL_IEEE_MODE="single-precision" ./a.out 
....
i=12 sum=2.718281984329223633 error=1.5587e-07
@end example
