@cindex statistics
@cindex mean
@cindex standard deviation
@cindex variance
@cindex estimated standard deviation
@cindex estimated variance
@cindex t-test
@cindex range
@cindex min
@cindex max

This chapter describes the statistical functions in the library.  The
basic statistical functions include routines to compute the mean,
variance and standard deviation. More advanced functions allow you to
calculate absolute deviations, skewness, and kurtosis as well as the
median and arbitrary percentiles.  Statistical tests for comparing
different datasets, such as the t-test, are also included.

All the functions are available in versions for datasets in all the
standard floating-point and integer types. The versions for double
precision floating-point data have the prefix @code{gsl_stats} and the
versions for integer data have the prefix @code{gsl_stats_int}. The
following table gives the prefixes for all the numeric types,

@example
gsl_stats_               double        
gsl_stats_long_double_   long double   
gsl_stats_float_         float         
gsl_stats_long_          long          
gsl_stats_ulong_         unsigned long 
gsl_stats_int_           int           
gsl_stats_uint_          unsigned int  
gsl_stats_short_         short         
gsl_stats_ushort_        unsigned short
gsl_stats_char_          char          
gsl_stats_uchar_         unsigned char 
@end example
@noindent
All the algorithms use a recurrence relation to compute average
quantities in a stable way, without large intermediate values that might
overflow.

@menu
* Mean and standard deviation and variance::  
* Absolute deviation::          
* Higher moments (skewness and kurtosis)::  
* Maximum and Minimum values::  
* Median and Percentiles::      
* Statistical tests::           
* Example statistical programs::  
* Statistics References and Further Reading::  
@end menu

@c @node Statistical Concepts
@c @section Statistical Concepts

@c A probability density function tells us the frequency with which a
@c random variable takes a particular value or lies in a given range,
@c @c
@c @equation
@c \hbox@{probability@}(a < x < b) = \int_a^b dx \, p(x)
@c @end equation
@c @noindent
@c The ensemble of all possible values generated with the appropriate
@c frequency by the probability density function is called the
@c @dfn{population}. We can define parameters describing the probability
@c density function, such as the population mean @math{\mu} and population
@c variance @math{\sigma^2},
@c @c
@c @equation
@c \mu = \int_@{-\infty@}^@{+\infty@} dx \, x p(x) 
@c @end equation
@c @equation
@c \sigma^2 = \int_@{-\infty@}^@{+\infty@} dx \, (x-\mu)^2 p(x)
@c @end equation
@c @noindent
@c The parameters cannot be observed directly. In statistical calculations
@c we try to estimate these parameters from a finite set of observations.

@c An observed datapoint drawn from a population is called a
@c @dfn{sample}. A @dfn{statistic} is a function of a set of samples, such
@c as their mean, median or maximum value.  An @dfn{estimator} is a
@c statistic that we use to extract the underlying parameters of the
@c probability density function.

@c For example the arithmetic mean of an observed dataset, also known as
@c the sample mean, can be shown to be a good estimator for the population
@c mean @math{\mu}. We denote estimators with a "hat", so the sample mean
@c is written @math{\hat \mu}.

@c There can be many possible estimators for a parameter, but some will be
@c better than others. Using probability theory and the probability density
@c function we can calculate the behavior of any estimator. An estimator is
@c called @dfn{unbiased} if its expectation value in repeated observations
@c equals the underlying parameter of the probability density function. An
@c unbiased estimator is desirable. There are also other measures of an
@c estimator properties, such as @dfn{precision} and @dfn{efficiency}
@c (consult the references for details).

@node Mean and standard deviation and variance
@section Mean, Standard Deviation and Variance

@deftypefn Statistics double gsl_stats_mean (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_mean} returns the arithmetic mean of
@var{data}, an array of length @var{n}.

The sample mean is an unbiased estimator of the population mean and is
denoted by @math{\hat \mu}.
@c
@equation
@{\hat \mu@} = @{1 \over N@} \sum x_i
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}.

For a gaussian distribution the variance of @math{\hat \mu} is
@math{\sigma^2/N}, so the one standard-deviation error on the mean is
@math{\sigma/\sqrt@{N@}}.

If the underlying distribution has long tails then the mean may be
subject to large fluctations.

@end deftypefn

@deftypefn Statistics double gsl_stats_est_variance (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_est_variance} returns the estimated
variance of @var{data}, an array of length @var{n}.

This is an unbiased estimator of
@math{\sigma^2}, and is defined by
@c
@equation
@{\hat \sigma@}^2 = @{1 \over (N-1)@} \sum (x_i - @{\hat \mu@})^2
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}. 

Note that the normalisation factor of @math{1/(N-1)} is chosen to make
@math{\hat \sigma^2} an unbiased estimator. (A factor of @math{1/N}
produces variances which, on the average, are too small since
correlations between @math{x_i} and @math{\hat \mu} tend to reduce the
sample variance).

For a gaussian distribution the variance of @math{\hat \sigma^2} is
@math{2 \sigma^4/N}. The one standard-deviation error on the variance is
@math{\sqrt@{2@} \sigma^2/\sqrt@{N@}}.

If the underlying distribution has long tails then the variance may be
subject to large fluctations, or may not converge.

Both these functions compute the mean via a call to
@code{gsl_stats_mean} or @code{gsl_stats_int_mean}. If you have already
computed the mean then you can pass it directly to one of the following
two functions, @code{gsl_stats_est_variance_with_mean} and
@code{gsl_stats_int_est_variance_with_mean}.

@end deftypefn

@deftypefn Statistics double gsl_stats_est_variance_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})

The function @code{gsl_stats_est_variance_with_mean} returns the sample
variance of @var{data} relative to the given value of @var{mean}.  The
function is computed with @math{\hat \mu} replaced by the value of
@var{mean} that you supply,
@c
@equation
@{\hat \sigma@}^2 = @{1 \over (N-1)@} \sum (x_i - mean)^2
@end equation

@end deftypefn

@deftypefn Statistics double gsl_stats_est_sd (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_est_sd_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})

The standard deviation is defined as the square root of the
variance. These functions return the square root of the corresponding
variance functions above.
@end deftypefn

@deftypefn Statistics double gsl_stats_variance (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_variance_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})

These functions compute an unbiased estimate of the variance when the
population mean of a distribution is known @emph{a priori}.

In this case the estimator for the variance requires a factor @math{1/N}
and the sample mean @math{\hat \mu} must be replaced by the known
population mean @math{\mu},
@c
@equation
@{\hat \sigma@}^2 = @{1 \over N@} \sum (x_i - \mu)^2
@end equation
@noindent
@end deftypefn

@deftypefn Statistics double gsl_stats_sd (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_sd_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})

The functions @code{gsl_stats_sd}, @code{gsl_stats_int_sd},
@code{gsl_stats_sd_with_mean} and @code{gsl_stats_int_sd_with_mean}
calculate the standard deviation, which is simply the square root of the
corresponding variance function.
@end deftypefn


@node Absolute deviation
@section Absolute deviation

@deftypefn Statistics double gsl_stats_absdev (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_absdev} computes the absolute deviation
from the mean of @var{data}, an array of length @var{n}.

The absolute deviation from the mean is defined as
@c
@equation
absdev  = @{1 \over N@} \sum |x_i - @{\hat \mu@}|
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}.

The absolute deviation from the mean provides a more robust measure of
the width of a distribution than the variance.

Both these functions compute the mean of @var{data} via a call to
@code{gsl_stats_mean} or @code{gsl_stats_int_mean}.

@end deftypefn

@deftypefn Statistics double gsl_stats_absdev_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})

The function @code{gsl_stats_absdev_with_mean} computes the absolute
deviation of the array @var{data} relative to the given value of
@var{mean},
@c
@equation
absdev  = @{1 \over N@} \sum |x_i - mean|
@end equation
@noindent
These functions are useful if you have already computed the mean of
@var{data} (and want to avoid recomputing it), or wish to calculate the
absolute deviation relative to another value (such as zero, or the
median).

@end deftypefn

@node Higher moments (skewness and kurtosis)
@section Higher moments (skewness and kurtosis)

@deftypefn Statistics double gsl_stats_skew (const double @var{data[]}, size_t @var{n})
The functions @code{gsl_stats_skew} and @code{gsl_stats_int_skew}
compute the skewness of @var{data}, an array of length @var{n}.

The skewness is defined as 
@c
@equation
skew = @{1 \over N@} \sum 
 @{\left( x_i - @{\hat \mu@} \over @{\hat \sigma@} \right)@}^3
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}.

The skewness measures the asymmetry of the tails of a distribution.

Both these functions compute the mean and standard deviation of
@var{data} via calls to @code{gsl_stats_mean} and
@code{gsl_stats_est_sd} or @code{gsl_stats_int_mean} and
@code{gsl_stats_int_est_sd}.

@end deftypefn

@deftypefn Statistics double gsl_stats_skew_with_mean_and_sd (const double @var{data[]}, size_t @var{n}, double @var{mean}, double @var{sd})

The function @code{gsl_stats_skew_with_mean_and_sd} computes the
skewness of the array @var{data} using the given values of the mean
@var{mean} and standard deviation @var{sd}.

@equation
skew = @{1 \over N@}
     \sum @{\left( x_i - mean \over sd \right)@}^3
@end equation
@noindent

These functions are useful if you have already computed the mean and
standard deviation of @var{data} and want to avoid recomputing them.
@end deftypefn

@deftypefn Statistics double gsl_stats_kurtosis (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_kurtosis} computes the kurtosis of
@var{data}, an array of length @var{n}.

The kurtosis is defined as 
@c
@equation
kurtosis = \left( @{1 \over N@} \sum 
 @{\left(x_i - @{\hat \mu@} \over @{\hat \sigma@} \right)@}^4 
 \right) 
 - 3
@end equation
@noindent

The kurtosis measures how sharply peaked a distribution is, relative to
its width. The kurtosis is normalised to zero for a gaussian
distribution by the -3 in the defintion.

@end deftypefn

@deftypefn Statistics double gsl_stats_kurtosis_with_mean_and_sd (const double @var{data[]}, size_t @var{n}, double @var{mean}, double @var{sd})

The function @code{gsl_stats_kurtosis_with_mean_and_sd} computes the
kurtosis of the array @var{data} using the given values of the mean
@var{mean} and standard deviation @var{sd}.

@equation
kurtosis = @{1 \over N@}
  \left( \sum @{\left(x_i - mean \over sd \right)@}^4 \right) 
  - 3
@end equation
@noindent

These functions are useful if you have already computed the mean and
standard deviation of @var{data} and want to avoid recomputing them.
@end deftypefn

@node Maximum and Minimum values
@section Maximum and Minimum values

@deftypefn Statistics double gsl_stats_max (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_max} returns the maximum value in
@var{data}, an array of length @var{n}. The maximum value is defined as
the value of the element @math{x_i} which satisfies @math{x_i >= x_j}
for all @math{j}.

If you want instead to find the element with the largest absolute
magnitude you will need to apply @code{fabs} or @code{abs} to your data
before calling this function.

@end deftypefn
@deftypefn Statistics double gsl_stats_min (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_min} returns the minimun value in
@var{data}, an array of length @var{n}.  The minimum value is defined as
the value of the element @math{x_i} which satisfies @math{x_i <= x_j}
for all @math{j}.

If you want instead to find the element with the smallest absolute
magnitude you will need to apply @code{fabs} or @code{abs} to your data
before calling this function.
@end deftypefn

@deftypefn Statistics size_t gsl_stats_max_index (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_max_index} returns the index of the maximum
value in @var{data}, an array of length @var{n}. The maximum value is
defined as the value of the element @math{x_i} which satisfies @math{x_i
>= x_j} for all @math{j}. When there are several equal maximum elements
then the first one is chosen.

@end deftypefn

@deftypefn Statistics size_t gsl_stats_min_index (const double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_min_index} returns the index of the minimum
value in @var{data}, a double-precision array of length @var{n}. The
minimum value is defined as the value of the element @math{x_i} which
satisfies @math{x_i >= x_j} for all @math{j}. When there are several
equal minimum elements then the first one is chosen.
@end deftypefn

@node Median and Percentiles
@section Median and Percentiles

The median and percentile functions described in this section operate on
sorted data. For convenience we use @dfn{quantiles}, measured on a scale
of 0 to 1, instead of percentiles (which use a scale of 0 to 100).

@deftypefn Statistics void gsl_stats_sort_data (double @var{data[]}, size_t @var{n})

The function @code{gsl_stats_sort_data} sorts the elements of
@var{data}, an array of length @var{n}, into ascending numerical order
in-place (i.e. after sorting, the minimum value of data is in
@var{data[0]} and the maximum value is in @var{data[n-1]}). The system
@code{qsort} function is used to perform the sorting.

The function @code{gsl_stats_int_sort_data} sorts an integer array.
@end deftypefn

@deftypefn Statistics double gsl_stats_median_from_sorted_data (const double @var{sorted_data[]}, size_t @var{n})

The function @code{gsl_stats_median_from_sorted_data} returns the median
value of @var{sorted_data}, an array of length @var{n} with its elements
in ascending numerical order. There are no checks to see whether the
data are sorted, so the function @code{gsl_stats_sort_data} should
always be used first.

When the array has an odd number of elements the median is the value of
element @math{(n-1)/2}. When the array has an even number of elements
the median is the mean of the two nearest middle values, elements
@math{(n-1)/2} and @math{n/2}.

The function @code{gsl_stats_int_median_from_sorted_data} returns the
median of an integer array. Since the median may have to be found by
interpolation the function @code{gsl_stats_int_median_from_sorted_data}
always returns a floating-point number.
@end deftypefn

@deftypefn Statistics double gsl_stats_quantile_from_sorted_data (const double @var{sorted_data[]}, size_t @var{n}, double @var{f})
@deftypefnx Statistics double gsl_stats_int_quantile_from_sorted_data (const int @var{sorted_data[]}, size_t @var{n}, double @var{f})

The function @code{gsl_stats_median_from_sorted_data} returns a
quantile value of @var{sorted_data}, a double-precision array of
length @var{n} with its elements in ascending numerical order.  The
quantile is determined by the @var{f}, a fraction between 0 and 1. For
example, to compute the value of the 75th percentile @var{f} should have
the value 0.75.

There are no checks to see whether the data are sorted, so the function
@code{gsl_stats_sort_data} should always be used first.

The quantile is found by interpolation, using the formula

@equation
quantile = (1 - \delta) data[i] + \delta data[i+1]
@end equation
@noindent
where @math{i} is @code{floor}(@math{(n - 1)f}) and @math{\delta} is 
@math{(n-1)f - i}.

Thus the minimum value of the array (@var{data[0]}) is given by @var{f}
equal to zero, the maximum value (@var{data[n-1]}) is given by @var{f}
equal to one and the median value is given by @var{f} equal to 0.5.

The function @code{gsl_stats_int_quantile_from_sorted_data} returns a
quantile of an integer array. Since the quantile is found by
interpolation the function
@code{gsl_stats_int_quantile_from_sorted_data} always returns a
floating-point number.
@end deftypefn


@node Statistical tests
@section Statistical tests

FIXME, do more work on the statistical tests

@c @deftypefn Statistics double gsl_stats_ttest (const double @var{data1[]}, double @var{data2[]}, size_t @var{n1}, size_t @var{n2})
@c @deftypefnx Statistics double gsl_stats_int_ttest (const double @var{data1[]}, double @var{data2[]}, size_t @var{n1}, size_t @var{n2})

@c The function @code{gsl_stats_ttest} computes the t-test statistic for
@c the two arrays @var{data1[]} and @var{data2[]}, of lengths @var{n1} and
@c @var{n2} respectively.

@c The t-test statistic measures the difference between the means of two
@c datasets.

@node Example statistical programs
@section Example statistical programs
Here is a basic example of how to use the statistical functions:

@example
#include <stdio.h>
#include <gsl_statistics.h>

int main()
@{
  double data[5] = @{17.2, 18.1, 16.5, 18.3, 12.6@} ;
  double mean, variance, largest, smallest;

  mean     = gsl_stats_mean(data, 5);
  variance = gsl_stats_variance(data, 5);
  largest  = gsl_stats_max(data, 5);
  smallest = gsl_stats_min(data, 5);

  printf("The dataset is %g, %g, %g, %g, %g\n",
        data[0], data[1], data[2], data[3], data[4]);

  printf("The sample mean is %g\n", mean) ;
  printf("The estimated variance is %g\n", variance) ;
  printf("The largest value is %g\n", largest) ;
  printf("The smallest value is %g\n", smallest) ;
@}
@end example

The program should produce the following output,

@example
The dataset is 17.2, 18.1, 16.5, 18.3, 12.6
The sample mean is 16.54
The estimated variance is 4.2984
The largest value is 18.3
The smallest value is 12.6
@end example


Here is an example using sorted data,

@example
#include <stdio.h>
#include <gsl_statistics.h>

int main()
@{
  double data[5] = @{17.2, 18.1, 16.5, 18.3, 12.6@} ;
  double median, upperq, lowerq;

  printf("The original dataset is %g, %g, %g, %g, %g\n",
        data[0], data[1], data[2], data[3], data[4]);

  gsl_stats_sort_data(data, 5) ;

  printf("The sorted dataset is %g, %g, %g, %g, %g\n",
        data[0], data[1], data[2], data[3], data[4]);

  median   = gsl_stats_median_from_sorted_data(data, 5);
  upperq   = gsl_stats_quantile_from_sorted_data(data, 5, 0.75);
  lowerq   = gsl_stats_quantile_from_sorted_data(data, 5, 0.25);

  printf("The median is %g\n", median) ;
  printf("The upper quartile is %g\n", upperq) ;
  printf("The lower quartile is %g\n", lowerq) ;
@}
@end example

This program should produce the following output,

@example
The original dataset is 17.2, 18.1, 16.5, 18.3, 12.6
The sorted dataset is 12.6, 16.5, 17.2, 18.1, 18.3
The median is 17.2
The upper quartile is 18.1
The lower quartile is 16.5
@end example

@node Statistics References and Further Reading
@section Statistics References and Further Reading
@noindent
The standard reference for almost any topic in statistics is the
multi-volume @cite{Advanced Theory of Statistics} by Kendall and Stuart.

@itemize @asis
@item
Maurice Kendall, Alan Stuart, and J. Keith Ord.
@cite{The Advanced Theory of Statistics} (multiple volumes)
reprinted as @cite{Kendall's Advanced Theory of Statistics}.
Wiley, ISBN 047023380X.
@end itemize
@noindent
Many statistical concepts can be more easily understood by a Bayesian
approach. The recent book by Gelman, Carlin, Stern and Rubin gives a
comprehensive coverage of the subject, while Jeffreys' @cite{Theory of
Probability} gives an older but more pedagogical introduction.

@itemize @asis
@item
Andrew Gelman, John B. Carlin, Hal S. Stern, Donald B. Rubin.
@cite{Bayesian Data Analysis}.
Chapman & Hall, ISBN 0412039915.

@item
Sir Harold Jeffreys.
@cite{Theory of Probability}.
Clarendon Press, ISBN 0198531931
@end itemize
@noindent
For physicists the Particle Data Group provides useful reviews of
Probability and Statistics in the "Mathematical Tools" section of its
Annual Review of Particle Physics. 

@itemize @asis
@item
@cite{Review of Particle Properties}
R.M. Barnett et al., Physical Review D54, 1 (1996)
@end itemize
@noindent
The Review of Particle Physics is available online in postscript and pdf
format at @url{http://pdg.lbl.gov/}.


