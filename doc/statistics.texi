@cindex statistics
@cindex mean
@cindex standard deviation
@cindex variance
@cindex estimated standard deviation
@cindex estimated variance
@cindex t-test
@cindex range
@cindex min
@cindex max

This chapter describes the statistical functions in the library.  The
basic statistical functions include routines to compute the mean,
variance and standard deviation. More advanced functions allow you to
calculate absolute deviations, skewness, and kurtosis as well as the
median and arbitrary percentiles.  Statistical tests for comparing
different datasets, such as the t-test, are also included.

All the functions are available in versions for floating-point datasets
and integer datasets. The versions for floating-point data have the
prefix @code{gsl_stats} and the versions for integer data have the
prefix @code{gsl_stats_int}. All the algorithms use a recurrence
relation to compute average quantities in a stable way, without large
intermediate values that might overflow.

@menu
* Statistical Concepts::        
* Mean::                        
* Standard deviation and variance (unknown population mean)::  
* Standard deviation and variance (known population mean)::  
* Absolute deviation::          
* Higher moments (skewness and kurtosis)::  
* Maximum and Minimum values::  
* Median and Percentiles::      
* Statistical tests::           
* Example programs::            
* Statistics References and Further Reading::  
@end menu

@node Statistical Concepts
@section Statistical Concepts

A probability density function tells us the frequency with which a
random variable takes a particular value or lies in a given range,
@c
@equation
\hbox@{probability@}(a < x < b) = \int_a^b dx \, p(x)
@end equation
@noindent
The ensemble of all possible values generated with the appropriate
frequency by the probability density function is called the
@dfn{population}. We can define parameters describing the probability
density function, such as the population mean @math{\mu} and population
variance @math{\sigma^2},
@c
@equation
\mu = \int_@{-\infty@}^@{+\infty@} dx \, x p(x) 
@end equation
@equation
\sigma^2 = \int_@{-\infty@}^@{+\infty@} dx \, (x-\mu)^2 p(x)
@end equation
@noindent
The parameters cannot be observed directly. In statistical calculations
we try to estimate these parameters from a finite set of observations.

An observed datapoint drawn from a population is called a
@dfn{sample}. A @dfn{statistic} is a function of a set of samples, such
as their mean, median or maximum value.  An @dfn{estimator} is a
statistic that we use to extract the underlying parameters of the
probability density function.

For example the arithmetic mean of an observed dataset, also known as
the sample mean, can be shown to be a good estimator for the population
mean @math{\mu}. We denote estimators with a "hat", so the sample mean
is written @math{\hat \mu}.

There can be many possible estimators for a parameter, but some will be
better than others. Using probability theory and the probability density
function we can calculate the behavior of any estimator. An estimator is
called @dfn{unbiased} if its expectation value in repeated observations
equals the underlying parameter of the probability density function. An
unbiased estimator is desirable. There are also other measures of an
estimator properties, such as @dfn{precision} and @dfn{efficiency}
(consult the references for details).

@node Mean
@section Mean

@deftypefn Statistics double gsl_stats_mean (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_mean (const int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_mean} returns the arithmetic mean of
@var{data}, a double-precision array of length @var{n}. The function
@code{gsl_stats_int_mean} returns the sample mean of an integer array.

The sample mean is an unbiased estimator of the population mean and is
denoted by @math{\hat \mu}.
@c
@equation
@{\hat \mu@} = @{1 \over N@} \sum x_i
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}.

For a gaussian distribution the variance of @math{\hat \mu} is
@math{\sigma^2/N}, so the one standard-deviation error on the mean is
@math{\sigma/\sqrt@{N@}}.

If the underlying distribution has long tails then the mean may be
subject to large fluctations.

@end deftypefn

@node Standard deviation and variance (unknown population mean)
@section Standard deviation and variance (unknown population mean)

@deftypefn Statistics double gsl_stats_est_variance (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_est_variance (const int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_est_variance} returns the estimated
variance of @var{data}, a double-precision array of length @var{n}.
The function @code{gsl_stats_int_est_variance} returns the estimated
variance of an integer array.

This is an unbiased estimator of
@math{\sigma^2}, and is defined by
@c
@equation
@{\hat \sigma@}^2 = @{1 \over (N-1)@} \sum (x_i - @{\hat \mu@})^2
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}. 

Note that the normalisation factor of @math{1/(N-1)} is chosen to make
@math{\hat \sigma^2} an unbiased estimator. (A factor of @math{1/N}
produces variances which, on the average, are too small since
correlations between @math{x_i} and @math{\hat \mu} tend to reduce the
sample variance).

For a gaussian distribution the variance of @math{\hat \sigma^2} is
@math{2 \sigma^4/N}. The one standard-deviation error on the variance is
@math{\sqrt@{2@} \sigma^2/\sqrt@{N@}}.

If the underlying distribution has long tails then the variance may be
subject to large fluctations, or may not converge.

Both these functions compute the mean via a call to
@code{gsl_stats_mean} or @code{gsl_stats_int_mean}. If you have already
computed the mean then you can pass it directly to one of the following
two functions, @code{gsl_stats_est_variance_with_mean} and
@code{gsl_stats_int_est_variance_with_mean}.

@end deftypefn

@deftypefn Statistics double gsl_stats_est_variance_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})
@deftypefnx Statistics double gsl_stats_int_est_variance_with_mean (const int @var{data[]}, size_t @var{n}, double @var{mean})

The function @code{gsl_stats_est_variance_with_mean} returns the sample
variance of @var{data} relative to the given value of @var{mean}, and
@code{gsl_stats_int_est_variance} does the same for an integer array.
The functions are computed with @math{\hat \mu} replaced by the value of
@var{mean} that you supply,
@c
@equation
@{\hat \sigma@}^2 = @{1 \over (N-1)@} \sum (x_i - mean)^2
@end equation

@end deftypefn

@deftypefn Statistics double gsl_stats_est_sd (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_est_sd (const int @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_est_sd_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})
@deftypefnx Statistics double gsl_stats_int_est_sd_with_mean (const int @var{data[]}, size_t @var{n}, double @var{mean})

The standard deviation is defined as the square root of the
variance. These functions return the square root of the corresponding
variance functions above.
@end deftypefn


@node Standard deviation and variance (known population mean)
@section Standard deviation and variance (known population mean)

@deftypefn Statistics double gsl_stats_variance (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_variance (const int @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_variance_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})
@deftypefnx Statistics double gsl_stats_int_variance_with_mean (const int @var{data[]}, size_t @var{n}, double @var{mean})

These functions compute an unbiased estimate of the variance when the
population mean of a distribution is known @emph{a priori}.

In this case the estimator for the variance requires a factor @math{1/N}
and the sample mean @math{\hat \mu} must be replaced by the known
population mean @math{\mu},
@c
@equation
@{\hat \sigma@}^2 = @{1 \over N@} \sum (x_i - \mu)^2
@end equation
@noindent
@end deftypefn

@deftypefn Statistics double gsl_stats_sd (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_sd (const int @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_sd_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})
@deftypefnx Statistics double gsl_stats_int_sd_with_mean (const int @var{data[]}, size_t @var{n}, double @var{mean})

The functions @code{gsl_stats_sd}, @code{gsl_stats_int_sd},
@code{gsl_stats_sd_with_mean} and @code{gsl_stats_int_sd_with_mean}
calculate the standard deviation, which is simply the square root of the
corresponding variance function.
@end deftypefn


@node Absolute deviation
@section Absolute deviation

@deftypefn Statistics double gsl_stats_absdev (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_absdev (const int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_absdev} computes the absolute deviation
from the mean of @var{data}, a double precision array of length @var{n}.

The absolute deviation from the mean is defined as
@c
@equation
absdev  = @{1 \over N@} \sum |x_i - @{\hat \mu@}|
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}.

The absolute deviation from the mean provides a more robust measure of
the width of a distribution than the variance.

Both these functions compute the mean of @var{data} via a call to
@code{gsl_stats_mean} or @code{gsl_stats_int_mean}.

@end deftypefn

@deftypefn Statistics double gsl_stats_absdev_with_mean (const double @var{data[]}, size_t @var{n}, double @var{mean})
@deftypefnx Statistics double gsl_stats_int_absdev_with_mean (const int @var{data[]}, size_t @var{n}, double @var{mean})

The functions @code{gsl_stats_absdev_with_mean} and
@code{gsl_stats_int_absdev_with_mean} compute the absolute deviation of
the array @var{data} relative to the given value of @var{mean}
@c
@equation
absdev  = @{1 \over N@} \sum |x_i - mean|
@end equation
@noindent
These functions are useful if you have already computed the mean of
@var{data} (and want to avoid recomputing it), or wish to calculate the
absolute deviation relative to another value (such as zero, or the
median).

@end deftypefn

@node Higher moments (skewness and kurtosis)
@section Higher moments (skewness and kurtosis)

@deftypefn Statistics double gsl_stats_skew (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_skew (const int @var{data[]}, size_t @var{n}, double @var{mean})
The functions @code{gsl_stats_skew} and @code{gsl_stats_int_skew}
compute the skewness of @var{data}, an array of length @var{n}.

The skewness is defined as 
@c
@equation
skew = @{1 \over N@} \sum 
 @{\left( x_i - @{\hat \mu@} \over @{\hat \sigma@} \right)@}^3
@end equation
@noindent
where @math{x_i} are the elements of the array @var{data}.

The skewness measures the asymmetry of the tails of a distribution.

Both these functions compute the mean and standard deviation of
@var{data} via calls to @code{gsl_stats_mean} and
@code{gsl_stats_est_sd} or @code{gsl_stats_int_mean} and
@code{gsl_stats_int_est_sd}.

@end deftypefn

@deftypefn Statistics double gsl_stats_skew_with_mean_and_sd (const double @var{data[]}, size_t @var{n}, double @var{mean}, double @var{sd})
@deftypefnx Statistics double gsl_stats_int_skew_with_mean_and_sd (const int @var{data[]}, size_t @var{n}, double @var{mean}, double @var{sd})

The functions @code{gsl_stats_skew_with_mean_and_sd} and
@code{gsl_stats_int_skew_with_mean_and_sd} compute the skewness of the
array @var{data} using the given values of the mean @var{mean} and
standard deviation @var{sd}.

@equation
skew = @{1 \over N@}
     \sum @{\left( x_i - mean \over sd \right)@}^3
@end equation
@noindent

These functions are useful if you have already computed the mean and
standard deviation of @var{data} and want to avoid recomputing them.
@end deftypefn

@deftypefn Statistics double gsl_stats_kurtosis (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_kurtosis (const int @var{data[]}, size_t @var{n}, double @var{mean})

The functions @code{gsl_stats_kurtosis} and
@code{gsl_stats_int_kurtosis} compute the kurtosis of @var{data}, an
array of length @var{n}.

The kurtosis is defined as 
@c
@equation
kurtosis = \left( @{1 \over N@} \sum 
 @{\left(x_i - @{\hat \mu@} \over @{\hat \sigma@} \right)@}^4 
 \right) 
 - 3
@end equation
@noindent

The kurtosis measures how sharply peaked a distribution is, relative to
its width. The kurtosis is normalised to zero for a gaussian
distribution by the -3 in the defintion.

@end deftypefn

@deftypefn Statistics double gsl_stats_kurtosis_with_mean_and_sd (const double @var{data[]}, size_t @var{n}, double @var{mean}, double @var{sd})
@deftypefnx Statistics double gsl_stats_int_kurtosis_with_mean_and_sd (const int @var{data[]}, size_t @var{n}, double @var{mean}, double @var{sd})

The functions @code{gsl_stats_kurtosis_with_mean_and_sd} and
@code{gsl_stats_int_kurtosis_with_mean_and_sd} compute the kurtosis of
the array @var{data} using the given values of the mean @var{mean} and
standard deviation @var{sd}.

@equation
kurtosis = @{1 \over N@}
  \left( \sum @{\left(x_i - mean \over sd \right)@}^4 \right) 
  - 3
@end equation
@noindent

These functions are useful if you have already computed the mean and
standard deviation of @var{data} and want to avoid recomputing them.
@end deftypefn

@node Maximum and Minimum values
@section Maximum and Minimum values

@deftypefn Statistics double gsl_stats_max (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics int gsl_stats_int_max (const int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_max} returns the maximum value in
@var{data}, a double-precision array of length @var{n}.  The function
@code{gsl_stats_int_stats_max} returns the maximum value of an integer
array. The maximum value is defined as the value of the element
@math{x_i} which satisfies @math{x_i >= x_j} for all @math{j}.

If you want instead to find the element with the largest absolute
magnitude you will need to apply @code{fabs} or @code{abs} to your data
before calling this function.

@end deftypefn
@deftypefn Statistics double gsl_stats_min (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics int gsl_stats_int_min (const int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_min} returns the minimun value in
@var{data}, a double-precision array of length @var{n}.  The function
@code{gsl_stats_int_stats_min} returns the minimum value of an integer
array. The minimum value is defined as the value of the element
@math{x_i} which satisfies @math{x_i <= x_j} for all @math{j}.

If you want instead to find the element with the smallest absolute
magnitude you will need to apply @code{fabs} or @code{abs} to your data
before calling this function.
@end deftypefn

@deftypefn Statistics size_t gsl_stats_max_index (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics size_t gsl_stats_int_max_index (const int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_max_index} returns the index of the maximum
value in @var{data}, a double-precision array of length @var{n}. The
function @code{gsl_stats_int_stats_max} returns the index of the maximum
value of an integer array. The maximum value is defined as the value of
the element @math{x_i} which satisfies @math{x_i >= x_j} for all
@math{j}. When there are several equal maximum elements then the first
one is chosen.

@end deftypefn

@deftypefn Statistics size_t gsl_stats_min_index (const double @var{data[]}, size_t @var{n})
@deftypefnx Statistics size_t gsl_stats_int_min_index (const int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_min_index} returns the index of the minimum
value in @var{data}, a double-precision array of length @var{n}. The
function @code{gsl_stats_int_stats_min} returns the index of the minimum
value of an integer array. The minimum value is defined as the value of
the element @math{x_i} which satisfies @math{x_i >= x_j} for all
@math{j}. When there are several equal minimum elements then the first
one is chosen.
@end deftypefn

@node Median and Percentiles
@section Median and Percentiles

The median and percentile functions described in this section operate on
sorted data. 

@deftypefn Statistics void gsl_stats_sort_data (double @var{data[]}, size_t @var{n})
@deftypefnx Statistics void gsl_stats_int_sort_data (int @var{data[]}, size_t @var{n})

The function @code{gsl_stats_sort_data} sorts the elements of
@var{data}, a double-precision array of length @var{n}, into ascending
numerical order in-place (i.e. after sorting, the minimum value of data
is in @var{data[0]} and the maximum value is in @var{data[n-1]}). The
system @code{qsort} function is used to perform the sorting.

The function @code{gsl_stats_int_sort_data} sorts an integer array.
@end deftypefn

@deftypefn Statistics double gsl_stats_median_from_sorted_data (const double @var{sorted_data[]}, size_t @var{n})
@deftypefnx Statistics double gsl_stats_int_median_from_sorted_data (const int @var{sorted_data[]}, size_t @var{n})

The function @code{gsl_stats_median_from_sorted_data} returns the median
value of @var{sorted_data}, a double-precision array of length @var{n} with its
elements in ascending numerical order. There are no checks to see
whether the data are sorted, so the function @code{gsl_stats_sort_data}
should always be used first.

When the array has an odd number of elements the median is the value of
element @math{(n-1)/2}. When the array has an even number of elements
the median is the mean of the two nearest middle values, elements
@math{(n-1)/2} and @math{n/2}.

The function @code{gsl_stats_int_median_from_sorted_data} returns the
median of an integer array. Since the median may have to be found by
interpolation the function @code{gsl_stats_int_median_from_sorted_data}
always returns a floating-point number.
@end deftypefn

@deftypefn Statistics double gsl_stats_percentile_from_sorted_data (const double @var{sorted_data[]}, size_t @var{n}, double @var{f})
@deftypefnx Statistics double gsl_stats_int_percentile_from_sorted_data (const int @var{sorted_data[]}, size_t @var{n}, double @var{f})

The function @code{gsl_stats_median_from_sorted_data} returns a
percentile value of @var{sorted_data}, a double-precision array of
length @var{n} with its elements in ascending numerical order.  The
percentile is determined by the @var{f}, a fraction between 0 and 1. For
example, to compute the value of the 75th percentile @var{f} should have
the value 0.75.

There are no checks to see whether the data are sorted, so the function
@code{gsl_stats_sort_data} should always be used first.

The percentile is found by interpolation, using the formula

@equation
percentile = (1 - \delta) data[i] + \delta data[i+1]
@end equation
@noindent
where @math{i} is @code{floor}(@math{(n - 1)f}) and @math{\delta} is 
@math{(n-1)f - i}.

Thus the minimum value of the array (@var{data[0]}) is given by @var{f}
equal to zero, the maximum value (@var{data[n-1]}) is given by @var{f}
equal to one and the median value is given by @var{f} equal to 0.5.

The function @code{gsl_stats_int_percentile_from_sorted_data} returns a
percentile of an integer array. Since the percentile is found by
interpolation the function
@code{gsl_stats_int_percentile_from_sorted_data} always returns a
floating-point number.
@end deftypefn


@node Statistical tests
@section Statistical tests

FIXME, do more work on the statistical tests

@c @deftypefn Statistics double gsl_stats_ttest (const double @var{data1[]}, double @var{data2[]}, size_t @var{n1}, size_t @var{n2})
@c @deftypefnx Statistics double gsl_stats_int_ttest (const double @var{data1[]}, double @var{data2[]}, size_t @var{n1}, size_t @var{n2})

@c The function @code{gsl_stats_ttest} computes the t-test statistic for
@c the two arrays @var{data1[]} and @var{data2[]}, of lengths @var{n1} and
@c @var{n2} respectively.

@c The t-test statistic measures the difference between the means of two
@c datasets.

@node Example programs
@section Example programs
Here is a basic example of how to use the statistical functions:

@example
#include <stdio.h>
#include <gsl_statistics.h>

int main()
@{
  double data[5] = @{17.2, 18.1, 16.5, 18.3, 12.6@} ;
  double mean, variance, largest, smallest;

  mean     = gsl_stats_mean(data, 5);
  variance = gsl_stats_variance(data, 5);
  largest  = gsl_stats_max(data, 5);
  smallest = gsl_stats_min(data, 5);

  printf("The dataset is %g, %g, %g, %g, %g\n",
        data[0], data[1], data[2], data[3], data[4]);

  printf("The sample mean is %g\n", mean) ;
  printf("The estimated variance is %g\n", variance) ;
  printf("The largest value is %g\n", largest) ;
  printf("The smallest value is %g\n", smallest) ;
@}
@end example

The program should produce the following output,

@example
The dataset is 17.2, 18.1, 16.5, 18.3, 12.6
The sample mean is 16.54
The estimated variance is 4.2984
The largest value is 18.3
The smallest value is 12.6
@end example


Here is an example using sorted data,

@example
#include <stdio.h>
#include <gsl_statistics.h>

int main()
@{
  double data[5] = @{17.2, 18.1, 16.5, 18.3, 12.6@} ;
  double median, upperq, lowerq;

  printf("The original dataset is %g, %g, %g, %g, %g\n",
        data[0], data[1], data[2], data[3], data[4]);

  gsl_stats_sort_data(data, 5) ;

  printf("The sorted dataset is %g, %g, %g, %g, %g\n",
        data[0], data[1], data[2], data[3], data[4]);

  median   = gsl_stats_median_from_sorted_data(data, 5);
  upperq   = gsl_stats_percentile_from_sorted_data(data, 5, 0.75);
  lowerq   = gsl_stats_percentile_from_sorted_data(data, 5, 0.25);

  printf("The median is %g\n", median) ;
  printf("The upper quartile is %g\n", upperq) ;
  printf("The lower quartile is %g\n", lowerq) ;
@}
@end example

This program should produce the following output,

@example
The original dataset is 17.2, 18.1, 16.5, 18.3, 12.6
The sorted dataset is 12.6, 16.5, 17.2, 18.1, 18.3
The median is 17.2
The upper quartile is 18.1
The lower quartile is 16.5
@end example

@node Statistics References and Further Reading
@section Statistics References and Further Reading
@noindent
The standard reference for almost any topic in statistics is the
multi-volume @cite{Advanced Theory of Statistics} by Kendall and Stuart.

@itemize @asis
@item
Maurice Kendall, Alan Stuart, and J. Keith Ord.
@cite{The Advanced Theory of Statistics} (multiple volumes)
reprinted as @cite{Kendall's Advanced Theory of Statistics}.
Wiley, ISBN 047023380X.
@end itemize
@noindent
Many statistical concepts can be more easily understood by a Bayesian
approach. The recent book by Gelman, Carlin, Stern and Rubin gives a
comprehensive coverage of the subject, while Jeffreys' @cite{Theory of
Probability} gives an older but more pedagogical introduction.

@itemize @asis
@item
Andrew Gelman, John B. Carlin, Hal S. Stern, Donald B. Rubin.
@cite{Bayesian Data Analysis}.
Chapman & Hall, ISBN 0412039915.

@item
Sir Harold Jeffreys.
@cite{Theory of Probability}.
Clarendon Press, ISBN 0198531931
@end itemize
@noindent
For physicists the Particle Data Group provides useful reviews of
Probability and Statistics in the "Mathematical Tools" section of its
Annual Review of Particle Physics. 

@itemize @asis
@item
@cite{Review of Particle Properties}
R.M. Barnett et al., Physical Review D54, 1 (1996)
@end itemize
@noindent
The Review of Particle Physics is available online in postscript format
at @url{http://pdg.lbl.gov/}.


