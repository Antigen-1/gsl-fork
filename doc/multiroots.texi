This chapter describes functions for solving multidimensional nonlinear
equations (with @math{n} equations in @math{n} unknowns). The library
provides low level components for a variety of iterative solvers and
convergence tests. These can be combined by the user to achieve the
desired solution, with full access to the intermediate steps of the
iteration. Each class of methods uses the same framework, so that you
can switch between solvers at runtime without needing to recompile your
program. Each instance of a solver keeps track of its own state,
allowing the solvers to be used in multi-threaded programs.

The header file @file{gsl_multiroots.h} contains prototypes for the
multidimensional root finding functions and related declarations.

@menu
* Multidimensional Root Finding Overview::  
* Multidimensional Root Finding - Initializing the Solver::  
* Multidimensional Root Finding - Providing the function to solve::  
* Multidimensional Root Finding References and Further Reading::  
@end menu

@node Multidimensional Root Finding Overview
@section Overview
@cindex multidimensional root finding, overview

The problem of multidimensional root finding requires the simultaneous
solution of @math{n} equations, @math{F_i}, in @math{n} variables,
@math{x_i},

@tex
\beforedisplay
$$
F_i (x_1, \dots, x_n) = 0 \qquad\hbox{for}~i = 1 \dots n.
$$
\afterdisplay
@end tex
@ifinfo
@example
F_i (x_1, ..., x_n) = 0    for i = 1 ... n.
@end example
@end ifinfo
@noindent
In general there are no bracketing methods available for @math{n}
dimensional systems, and no way of knowing whether any solutions
exist. All algorithms proceed from an initial guess using a variant of
the Newton iteration,

@tex
\beforedisplay
$$
x \to x - J^{-1} F(x)
$$
\afterdisplay
@end tex
@ifinfo
@example
x -> x - J^@{-1@} F(x)
@end example
@end ifinfo
@noindent
where @math{x}, @math{F} are vector quantities and @math{J} is the
Hessian matrix @c{$J_{ij} = \partial F_i / \partial x_j$} 
@math{J_@{ij@} = d F_i / d x_j}.
Additional strategies are also used to enlarge the region of
convergence. These include requiring a decrease in the norm @math{|F|} on
each iteration proposed by Newton's method, or taking downwards steps in
the direction of the negative gradient of @math{|F|}.

The evaluation of the Hessian matrix can be problematic, either because
programming the derivatives is intractable or because computation of the
@math{n^2} terms of the matrix becomes too expensive. For these reasons
the algorithms provided by the library fall into two classes according
to whether the derivatives are available or not.

The state for solvers with an analytic Hessian matrix is held in a
@code{gsl_multiroot_fdfsolver} struct. The updating procedure requires
both the function and its derivatives to be supplied by the user.

The state for solvers which do not use an analytic Hessian matrix is
held in a @code{gsl_multiroot_fsolver} struct. The updating procedure
uses only function evaluations (not derivatives).  The algorithms
estimate the matrix @math{J} or @c{$J^{-1}$} 
@math{J^@{-1@}} by approximate methods.

@node Multidimensional Root Finding - Initializing the Solver
@section Initializing the Solver

@deftypefun {gsl_multiroot_fsolver *} gsl_multiroot_fsolver_alloc (const gsl_multiroot_fsolver_type * @var{T}, gsl_multiroot_function * @var{f}, gsl_vector * @var{x})
This function returns a pointer to a a newly allocated instance of a
solver of type @var{T} for the function @var{f}, with an initial bracket
on the root of @var{x}. For example, the following code creates an
instance of a Brent solver,

@example
gsl_multiroot_fsolver * s = 
    gsl_multiroot_fsolver_alloc (gsl_multiroot_fsolver_brent, f, x);
@end example

If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of @code{GSL_ENOMEM}.
@end deftypefun

@deftypefun {gsl_multiroot_fdfsolver *} gsl_multiroot_fdfsolver_alloc (const gsl_multiroot_fdfsolver_type * @var{T}, gsl_multiroot_function_fdf * @var{fdf}, gsl_vector * @var{x})
This function returns a pointer to a a newly allocated instance of a
solver of type @var{T} for the function @var{f}, with an initial guess
for the root of @var{x}. For example, the following code creates an
instance of a Newton-Raphson solver,

@example
gsl_multiroot_fdfsolver * s = 
    gsl_multiroot_fdfsolver_alloc (gsl_multiroot_fdfsolver_newton, fdf, x);
@end example

If there is insufficient memory to create the solver then the function
returns a null pointer and the error handler is invoked with an error
code of @code{GSL_ENOMEM}.
@end deftypefun

@deftypefun int gsl_multiroot_fsolver_set (gsl_multiroot_fsolver * @var{s}, gsl_multiroot_function * @var{f}, gsl_vector * @var{x})
This function reinitializes an existing solver @var{s} to use the
function @var{f} and the initial guess @var{x}.
@end deftypefun

@deftypefun int gsl_multiroot_fdfsolver_set (gsl_multiroot_fdfsolver * @var{s}, gsl_function_fdf * @var{fdf}, gsl_vector * @var{x})
This function reinitializes an existing solver @var{s} to use the
function and derivative @var{fdf} and the initial guess @var{x}.
@end deftypefun

@deftypefun void gsl_multiroot_fsolver_free (gsl_multiroot_fsolver * @var{s})
@deftypefunx void gsl_multiroot_fdfsolver_free (gsl_multiroot_fdfsolver * @var{s})
These functions free all the memory associated with the solver @var{s}.
@end deftypefun

@deftypefun {const char *} gsl_multiroot_fsolver_name (const gsl_multiroot_fsolver * @var{s})
@deftypefunx {const char *} gsl_multiroot_fdfsolver_name (const gsl_multiroot_fdfsolver * @var{s})
These functions return a pointer to the name of the solver. For example,

@example
printf("s is a '%s' solver\n", gsl_multiroot_fdfsolver_name (s)) ;
@end example

@noindent
would print something like @code{s is a 'newton' solver}
@end deftypefun

@node Multidimensional Root Finding - Providing the function to solve
@section Providing the function to solve
@cindex multidimensional root finding, providing a function to solve

You must provide @math{n} functions of @math{n} variables for the root
finders to operate on. In order to allow for general parameters the
functions are defined by the following data types:

@deftp {Data Type} gsl_multiroot_function 
This data type defines a general system of functions with parameters.

@table @code
@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
this function should store the vector result
@c{$f(x,\hbox{\it params})$}
@math{f(x,params)} in @var{f} for argument @var{x} and parameters @var{params},
returning an appropriate error code if the function cannot be computed.

@item size_t @var{n}
the dimension of the system, i.e. the number of components of the
vectors @var{x} and @var{f}

@item void * @var{params}
a pointer to the parameters of the function
@end table

Here is an example for Powell's test function,

@tex
\beforedisplay
$$
f_1(x) = A x_0 x_1 - 1,
f_2(x) = \exp(-x_0) + \exp(-x_1) - (1 + 1/A)
$$
\afterdisplay
@end tex
@ifinfo
@example
f_1(x) = A x_0 x_1 - 1,
f_2(x) = exp(-x_0) + exp(-x_1) - (1 + 1/A)
@end example
@end ifinfo

@noindent
with @math{A = 10^4}. The following code defines a
@code{gsl_multiroot_function} system @code{F} which you could pass to a
solver:

@example
struct powell_params @{ double A ; @} ;

int
powell (gsl_vector * x, void * p, gsl_vector * f) @{
   struct powell_params * params = *(struct powell_params *)p ;
   double A = (params->A) ;
   double x0 = gsl_vector_get(x,0);
   double x1 = gsl_vector_get(x,1);
   gsl_vector_set (f, 0, A * x0 * x1 - 1)
   gsl_vector_set (f, 1, exp(-x0) + exp(-x1) - (1 + 1/A))
   return GSL_SUCCESS
@}

gsl_multiroot_function F ;
struct powell_params params = @{ 10000.0 @};

F.function = &powell ;
F.n = 2 ;
F.params = &params ;
@end example


@end deftp

@deftp {Data Type} gsl_multiroot_function_fdf
This data type defines a general system of functions with parameters and
their Hessian matrix of derivatives.

@table @code
@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
this function should return the value of
@c{$f(x,\hbox{\it params})$}
@math{f(x,params)} for argument @var{x} and parameters @var{params}

@item int (* df) (const gsl_vector * @var{x}, void * @var{params}, gsl_matrix * @var{J})
@item int (* fdf) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f}, gsl_matrix * @var{J})

@item double (* @var{df}) (double @var{x}, void * @var{params})
this function should return the value of the derivative of @var{f} with
respect to @var{x},
@c{$f'(x,\hbox{\it params})$}
@math{f'(x,params)}, for argument @var{x} and parameters @var{params}

@item void (* @var{fdf}) (double @var{x}, void * @var{params}, double * @var{f}, double * @var{d}f)
this function should set the values of the function @var{f} to 
@c{$f(x,\hbox{\it params})$}
@math{f(x,params)}
and its derivative @var{df} to
@c{$f'(x,\hbox{\it params})$}
@math{f'(x,params)} 
for argument @var{x} and parameters @var{params}. This function provides
an optimization of the separate functions for @math{f(x)} and @math{f'(x)} -- 
it is always faster to compute the function and its derivative at the
same time. 

@item void * @var{params}
a pointer to the parameters of the function
@end table

Here is an example where 
@c{$f(x) = \exp(2x)$}
@math{f(x) = 2\exp(2x)}:

@example
double
my_f (double x, void * params)
@{
   return exp (2 * x);
@}

double
my_df (double x, void * params)
@{
   return 2 * exp (2 * x);
@}

void
my_fdf (double x, void * params, double * f, double * df)
@{
   double t = exp (2 * x) ;

   *f = t;
   *df = 2 * t;   /* computing using existing values */
@}

gsl_function_fdf FDF ;

FDF.f = &my_f ;
FDF.df = &my_df ;
FDF.fdf = &my_fdf ;
FDF.params = 0 ;
@end example

@end deftp


@node Multidimensional Root Finding References and Further Reading
@section References and Further Reading

@itemize @asis
@item
C.G. Broyden, "A Class of Methods for Solving Nonlinear
Simultaneous Equations", @cite{Mathematics of Computation}, vol 19 (1965),
p 577-593

@item
J.J. Mor@'e, M.Y. Cosnard, "Numerical Solution of Nonlinear Equations",
@cite{ACM Transactions on Mathematical Software}, Vol 5, No 1, (1979), p 64-85
@end itemize
