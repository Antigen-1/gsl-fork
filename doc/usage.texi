@cindex standards conformance, ANSI C
@cindex ANSI C, use of
@cindex C extensions, compatible use of
@cindex compatibility
This chapter describes how to compile programs that use GSL, and
introduces its conventions.  The library is written in ANSI C and is
intended to conform to the ANSI C standard.  The library does not rely
on any non-ANSI extensions in the interface it exports to the user.
Extensions which can be used in a way compatible with pure ANSI C are
supported, however.  Thus programs you write using GSL should be
portable to any system with a working ANSI C compiler.  They will also be
able to take advantage of compiler extensions on those platforms which
support them.  When an ANSI C feature is known to be broken on a
particular system the library will exclude any related functions at
compile-time.  This should make it impossible to link a program that
would use these functions and give incorrect results.

@menu
* Compiling and Linking::       
* Inline functions::            
* Long double::                 
* Alternative optimized functions::  
* Support for different numeric types::  
* Compatibility with C++::      
@end menu

@node Compiling and Linking
@section Compiling and Linking
@cindex compiling programs, include paths
@cindex including GSL header files
@cindex header files, including
The library header files are installed in their own @file{gsl}
directory.  You should write any preprocessor include statements with a
@file{gsl/} directory prefix thus,

@example
#include <gsl/gsl_math.h>
@end example

@noindent
If the directory is not installed on the standard search path of your
compiler you will also need to provide its location to the preprocessor
as a command line flag.  The default location of the @file{gsl}
directory is @file{/usr/local/include/gsl}.

@cindex compiling programs, library paths
@cindex linking with GSL libraries
@cindex libraries, linking with
The library is installed as a single file, @file{libgsl.a}.  A shared
version of the library is also installed on systems that support shared
libraries.  The default location of these files is
@file{/usr/local/lib}.  To link against the library you need to specify
both the main library and a supporting @sc{blas} library.  A suitable
blas implementation is provided in @file{libgslblasnative} if your
system does not provide one.  The following example shows how to link an
application with the library,

@example
gcc app.o -lgsl -lgslblasnative -lm
@end example
@noindent
The following command line shows how to link the same application with
an alternative blas library @file{libcblas},

@example
gcc app.o -lgsl -lgslblascblas -lcblas -lm
@end example
@noindent
The library must conform to the @sc{cblas} standard. For more
information see @ref{BLAS Support}.

To run a program linked with the shared version of the library it may be
necessary to define the shell variable @code{LD_LIBRARY_PATH} to include
the directory where the library is installed. For example,

@example
LD_LIBRARY_PATH=/usr/local/gsl:$LD_LIBRARY_PATH ./app
@end example
@noindent
To compile a statically linked version of the program instead, use the
@code{-static} flag in @code{gcc},

@example
gcc -static app.o -lgsl -lgslblasnative -lm
@end example
@noindent
The installed program @code{gsl-config} provides information on the
appropriate compiler and linker options for compiling programs using the
library. For example, the following command shows that the library has
been installed under the directory @file{/usr/local},

@example
$ gsl-config --prefix
/usr/local
@end example
@noindent
Further information is available using the command @code{gsl-config --help}.

@node Inline functions
@section Inline functions

@cindex inline functions
@cindex HAVE_INLINE
@cindex autoconf, using with GSL
The @code{inline} keyword is not part of ANSI C and the library does not
export any inline function definitions by default.  The inline versions
of functions can be included by defining the macro @code{HAVE_INLINE}
when compiling an application.

@example
gcc -c -DHAVE_INLINE app.c
@end example
@noindent
If you use @code{autoconf} this macro can be defined automatically.
The following test should be placed in your @file{configure.in} file,

@example
AC_C_INLINE

if test "$ac_cv_c_inline" != no ; then
  AC_DEFINE(HAVE_INLINE,1)
  AC_SUBST(HAVE_INLINE)
fi
@end example
@noindent
and the macro will then be defined in the compilation flags or by
including the file @file{config.h} before any library headers.  If you
do not define the macro @code{HAVE_INLINE} then the slower non-inlined
versions of the functions will be used instead.

@node Long double
@section Long double
@cindex long double
The extended numerical type @code{long double} is part of the ANSI C
standard and should be available in every modern compiler.  However, the
precision of @code{long double} is platform dependent, and this should
be considered when using it.  The IEEE standard only specifies the
minimum precision of extended precision numbers, while @code{double} is
the same on all platforms.

In some system libraries the @code{stdio.h} formatted input/output
functions @code{printf} and @code{scanf} are not implemented correctly
for @code{long double}.  Undefined or incorrect results are avoided by
testing these functions during the @code{configure} stage of library
compilation and eliminating certain GSL functions which depend on them
if necessary,

@example
checking whether printf/scanf works with long double... no
@end example

@noindent
Consequently when @code{long double} formatted input/output does not
work on a given system it will not be possible to link a program which
uses GSL functions dependent on this.

If it is necessary to work on a system which does not support formatted
@code{long double} input/output then the options are to use binary
formats or to convert @code{long double} results into @code{double} for
reading and writing.

@node Alternative optimized functions
@section Alternative optimized functions

@cindex alternative optimized functions
@cindex optimized functions, alternatives
The main implementation of some functions in the library will not be
optimal on all architectures.  For example, there are several ways to
compute a Gaussian random variate and their relative speeds are
platform-dependent.  In cases like this the library provides alternate
implementations of these functions with the same interface.  If you
write your application using calls to the standard implementation you
can select an alternative version later via a preprocessor definition.
It is also possible to introduce your own optimized functions this way
while retaining portability.  For example,

@example
#ifdef SPARC
#define gsl_ran_gaussian gsl_ran_gaussian_ratio_method
#endif
#ifdef INTEL
#define gsl_ran_gaussian my_gaussian
#endif
@end example
@noindent
Note that the alternative implementations will not produce bit-for-bit
identical results, and in the case of random number distributions will
produce an entirely different stream of random variates.

@node Support for different numeric types
@section Support for different numeric types

Many functions in the library are defined for different numeric types.
This feature is implemented by varying the name of the function with a
type-related modifier --- a primitive form of C++ templates.  The
modifier is inserted into the function name after the initial module
prefix.  The following table shows the function names defined for all
the numeric types of an imaginary module @code{gsl_foo} with function
@code{fn},

@example
gsl_foo_fn               double        
gsl_foo_long_double_fn   long double   
gsl_foo_float_fn         float         
gsl_foo_long_fn          long          
gsl_foo_ulong_fn         unsigned long 
gsl_foo_int_fn           int           
gsl_foo_uint_fn          unsigned int  
gsl_foo_short_fn         short         
gsl_foo_ushort_fn        unsigned short
gsl_foo_char_fn          char          
gsl_foo_uchar_fn         unsigned char 
@end example
@noindent
The normal numeric precision @code{double} is considered the default and
does not require a suffix.  For example, the function
@code{gsl_stats_mean} computes the mean of double precision numbers,
while the function @code{gsl_stats_int_mean} computes the mean of
integers.

A corresponding scheme is used for library defined types, such as
@code{gsl_vector} and @code{gsl_matrix}.  In this case the modifier is
appended to the type name.  For example, if a module defines a new
type-dependent struct or typedef @code{gsl_foo} it is modified for other
types in the following way,

@example
gsl_foo                  double        
gsl_foo_long_double      long double   
gsl_foo_float            float         
gsl_foo_long             long          
gsl_foo_ulong            unsigned long 
gsl_foo_int              int           
gsl_foo_uint             unsigned int  
gsl_foo_short            short         
gsl_foo_ushort           unsigned short
gsl_foo_char             char          
gsl_foo_uchar            unsigned char 
@end example
@noindent
When a module contains type-dependent definitions the library provides
individual header files for each type.  The filenames are modified as
shown in the below.  For convenience the default header includes the
definitions for all the types.  To include only the double precision
header, or any other specific type, file use its individual filename.

@example
#include <gsl/gsl_foo.h>                  All types listed below
#include <gsl/gsl_foo_double.h>           double        
#include <gsl/gsl_foo_long_double.h>      long double   
#include <gsl/gsl_foo_float.h>            float         
#include <gsl/gsl_foo_long.h>             long          
#include <gsl/gsl_foo_ulong.h>            unsigned long 
#include <gsl/gsl_foo_int.h>              int           
#include <gsl/gsl_foo_uint.h>             unsigned int  
#include <gsl/gsl_foo_short.h>            short         
#include <gsl/gsl_foo_ushort.h>           unsigned short
#include <gsl/gsl_foo_char.h>             char          
#include <gsl/gsl_foo_uchar.h>            unsigned char 
@end example


@node Compatibility with C++
@section Compatibility with C++
@cindex C++, compatibility
The library header files automatically define functions to have
@code{extern "C"} linkage when included in C++ programs.
