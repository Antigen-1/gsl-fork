\input texinfo @c -*-texinfo-*-

@c %**start of header
@setfilename gsl-ref.info
@settitle GNU Scientific Library -- Reference Manual
@finalout
@c @setchapternewpage odd
@c %**end of header

@dircategory Scientific software
@direntry
* gsl-ref: (gsl-ref).                   GNU Scientific Library -- Reference
@end direntry

@include version-ref.texi
@set GSL @emph{GNU Scientific Library}

@ifinfo
This file documents the @value{GSL}.

Copyright (C) 1996, 1997 The GSL Project.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end ifinfo

@titlepage
@title GNU Scientific Library -- Reference Manual
@subtitle Edition @value{EDITION}, for gsl Version @value{VERSION}
@subtitle @value{UPDATED}
@author Mark Galassi @footnote{Cygnus Solutions and Los Alamos National Laboratory}
@author @email{rosalia@@nis.lanl.gov}
@author
@author Jim Davies @footnote{Space Data Systems Group, Los Alamos National Laboratory and Department of Computer Science, Georgia Institute of Technology}
@author @email{jimmyd@@nis.lanl.gov}
@author
@author James Theiler @footnote{Astrophysics and Radiation Measurements group, Los Alamos National Laboratory}
@author @email{jt@@nis.lanl.gov}
@author
@author Brian Gough @footnote{Theoretical Particle Physics group, Los Alamos National Laboratory}
@author @email{bjg@@vvv.lanl.gov}
@author
@author Reid Priedhorsky @footnote{Mathematical Modeling and Analysis group, Los Alamos National Laboratory}
@author @email{rp@@lanl.gov}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1996,1997 The GSL Project.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end titlepage

@ifinfo
@node Top, Preliminaries, (dir), (dir)
@top GSL
@end ifinfo

@ifinfo
This file documents the the @value{GSL}, a collection of numerical
routines for scientific computing.

As of @value{UPDATED}, the only complete packages are the random number
suite (@pxref{Random number generation}) and the FFT package
(@pxref{FFTs}).
@end ifinfo


@menu
* Preliminaries::               
* Error handling in GSL::       
* Random number generation::    
* Basic statistics::            
* FFTs::                        
* Root finding::                
* Simulated annealing::         
* Debugging Numerical Programs::  
* Contributors to GSL::         
* Copying::                     
* Concept Index::               
* Function Index::              
* Variable Index::              
* Type Index::                  
@end menu

@node Preliminaries, Error handling in GSL, Top, Top
@chapter Preliminaries

The GNU Scientific Library (GSL) is a collection of routines for
numerical analysis.  The routines are written from scratch by the GSL
team (@pxref{Contributors to GSL}) in C, and are meant to present a
modern Applications Programming Interface (API) for C programmers, while
allowing wrappers to be written for very high level languages.

@c Section on error handling
@node Error handling in GSL, Random number generation, Preliminaries, Top
@chapter Error handling in GSL
@cindex Errors
@include err.texi

@c Section on random number generation
@node Random number generation, Basic statistics, Error handling in GSL, Top
@chapter Random number generation
@include random.texi

@c Section on statistics
@node Basic statistics, FFTs, Random number generation, Top
@chapter Basic statistics
@cindex statistics -- basic
@cindex mean
@cindex standard deviation
@cindex variance
@cindex estimated standard deviation
@cindex estimated variance
@cindex t-test
@cindex range
@cindex min
@cindex max

The following routines were written primarily to be used for statistical
analysis of psychological experiment data.

@deftypefn Statistics double gsl_stats_dmean (double *array, int size)
@code{gsl_stats_dmean} returns the mean of an array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_imean (int *array, int size)
@code{gsl_stats_imean} returns the mean of an array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dvariance (double *array, int size)
@code{gsl_stats_dvariance} returns the variance of an array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_ivariance (int *array, int size)
@code{gsl_stats_ivariance} returns the variance of an array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dsd (double *array, int size)
@code{gsl_stats_dsd} returns the standard deviation of an array of
doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_isd (int *array, int size)
@code{gsl_stats_isd} returns the standard deviation of an array of
integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dest_variance (double *array, int size)
@code{gsl_stats_dest_variance} returns the estimated variance for an
array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_iest_variance (int *array, int size)
@code{gsl_stats_iest_variance} returns the estimated variance for an
array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dest_sd (double *array, int size);
@code{gsl_stats_dest_sd} returns the estimated standard deviation of an
array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_iest_sd (int *array, int size)
@code{gsl_stats_iest_sd} returns the estimated standard deviation of an
array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_ddpvariance (double *array1, double *array2, int size1, int size2)
@code{gsl_stats_ddpvariance} returns the pooled variance of two arrays
of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_ipvariance (int *array1, int *array2, int size1, int size2)
@code{gsl_stats_ipvariance} returns the pooled variance of two arrays of
integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dttest (double *array1, double *array2, int size1, int size2);
@code{gsl_stats_dttest} returns the t statistic from two arrays of
doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_ittest (int *array1, int *array2, int size1, int size2);
@code{gsl_stats_ittest} returns the t statistic from two arrays of
integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dmax (double *array1, int size);
@code{gsl_stats_dmax} returns the highest number in an array of doubles.
@end deftypefn

@deftypefn Statistics int gsl_stats_imax (int *array1, int size);
@code{gsl_stats_imax} returns the highest number in an array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dmin (double *array1, int size);
@code{gsl_stats_imin} returns the lowest number in an array of doubles.
@end deftypefn

@deftypefn Statistics int gsl_stats_imin (int *array1, int size);
@code{gsl_stats_imin} returns the lowest number in an array of integers.
@end deftypefn

Here is a basic example of how to use these functions:

@smallexample
#include<stdio.h>

#include <gsl_bstats.h>

/* to compile: gcc file_name.c libgsl_statistics.a -lm */

int main()
@{
  double data[5];
  double data_variance;

  data[0] = 17.2 ;
  data[1] = 18.1 ;
  data[2] = 16.5 ;
  data[3] = 18.3 ;
  data[4] = 12.6 ;

  data_variance = gsl_stats_dmean(data, 5);
@}
@end smallexample

@c Section on FFTs
@node FFTs, Root finding, Basic statistics, Top
@chapter FFTs
@include fft.texi

@c Section on root finding
@node Root finding, Simulated annealing, FFTs, Top
@chapter Root finding
@include roots.texi

@c Section on simulated annealing
@node Simulated annealing, Debugging Numerical Programs, Root finding, Top
@chapter Simulated annealing
@cindex simulated annealing
@cindex combinatorial searches

Stochastic search techniques are used when the structure of a space is
not well understood or is not smooth, so that techniques like Newton's
method (which requires calculating Jacobian derivative matrices) cannot
be used.

In particular, these techniques are frequently used to solve
@emph{combinatorial optimization} problems, such as the traveling
salesman problem.
@cindex combinatorial optimization
@cindex optimization -- combinatorial

The basic problem layout is that we are looking for a point in the space
at which a real valued @emph{energy function} (or @emph{cost function})
is minimized.
@cindex energy function
@cindex cost function

Simulated annealing is a technique which has given good results in
avoiding local minima; it is based on the idea of taking a random walk
through the space at successively lower temperatures, where the
probability of taking a step is given by a Boltzmann distribution.

@menu
* Simulated Annealing algorithm::  
* Simulated Annealing functions::  
* Examples with Simulated Annealing::  
@end menu

@node Simulated Annealing algorithm, Simulated Annealing functions, Simulated annealing, Simulated annealing
@section Simulated Annealing algorithm


We take random walks through the problem space, looking for points with
low energies; in these random walks, the probability of taking a step is
determined by the Boltzmann distribution
@equation
p = e^@{-(E_@{i+1@} - E_i)/(kT)@}
@end equation
@noindent
if @math{E_@{i+1@} < E_i}, and @math{p = 0} when @math{E_@{i+1@} \ge
E_i}.

In other words, a step @emph{will} occur if the new energy is lower.  If
the new energy is higher, the transition can still occur, and its
likelyhood is proportional to the temperature @math{T} and inversely
proportional to the energy difference @math{E_@{i+1@} - E_i}.

The temperature @math{T} is initially set to a high value, and a random
walk is carried out at that temperature.  Then the temperature is
lowered very slightly (according to a @emph{cooling schedule}) and
another random walk is taken.
@cindex cooling schedule
@cindex schedule - cooling

This slight probability of taking a step that gives @emph{higher} energy
is what allows simulated annealing to frequently get out of local
minima.

------

An initial guess is supplied.  At each step, a point is chosen at a
random distance from the current one, where the random distance @emph{r}
is distributed according to a Boltzmann distribution
@tex
$r = \exp^{-E/kT}$.
@end tex
@ifinfo
r = e^(-E/kT).
@end ifinfo
After a few search steps using this distribution, the temperature
@emph{T} is lowered according to some scheme, for example
@tex
$T \rightarrow T/\mu_T$
@end tex
@ifinfo
T -> T/mu_T
@end ifinfo
where mu_T is slightly greater than 1.


@node Simulated Annealing functions, Examples with Simulated Annealing, Simulated Annealing algorithm, Simulated annealing
@section Simulated Annealing functions

@deftp {Simulated annealing} gsl_Efunc_t
@smallexample
typedef double (*gsl_Efunc_t) (void *xp);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_step_t
@smallexample
typedef void (*gsl_siman_step_t) (void *xp, double step_size);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_metric_t
@smallexample
typedef double (*gsl_siman_metric_t) (void *xp, void *yp);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_print_t
@smallexample
typedef void (*gsl_siman_print_t) (void *xp);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_params_t
These are the parameters that control a run of @code{gsl_siman_solve}.

@smallexample
/* this structure contains all the information needed to structure
   the search, beyond the energy function, the step function and the
   initial guess. */
struct s_siman_params @{
  int n_tries;          /* how many points to try for each step */
  int iters_fixed_T;	/* how many iterations at each temperature? */
  double step_size;	/* max step size in the random walk */
  /* the following parameters are for the Boltzmann distribution */
  double k, t_initial, mu_t, t_min;
@};

typedef struct s_siman_params gsl_siman_params_t;
@end smallexample
@end deftp


@deftypefn {Simulated annealing} void gsl_siman_solve (void *@var{x0_p}, gsl_Efunc_t @var{Ef}, gsl_siman_metric_t @var{distance}, gsl_siman_print_t @var{print_position}, size_t @var{element_size}, gsl_siman_params_t params)
Does a @emph{simulated annealing} search through a given space.  The
space is specified by providing the functions @var{Ef}, @var{distance},
@var{print_position}, @var{element_size}.

The @var{params} structure (described above) controls the run by
providing the temperature schedule and other tunable parameters to the
algorithm (@pxref{Simulated Annealing algorithm}).
p
The result (optimal point in the space) is placed in @code{*@var{x0_p}}.

If @var{print_position} is not null, a log will be printed to the screen
with the following columns:
@example
number_of_iterations temperature x x-(*x0_p) Ef(x)
@end example

If @var{print_position} is null, no information is printed to the
screen.
@end deftypefn

@node Examples with Simulated Annealing,  , Simulated Annealing functions, Simulated annealing
@section Examples with Simulated Annealing

GSL's Simulated Annealing package is clumsy, and it has to be because it
is written in C, for C callers, and tries to be polymorphic at the same
time.  But here we provide some examples which can be pasted into your
application with little change and should make things easier.

@menu
* Trivial example::             
* Traveling Salesman Problem::  
@end menu

@node Trivial example, Traveling Salesman Problem, Examples with Simulated Annealing, Examples with Simulated Annealing
@subsection Trivial example

The first example, in one dimensional cartesian space, sets up an energy
function which is a damped sine wave; this has many local minima, but
only one global minimum, somewhere between 1.0 and 1.5.  The initial
guess given is 15.5, which is several local minima away from the global
minimum.

@example
/* set up parameters for this simulated annealing run */
#define N_TRIES 200		/* how many points do we try before stepping */
#define ITERS_FIXED_T 10	/* how many iterations for each T? */
#define STEP_SIZE 10		/* max step size in random walk */
#define K 1.0			/* Boltzmann constant */
#define T_INITIAL 0.002		/* initial temperature */
#define MU_T 1.005		/* damping factor for temperature */
#define T_MIN 2.0e-6

gsl_siman_params_t params = @{N_TRIES, ITERS_FIXED_T, STEP_SIZE,
			     K, T_INITIAL, MU_T, T_MIN@};

/* now some functions to test in one dimension */
double E1(void *xp)
@{
  double x = * ((double *) xp);

  return exp(-square(x-1))*sin(8*x);
@}

double M1(void *xp, void *yp)
@{
  double x = *((double *) xp);
  double y = *((double *) yp);

  return fabs(x - y);
@}

void S1(void *xp, double step_size)
@{
  double r;
  double old_x = *((double *) xp);
  double new_x;

  r = gsl_ran_uniform();
  new_x = r*2*step_size - step_size + old_x;

  memcpy(xp, &new_x, sizeof(new_x));
@}

void P1(void *xp)
@{
  printf("%12g", *((double *) xp));
@}

int main(int argc, char *argv[])
@{
  Element x0;			/* initial guess for search */

  double x_initial = 15.5;

  gsl_siman_solve(&x_initial, E1, S1, M1, P1, sizeof(double), params);
  return 0;
@}
@end example

Here are a couple of plots that are generated by running
@code{siman_test} in the following way:
@smallexample
./siman\_test | grep -v "^#" | xyplot -xyil -y -0.88 -0.83 -d "x...y" | xyps -d > siman-test.eps
./siman\_test | grep -v "^#" | xyplot -xyil -xl "generation" -yl "energy" -d "x..y" | xyps -d > siman-energy.eps
@end smallexample

@tex
\medskip
\input epsf

% nine, eight and six point fonts
\font\ninerm=cmr9   \font\eightrm=cmr8   \font\sixrm=cmr6
\font\ninei=cmmi9   \font\eighti=cmmi8   \font\sixi=cmmi6
\font\ninesy=cmsy9  \font\eightsy=cmsy8  \font\sixsy=cmsy6
\font\ninebf=cmbx9  \font\eightbf=cmbx8  \font\sixbf=cmbx6
\font\ninett=cmtt9  \font\eighttt=cmtt8
\font\nineit=cmti9  \font\eightit=cmti8
\font\ninesl=cmsl9  \font\eightsl=cmsl8

\centerline{\epsfxsize=3.4in\epsfbox{siman-test.eps}\epsfxsize=3.4in\epsfbox{siman-energy.eps}}
\nobreak
\centerline{\nineit Example of a simulated annealing run: at higher
temperatures (early in the plot)}
\centerline{\nineit you see that the solution can fluctuate, but at
lower temperatures it converges.}
\medskip
@end tex


@node Traveling Salesman Problem,  , Trivial example, Examples with Simulated Annealing
@subsection Traveling Salesman Problem
@cindex TSP
@cindex Traveling Salesman Problem

The TSP (@emph{Traveling Salesman Problem}) is the classic combinatorial
optimization problem.  I have provided a very simple version of it,
based on the coordinates of twelve cities in the southwestern United
States.  This should maybe be called the @emph{Flying Salesman Problem},
since I am using the great-circle distance between cities, rather than
the driving distance.  Also: I assume the earth is a sphere, so I don't
use geoid distances.

The @code{gsl_siman_solve()} routine finds a route which is 3490.62
Kilometers long; this is confirmed by an exhaustive search of all
possible routes with the same initial city.

The full code can be found in @file{siman/siman_tsp.c}, but I include
here some plots generated with in the following way:
@smallexample
./siman_tsp > tsp.output
grep -v "^#" tsp.output  | xyplot -xyil -d "x................y" -lx "generation" -ly "distance" -lt "TSP -- 12 southwest cities" | xyps -d > 12-cities.eps
grep initial_city_coord tsp.output | awk '@{print $2, $3, $4, $5@}' | xyplot -xyil -lb0 -cs 0.8 -lx "longitude (- means west)" -ly "latitude" -lt "TSP -- initial-order" | xyps -d > initial-route.eps
grep final_city_coord tsp.output | awk '@{print $2, $3, $4, $5@}' | xyplot -xyil -lb0 -cs 0.8 -lx "longitude (- means west)" -ly "latitude" -lt "TSP -- final-order" | xyps -d > final-route.eps
@end smallexample


This is the output showing the initial order of the cities; longitude is
negative, since it is west and I want the plot to look like a map.
@smallexample
# initial coordinates of cities (longitude and latitude)
###initial_city_coord: -105.95 35.68 Santa Fe
###initial_city_coord: -112.07 33.54 Phoenix
###initial_city_coord: -106.62 35.12 Albuquerque
###initial_city_coord: -103.2 34.41 Clovis
###initial_city_coord: -107.87 37.29 Durango
###initial_city_coord: -96.77 32.79 Dallas
###initial_city_coord: -105.92 35.77 Tesuque
###initial_city_coord: -107.84 35.15 Grants
###initial_city_coord: -106.28 35.89 Los Alamos
###initial_city_coord: -106.76 32.34 Las Cruces
###initial_city_coord: -108.58 37.35 Cortez
###initial_city_coord: -108.74 35.52 Gallup
###initial_city_coord: -105.95 35.68 Santa Fe
@end smallexample

The optimal route turns out to be:
@smallexample
# final coordinates of cities (longitude and latitude)
###final_city_coord: -105.95 35.68 Santa Fe
###final_city_coord: -106.28 35.89 Los Alamos
###final_city_coord: -106.62 35.12 Albuquerque
###final_city_coord: -107.84 35.15 Grants
###final_city_coord: -107.87 37.29 Durango
###final_city_coord: -108.58 37.35 Cortez
###final_city_coord: -108.74 35.52 Gallup
###final_city_coord: -112.07 33.54 Phoenix
###final_city_coord: -106.76 32.34 Las Cruces
###final_city_coord: -96.77 32.79 Dallas
###final_city_coord: -103.2 34.41 Clovis
###final_city_coord: -105.92 35.77 Tesuque
###final_city_coord: -105.95 35.68 Santa Fe
@end smallexample

@tex
\input epsf

% nine, eight and six point fonts
\font\ninerm=cmr9   \font\eightrm=cmr8   \font\sixrm=cmr6
\font\ninei=cmmi9   \font\eighti=cmmi8   \font\sixi=cmmi6
\font\ninesy=cmsy9  \font\eightsy=cmsy8  \font\sixsy=cmsy6
\font\ninebf=cmbx9  \font\eightbf=cmbx8  \font\sixbf=cmbx6
\font\ninett=cmtt9  \font\eighttt=cmtt8
\font\nineit=cmti9  \font\eightit=cmti8
\font\ninesl=cmsl9  \font\eightsl=cmsl8

\medskip
\centerline{\epsfxsize=3in\epsfbox{initial-route.eps}\epsfxsize=3in\epsfbox{final-route.eps}}
\nobreak
\centerline{\nineit Initial and final (optimal?) route for the 12
southwestern cities Flying Salesman Problem.}
\medskip
@end tex

Here's a plot of the cost function (energy) versus generation (point in
the calculation at which a new temperature is set) for this problem:

@tex
\input epsf

% nine, eight and six point fonts
\font\ninerm=cmr9   \font\eightrm=cmr8   \font\sixrm=cmr6
\font\ninei=cmmi9   \font\eighti=cmmi8   \font\sixi=cmmi6
\font\ninesy=cmsy9  \font\eightsy=cmsy8  \font\sixsy=cmsy6
\font\ninebf=cmbx9  \font\eightbf=cmbx8  \font\sixbf=cmbx6
\font\ninett=cmtt9  \font\eighttt=cmtt8
\font\nineit=cmti9  \font\eightit=cmti8
\font\ninesl=cmsl9  \font\eightsl=cmsl8

\medskip
\centerline{\epsfxsize=4.4in\epsfbox{12-cities.eps}}
\nobreak
\centerline{\nineit Example of a simulated annealing run for the 12}
\centerline{\nineit southwestern cities Flying Salesman Problem.}
\medskip
@end tex


@node Debugging Numerical Programs, Contributors to GSL, Simulated annealing, Top
@appendix Debugging Numerical Programs


@node Contributors to GSL, Copying, Debugging Numerical Programs, Top
@appendix Contributors to GSL

@table @strong
@item Mark Galassi
Conceived GSL (with James Theiler) and wrote the design document.  Wrote
the simulated annealing package and the relevant chapter in the manual.

@item James Theiler
Conceived GSL (with Mark Galassi).  Wrote the random number generators
and the relevant chapter in this manual.

@item Jim Davies
Wrote the basic statistical routines and the relevant chapter in this
manual.

@item Brian Gough
Wrote the FFT package and the relevant chapter in this manual.

@item Reid Priedhorsky
Wrote the root finding package and the relevant chapter in this manual.

@end table


@node Copying, Concept Index, Contributors to GSL, Top
@appendix Copying

   The subroutines and source code in the @value{GSL} package are "free";
this means that everyone is free to use them and free to redistribute
them on a free basis.  The @value{GSL}-related programs are not in the
public domain; they are copyrighted and there are restrictions on their
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of these
programs that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the programs that relate to @value{GSL}, that you receive
source code or else can get it if you want it, that you can change these
programs or use pieces of them in new free programs, and that you know
you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the @value{GSL}-related code, you must give the recipients all
the rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for the programs that relate to
@value{GSL}.  If these programs are modified by someone else and passed
on, we want their recipients to know that what they have is not what we
distributed, so that any problems introduced by others will not reflect
on our reputation.

   The precise conditions of the licenses for the programs currently
being distributed that relate to @value{GSL} are found in the General
Public Licenses that accompany them.

@node Concept Index, Function Index, Copying, Top
@unnumbered Concept Index

@printindex cp

@node Function Index, Variable Index, Concept Index, Top
@unnumbered Function Index

@printindex fn

@node Variable Index, Type Index, Function Index, Top
@unnumbered Variable Index

@printindex vr

@node Type Index,  , Variable Index, Top
@unnumbered Type Index

@printindex tp

@c @shortcontents
@contents
@bye
