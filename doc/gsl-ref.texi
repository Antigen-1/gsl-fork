\input texinfo @c -*-texinfo-*-

@c %**start of header
@setfilename gsl-ref.info
@settitle GNU Scientific Library -- Reference Manual
@finalout
@c @setchapternewpage odd
@c %**end of header

@dircategory Scientific software
@direntry
* gsl-ref: (gsl-ref).                   GNU Scientific Library -- Reference
@end direntry

@include version-ref.texi
@set GSL @emph{GNU Scientific Library}

@ifinfo
This file documents the @value{GSL}.

Copyright (C) 1996 The GSL Project.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end ifinfo

@titlepage
@title GNU Scientific Library -- Reference Manual
@subtitle Edition @value{EDITION}, for gsl Version @value{VERSION}
@subtitle @value{UPDATED}
@author Mark Galassi @footnote{Space Data Systems group, Los Alamos National Laboratory}
@author @email{rosalia@@nis.lanl.gov}
@author
@author Jim Davies @footnote{Space Data Systems Group, Los Alamos National Laboratory and Department of Computer Science, Georgia Institute of Technology}
@author @email{jimmyd@@nis.lanl.gov}
@author
@author James Theiler @footnote{Astrophysics and Radiation Measurements group, Los Alamos National Laboratory}
@author @email{jt@@nis.lanl.gov}
@author
@author Brian Gough @footnote{Theoretical Particle Physics group, Los Alamos National Laboratory}
@author @email{bjg@@vvv.lanl.gov}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1996,1997 The GSL Project.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end titlepage

@ifinfo
@node Top, Preliminaries, (dir), (dir)
@top GSL
@end ifinfo

@ifinfo
This file documents the the @value{GSL}, a collection of numerical
routines for scientific computing.

As of @value{UPDATED}, the only complete packages are the random number
suite (@pxref{Random number generation}) and the FFT package
(@pxref{FFTs}).
@end ifinfo


@menu
* Preliminaries::               
* Error handling in GSL::       
* Random number generation::    
* Basic statistics::                  
* FFTs::                        
* Root finding::                
* Simulated annealing::         
* Contributors to GSL::         
* Copying::                     
* Concept Index::               
* Function Index::              
* Variable Index::              
* Type Index::                  
@end menu

@node Preliminaries
@chapter Preliminaries

The GNU Scientific Library (GSL) is a collection of routines for
numerical analysis.  The routines are written from scratch by the GSL
team (@pxref{Contributors to GSL}) in C, and are meant to present a
modern Applications Programming Interface (API) for C programmers, while
allowing wrappers to be written for very high level languages.

@node Error handling in GSL
@chapter Error handling in GSL



@node Random number generation
@chapter Random number generation
@include random.texi

@node Basic statistics
@chapter Basic statistics
@cindex statistics -- basic
@cindex mean
@cindex standard deviation
@cindex variance
@cindex estimated standard deviation
@cindex estimated variance
@cindex t-test
@cindex range
@cindex min
@cindex max

The following routines were written primarily to be used for statistical
analysis of psychological experiment data.

@deftypefn Statistics double gsl_stats_dmean (double *array, int size)
@code{gsl_stats_dmean} returns the mean of an array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_imean (int *array, int size)
@code{gsl_stats_imean} returns the mean of an array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dvariance (double *array, int size)
@code{gsl_stats_dvariance} returns the variance of an array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_ivariance (int *array, int size)
@code{gsl_stats_ivariance} returns the variance of an array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dsd (double *array, int size)
@code{gsl_stats_dsd} returns the standard deviation of an array of
doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_isd (int *array, int size)
@code{gsl_stats_isd} returns the standard deviation of an array of
integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dest_variance (double *array, int size)
@code{gsl_stats_dest_variance} returns the estimated variance for an
array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_iest_variance (int *array, int size)
@code{gsl_stats_iest_variance} returns the estimated variance for an
array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dest_sd (double *array, int size);
@code{gsl_stats_dest_sd} returns the estimated standard deviation of an
array of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_iest_sd (int *array, int size)
@code{gsl_stats_iest_sd} returns the estimated standard deviation of an
array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_ddpvariance (double *array1, double *array2, int size1, int size2)
@code{gsl_stats_ddpvariance} returns the pooled variance of two arrays
of doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_ipvariance (int *array1, int *array2, int size1, int size2)
@code{gsl_stats_ipvariance} returns the pooled variance of two arrays of
integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dttest (double *array1, double *array2, int size1, int size2);
@code{gsl_stats_dttest} returns the t statistic from two arrays of
doubles.
@end deftypefn

@deftypefn Statistics double gsl_stats_ittest (int *array1, int *array2, int size1, int size2);
@code{gsl_stats_ittest} returns the t statistic from two arrays of
integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dmax (double *array1, int size);
@code{gsl_stats_dmax} returns the highest number in an array of doubles.
@end deftypefn

@deftypefn Statistics int gsl_stats_imax (int *array1, int size);
@code{gsl_stats_imax} returns the highest number in an array of integers.
@end deftypefn

@deftypefn Statistics double gsl_stats_dmin (double *array1, int size);
@code{gsl_stats_imin} returns the lowest number in an array of doubles.
@end deftypefn

@deftypefn Statistics int gsl_stats_imin (int *array1, int size);
@code{gsl_stats_imin} returns the lowest number in an array of integers.
@end deftypefn

Here is a basic example of how to use these functions:

@smallexample
#include<stdio.h>

#include <gsl_bstats.h>

/* to compile: gcc file_name.c libgsl_statistics.a -lm */

int main()
@{
  double data[5];
  double data_variance;

  data[0] = 17.2 ;
  data[1] = 18.1 ;
  data[2] = 16.5 ;
  data[3] = 18.3 ;
  data[4] = 12.6 ;

  data_variance = gsl_stats_dmean(data, 5);
@}
@end smallexample

@c Section on FFTs
@node FFTs
@chapter FFTs
@include fft.texi

@node Root finding
@chapter Root finding
@cindex root finding
@cindex Newton's Method

[contributed by Mark Galassi]

There is a program @code{rtest} which does sample runs of many of these
routines.

@section Newton's method

This is a half-assed implementation of Newton's method, meant mostly as
an example for the GSL coding conventions.

The epsilon value is static, and can be set and verified with:

@deftypefn {Root finding} void gsl_set_newton_epsilon (double new_val)
@deftypefnx {Root finding} double gsl_get_newton_epsilon ()
Sets and gets the epsilon value used in Newton's method.
@end deftypefn


@deftypefn {Root finding} double gsl_newton1D (double (*fn)(double x), double (*dfn)(double x), double guess)
Uses Newton's method to find a root of the function @var{fn}, starting
at @var{guess}.  User has to supply both the function @var{fn} and its
first derivative @var{dfn}.

Example: @code{gsl_newton1D(sin, cos, 2.3)}
@end deftypefn



@node Simulated annealing
@chapter Simulated annealing
@cindex simulated annealing
@cindex combinatorial searches

Stochastic search techniques are used when the structure of a space is
not well understood or is not smooth, so that techniques like Newton's
method (which requires calculating Jacobian derivative matrices) cannot
be used.

Simulated annealing is a stochastic search technique which has shown
good results in avoiding local minima; it is based on the idea of a
@emph{cooling schedule} for the size of random steps which are taken.
@cindex cooling schedule
@cindex schedule - cooling

An initial guess is supplied.  At each step, a point is chosen at a
random distance from the current one, where the random distance @emph{r}
is distributed according to a Boltzmann distribution
@tex
$r = \exp^{-E/kT}$.
@end tex
@ifinfo
r = e^(-E/kT).
@end ifinfo
After a few search steps using this distribution, the temperature
@emph{T} is lowered according to some scheme, for example
@tex
$T \rightarrow T/\mu_T$
@end tex
@ifinfo
T -> T/mu_T
@end ifinfo
where mu_T is slightly greater than 1.

@menu
* Simulated Annealing algorithm::  
* Simulated Annealing functions::  
* Examples with Simulated Annealing::  
@end menu

@node Simulated Annealing algorithm
@section Simulated Annealing algorithm

@node Simulated Annealing functions
@section Simulated Annealing functions

@deftp {Simulated annealing} gsl_Efunc_t
@smallexample
typedef double (*gsl_Efunc_t) (void *xp);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_step_t
@smallexample
typedef void (*gsl_siman_step_t) (void *xp, double step_size);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_metric_t
@smallexample
typedef double (*gsl_siman_metric_t) (void *xp, void *yp);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_print_t
@smallexample
typedef void (*gsl_siman_print_t) (void *xp);
@end smallexample
@end deftp

@deftp {Simulated annealing} gsl_siman_params_t
These are the parameters that control a run of @code{gsl_siman_solve}.

@smallexample
/* this structure contains all the information needed to structure
   the search, beyond the energy function, the step function and the
   initial guess. */
struct s_siman_params @{
  int n_tries;          /* how many points to try for each step */
  int iters_fixed_T;	/* how many iterations at each temperature? */
  double step_size;	/* max step size in the random walk */
  /* the following parameters are for the Boltzmann distribution */
  double k, t_initial, mu_t, t_min;
@};

typedef struct s_siman_params gsl_siman_params_t;
@end smallexample
@end deftp


@deftypefn {Simulated annealing} void gsl_siman_solve (void *@var{x0_p}, gsl_Efunc_t @var{Ef}, gsl_siman_metric_t @var{distance}, gsl_siman_print_t @var{print_position}, size_t @var{element_size}, gsl_siman_params_t params)
Does a @emph{simulated annealing} search through a given space.  The
space is specified by providing the functions @var{Ef}, @var{distance},
@var{print_position}, @var{element_size}.

The @var{params} structure (described above) controls the run by
providing the temperature schedule and other tunable parameters to the
algorithm (@pxref{Simulated Annealing algorithm}).
p
The result (optimal point in the space) is placed in @code{*@var{x0_p}}.

If @var{print_position} is not null, a log will be printed to the screen
with the following columns:
@example
number_of_iterations temperature x x-(*x0_p) Ef(x)
@end example

If @var{print_position} is null, no information is printed to the
screen.
@end deftypefn

@node Examples with Simulated Annealing
@section Examples with Simulated Annealing

GSL's Simulated Annealing package is clumsy, and it has to be because it
is written in C, for C callers, and tries to be polymorphic at the same
time.  But here we provide some examples which can be pasted into your
application with little change and should make things easier.

The first example, in one dimensional cartesian space, sets up an energy
function which is a damped sine wave; this has many local minima, but
only one global minimum, somewhere between 1.0 and 1.5.  The initial
guess given is 15.5, which is several local minima away from the global
minimum.

@example
/* set up parameters for this simulated annealing run */
#define N_TRIES 200		/* how many points do we try before stepping */
#define ITERS_FIXED_T 10	/* how many iterations for each T? */
#define STEP_SIZE 10		/* max step size in random walk */
#define K 1.0			/* Boltzmann constant */
#define T_INITIAL 0.002		/* initial temperature */
#define MU_T 1.005		/* damping factor for temperature */
#define T_MIN 2.0e-6

gsl_siman_params_t params = @{N_TRIES, ITERS_FIXED_T, STEP_SIZE,
			     K, T_INITIAL, MU_T, T_MIN@};

/* now some functions to test in one dimension */
double E1(void *xp)
@{
  double x = * ((double *) xp);

  return exp(-square(x-1))*sin(8*x);
@}

double M1(void *xp, void *yp)
@{
  double x = *((double *) xp);
  double y = *((double *) yp);

  return fabs(x - y);
@}

void S1(void *xp, double step_size)
@{
  double r;
  double old_x = *((double *) xp);
  double new_x;

  r = gsl_ran_uniform();
  new_x = r*2*step_size - step_size + old_x;

  memcpy(xp, &new_x, sizeof(new_x));
@}

void P1(void *xp)
@{
  printf("%12g", *((double *) xp));
@}

int main(int argc, char *argv[])
@{
  Element x0;			/* initial guess for search */

  double x_initial = 15.5;

  gsl_siman_solve(&x_initial, E1, S1, M1, P1, sizeof(double), params);
  return 0;
@}
@end example

@tex
\input epsf

% nine, eight and six point fonts
\font\ninerm=cmr9   \font\eightrm=cmr8   \font\sixrm=cmr6
\font\ninei=cmmi9   \font\eighti=cmmi8   \font\sixi=cmmi6
\font\ninesy=cmsy9  \font\eightsy=cmsy8  \font\sixsy=cmsy6
\font\ninebf=cmbx9  \font\eightbf=cmbx8  \font\sixbf=cmbx6
\font\ninett=cmtt9  \font\eighttt=cmtt8
\font\nineit=cmti9  \font\eightit=cmti8
\font\ninesl=cmsl9  \font\eightsl=cmsl8

\centerline{\epsfxsize=5in\epsfbox{siman-test.eps}}
%\centerline{\epsfxsize=5in\epsfbox{siman-point.eps}}
\nobreak
\centerline{\nineit Example of a simulated annealing run: at higher
temperatures (early in the plot)}
\centerline{\nineit you see that the solution can fluctuate, but at
lower temperatures it converges.}
\centerline{\nineit This was generated with the simple instruction:}
\centerline{\eighttt gnuplot> plot '<../siman/siman\_test | grep -v "\^{}\#"' using 1:3 with lines}

\medskip

\centerline{\epsfxsize=5in\epsfbox{siman-energy.eps}}
\nobreak
\centerline{\nineit The energy value versus iteration for the above
run. This was generated with the simple instruction}
\centerline{\eighttt gnuplot> plot '<../siman/siman\_test | grep -v "\^{}\#"' using 1:3 with lines}
\smallskip
@end tex


@node Contributors to GSL
@appendix Contributors to GSL

@table @strong
@item Mark Galassi
Conceived GSL (with James Theiler) and wrote the design document.  Wrote
the simulated annealing package and the relevant chapter in the manual.

@item James Theiler
Conceived GSL (with Mark Galassi).  Wrote the random number generators
and the relevant chapter in this manual.

@item Jim Davies
Wrote the basic statistical routines and the relevant chapter in this
manual.

@item Brian Gough
Wrote the FFT package and the relevant chapter in this manual.

@end table


@node Copying
@appendix Copying

   The subroutines and source code in the @value{GSL} package are "free";
this means that everyone is free to use them and free to redistribute
them on a free basis.  The @value{GSL}-related programs are not in the
public domain; they are copyrighted and there are restrictions on their
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of these
programs that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the programs that relate to @value{GSL}, that you receive
source code or else can get it if you want it, that you can change these
programs or use pieces of them in new free programs, and that you know
you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the @value{GSL}-related code, you must give the recipients all
the rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for the programs that relate to
@value{GSL}.  If these programs are modified by someone else and passed
on, we want their recipients to know that what they have is not what we
distributed, so that any problems introduced by others will not reflect
on our reputation.

   The precise conditions of the licenses for the programs currently
being distributed that relate to @value{GSL} are found in the General
Public Licenses that accompany them.

@node Concept Index
@unnumbered Concept Index

@printindex cp

@node Function Index
@unnumbered Function Index

@printindex fn

@node Variable Index
@unnumbered Variable Index

@printindex vr

@node Type Index
@unnumbered Type Index

@printindex tp

@c @shortcontents
@contents
@bye
