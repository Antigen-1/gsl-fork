@node Low Level Root Finding Functions
@section Low Level Root Finding Functions
@cindex root finding, low level functions

GSL provides several low level root finding functions which are more
complicated to use than the high level function but provide more
control. The following
@iftex
subsections
@end iftex
@ifinfo
nodes
@end ifinfo
explain how to use low level root finding functions.

Low level functions return errors and roots and are provided functions
to search in the same manner as the high level functions; see @ref{Root
Finder Exit Values}, and @ref{Providing the Function to Search},
respectively.

@menu
* Search Bounds and Guesses::   How to tell GSL where to search
* Search Stopping Parameters::  How to tell GSL when to stop searching
* Bisection::                   GSL's implementation of bisection
* False Position::              GSL's implementation of false position
* Secant Method::               GSL's implementation of secant method
* Newtons Method::              GSL's implementation of Newton's Method
@end menu


@node Search Bounds and Guesses
@subsection Search Bounds and Guesses
@cindex root finding, search bounds
@cindex root finding, guess(es)

When using low level functions, you can specify and monitor the region
being searched more precisely than you can when using high level
functions. You provide either search bounds or one or two guesses; this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
explains how search bounds and guesses work and how function arguments
control them.

Search bounds are the endpoints of the search interval which is iterated
smaller and smaller until the length of the interval is smaller than the
requested precision or one of the endpoints converges; a guess is an
@math{x} value which is iterated around until the it is within the
desired precision of a root. Two guesses behave similarly to one; there
are just two @math{x} values wandering about instead of one.

In low level functions, these arguments are defined as pointers to
@code{double} rather than simply @code{double}s for two reasons. First,
if the root finding function fails, it is very useful to have the final
values of your iterated variables available to help diagnose why it
failed. Second, it makes it possible to preserve the state of the root
finder, enabling it to be restarted in the same place if needed. A
situation where this could be useful is if the function under search is
very costly to evaluate. Pretend, for a moment, that you want to find a
root of a function which takes several minutes to evaluate. Your program
could chug away for a few iterations, then examine your mailbox to see
if the number of flames about bogging down the machine is above a
certain threshold. If it isn't, chug away for a few more iterations and
repeat the process; if it is, depending on your temperament, your
program could renice itself to a lower priority and mail back apologies
before continuing, or it could mailbomb everyone who complained, spawn
copies of itself endlessly, and dump garbage to @w{@file{/dev/audio}}.
(The latter approach is not recommended.)

Note that these arguments must be valid pointers; GSL root finders will
not allocate any memory for you.

@deftypevr {Low Level Function Argument} {double *} lower_bound
@deftypevrx {Low Level Function Argument} {double *} upper_bound
@vindex @r{root finding,} lower_bound @r{(low level function argument)}
@vindex @r{root finding,} upper_bound @r{(low level function argument)}
The initial upper and lower bounds of the interval in which to search for a
root. @w{@code{lower_bound}} must be less than @w{@code{upper_bound}}.

These arguments are modified during execution of the root finding
function; if you need to preserve their initial values, you must make
copies of them. See the third paragraph of this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
for the reasoning behind this behavior.

@end deftypevr

@deftypevr {Low Level Function Argument} {double *} guess
@deftypevrx {Low Level Function Argument} {double *} guess2
@vindex @r{root finding,} guess @r{(low level function argument)}
@vindex @r{root finding,} guess2 @r{(low level function argument)}
One or two initial values for the guess(es) iterated by the root finding
function.

These arguments are modified during execution of the root finding
function; if you need to preserve their initial values, you must make
copies of them. See the third paragraph of this
@iftex
subsection
@end iftex
@ifinfo
node
@end ifinfo
for the reasoning behind this behavior.

@end deftypevr


@node Search Stopping Parameters
@subsection Search Stopping Parameters
@cindex root finding, stopping parameters

@strong{FIXME: clean up this section and add documentation for
max_deltay.}

GSL root finding functions (and numerical root finding functions in
general) stop when one of the following conditions is true:

@itemize @bullet
@item
A root has been found to within the user-specified precision.

@item
A user-specified maximum number of iterations has executed.

@item
An error has occured.
@end itemize

Whenever you call a low level GSL root finding function, you must
specify precisely absolute and/or relative tolerances and the maximum
number of iterations.

GSL decides that two values @math{a} and @math{b}. with relative
tolerance @math{R} and absolute tolerance @math{A}, are close enough if
the following relation is true:

@equation
|a - b| \leq R \min(|a|,|b|) + A 
@end equation

You can set either @math{R} or @math{A} to zero, but be aware that GSL
will signal an error if the search moves into an area where both
@math{R} and @math{A} are meaningless; assuming @math{a} and @math{b}
are the endpoints of the region of interest, the following must be true
or GSL will signal an error:

@equation
R \min(|a|,|b|) + A \geq 10 \max(|a|,|b|) \times @{\tt DBL\_EPSILON@} 
@end equation

(We introduce a buffer of @math{10} to protect against roundoff error.)

For the sake of efficient resource use, do not ask for more precision
than you need, especially if your function is costly to evaluate.

@deftypevr {Low Level Function Argument} double abs_epsilon
@vindex @r{root finding,} abs_epsilon @r{(low level function argument)}
The maximum permissible absolute error in GSL root finder answers.

The only static limit on @w{@code{abs_epsilon}} is that it must be
positive; see above for other restrictions, however.
@end deftypevr

@deftypevr {Low Level Function Argument} double rel_epsilon
@vindex @r{root finding,} rel_epsilon @r{(low level function argument)}
The maximum permissible relative error in GSL root finder answers.

@w{@code{rel_epsilon}} must be greater than or equal to @math{@{\tt
DBL\_EPSILON@} \times 10} (note the buffer factor to protect against
roundoff error). See above for additional non-static restrictions.
@end deftypevr

@deftypevr {Function Argument} {unsigned int} max_iterations
@vindex @r{root finding,} max_iterations @r{(function argument)}
The maximum number of iterations a root finder is allowed to perform.
This must be greater than or equal to 1, as performing a negative number
of iterations is extremely difficult and not doing any iterations is
rather useless.

Do not set @w{@code{max_iterations}} too large. If there is a problem,
you want to know about it as soon as possible; you don't want your
program chugging away for many cycles in error.
@end deftypevr

In addition, GSL root finding functions which extrapolate (Newton's
Method, (@ref{Newtons Method}, and Secant Method, @ref{Secant Method})
accept an additional argument:

@deftypevr {Function Argument} double max_step_size
@vindex @r{root finding,} max_step_size @r{(function argument)}
The maximum step size an extrapolating algorithm is allowed to take.
This is to prevents the algorithm from landing on a place where the test
function's derivative is very small and zooming off to infinity or into
a different solution basin.

@strong{FIXME: talk about minimum value for max_step_size.}

For example, if while solving @math{\sin(x) = 0}, @math{x_n} of Newton's
Method (@pxref{Newtons Method}) landed on @math{1.570700000}
(@math{\pi/2 \approx 1.570796327}), then @math{x_@{n+1@}}
would be approximately @math{-10000}, which is definitely not what we
wanted! We want the root finder to recognize this step as ``too big''
and flag an error.

The alarm bell will ring if the following relation in true:

@equation
|@{@{d@} \over @{dx@}@} f(x)| < |@{@{f(x)@} \over @{\tt max\_step\_size@}@}|
@end equation
@noindent
Note that while Secant Method (@pxref{Secant Method}) does not deal with
derivatives directly, when extrapolating it approximates them
numerically.

Do not set @w{@code{max_step_size}} too large; that will defeat its
purpose. In the @math{\sin(x) = 0} example, @math{\pi} would be a good
value for @w{@code{max_step_size}}; any step larger than that would
certainly be headed astray. A good understanding of the problem is
especially important for @w{@code{max_step_size}}.
@end deftypevr


@node Bisection
@subsection Bisection
@cindex bisection algorithm for finding roots
@cindex root finding, bisection algorithm

Bisection is a simple and robust method of finding roots of a function
@math{f}; when its arguments are valid, it cannot fail. However, it is
the slowest algorithm implemented by GSL, and it cannot find roots of
even degree. Its convergence is linear.

One begins the algorithm with an interval which is guaranteed by the
Intermediate Value Theorem to contain a root: where @math{a} and
@math{b} are the endpoints of the interval, @math{f(a)} must differ in
sign from @math{f(b)}. (If you're a bit fuzzy on the Intermediate Value
Theorem, consult any elementary calculus textbook.)

Each iteration, bisection chops its interval in half and discards the
interval which does not contain a root. Once the interval is smaller
than the requested epsilon, iteration stops and the root location is
returned.

@c eps file "roots-bisection.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-bisection.eps}}
@end tex
@quotation
Four iterations of bisection, where @math{a_n} is @math{n}th position of
the beginning of the interval and @math{b_n} is the @math{n}th position
of the end. The midpoint of each interval is also indicated.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
bisection.)
@end ifinfo

@deftypefun int gsl_root_bisection (@w{double * @var{root}}, @w{double (* @var{f})(double)}, @w{double * @var{lower_bound}}, @w{double * @var{upper_bound}}, @w{double @var{rel_epsilon}}, @w{double @var{abs_epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_deltay}})
@findex @r{root finding,} gsl_root_bisection

Search for a zero of @code{f} using bisection. Returns @code{0} if
successful, @code{-1} on error (@pxref{Root Finder Error
Handling}).

@code{f(*lower_bound)} and @code{f(*upper_bound)} must differ in sign.

Arguments:
@table @code
@item root
A place to store the root location once it is found. @xref{Root Finder
Exit Values}.
@item f
A user defined function to search for a root. @xref{Providing the
Function to Search}.
@item lower_bound@r{, }upper_bound
Lower and upper bounds of the interval to search. @xref{Search Bounds
and Guesses}.
@item rel_epsilon@r{, }abs_epsilon
Maximum permitted relative and absolute error. @xref{Search Stopping
Parameters}.
@item max_iterations
The maximum allowed number of iterations. @xref{Search Stopping
Parameters}.
@item max_deltay
The maximum allowed difference between @w{@code{f(*lower_bound)}} and
@w{@code{f(*upper_bound)}}. @xref{Search Stopping Parameters}.
@end table

@end deftypefun


@node False Position
@subsection False Position
@cindex false position algorithm for finding roots
@cindex root finding, false position algorithm

False position is a robust method of finding roots of a function
@math{f}; if its arguments are valid, it cannot fail. However, it cannot
find roots of even degree. Its convergence is linear, but it is usually
faster than bisection.

One begins the algorithm with an interval which is guaranteed by the
Intermediate Value Theorem to contain a root: where @math{a} and
@math{b} are the endpoints of the interval, @math{f(a)} must differ in
sign from @math{f(b)}. (If you're a bit fuzzy on the Intermediate Value
Theorem, consult any elementary calculus textbook.)

Each iteration, false position draws a line between @math{f(a)} and
@math{f(b)}; the @math{x} position where this line crosses the @math{x}
axis is where the interval is split. The part of the interval which
contains the root is taken to be the new interval, and the process is
repeated until one of the following is true:

@equation
|a - b| \leq \varepsilon
@end equation
@equation
a_n - a_@{n-1@} = 0 \;\;\;@{\rm and@}\;\;\; |b_n - b_@{n-1@}| \leq \varepsilon
@end equation
@equation
b_n - b_@{n-1@} = 0 \;\;\;@{\rm and@}\;\;\;|a_n - a_@{n-1@}| \leq \varepsilon
@end equation

@c eps file "roots-false-position.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-false-position.eps}}
@end tex
@quotation
Several iterations of false position, where @math{a_n} is @math{n}th
position of the beginning of the interval and @math{b_n} is the
@math{n}th position of the end.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
false position.)
@end ifinfo

@deftypefun int gsl_root_falsepos (@w{double * @var{root}}, @w{double (* @var{f})(double)}, @w{double * @var{lower_bound}}, @w{double * @var{upper_bound}}, @w{double @var{rel_epsilon}}, @w{double @var{abs_epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_deltay}})
@findex @r{root finding,} gsl_root_falsepos

Search for a zero of @code{f} using false position. Return @code{0} if
successful, @code{-1} on error (@pxref{Root Finder Error Handling}.

@code{f(*lower_bound)} and @code{f(*upper_bound)} must differ in sign.

Arguments:
@table @code
@item root
A place to store the root location once it is found. @xref{Root Finder
Exit Values}.
@item f
A user defined function to search for a root. @xref{Providing the
Function to Search}.
@item lower_bound@r{, }upper_bound
Lower and upper bounds of the interval to search. @xref{Search Bounds
and Guesses}.
@item rel_epsilon@r{, }abs_epsilon
Maximum permitted relative and absolute error. @xref{Search Stopping
Parameters}.
@item max_iterations
The maximum allowed number of iterations. @xref{Search Stopping
Parameters}.
@item max_deltay
The maximum allowed difference between @w{@code{f(*lower_bound)}} and
@w{@code{f(*upper_bound)}}. @xref{Search Stopping Parameters}.
@end table

@end deftypefun


@node Secant Method
@subsection Secant Method
@cindex Secant Method algorithm for finding roots
@cindex root finding, Secant Method algorithm

Secant Method is a somewhat fragile method of finding roots. On single
roots, its convergence is of order @math{(1 + \sqrt 5)/2} (approximately
@math{1.62}). On multiple roots, converges linearly.

One begins the algorithm with two guesses for the value of the root,
@math{g_0} and @math{g_1}. The root may be either inside or outside the
interval defined by @math{g_0} and @math{g_1}.

Each iteration, Secant Method draws a line through @math{f(g_@{n - 1@})}
and @math{f(g_n)}. The @math{x} position where this line crosses the
@math{x} axis becomes @math{g_@{n + 1@}}. @math{g_@{n - 1@}} is
discarded, @math{n} is incremented, and the process is repeated until:

@equation
|g_n - g_@{n-1@}| \leq \varepsilon
@end equation

Note that @math{g_@{n + 1@}} may be obtained by either interpolation or
extrapolation and that Secant Method cannot fail during interpolation.

Secant Method breaks in the same situations that Newton's Method does,
though it is somewhat less sensitive. (@xref{Newtons Method}.)

@c eps file "roots-secant-method.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-secant-method.eps}}
@end tex
@quotation
Several iterations of Secant Method, where @math{g_n} is the @math{n}th
guess.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
Secant Method.)
@end ifinfo

@deftypefun int gsl_root_secant (@w{double * @var{root}}, @w{double (* @var{f})(double)}, @w{double * @var{guess}}, @w{double * @var{guess2}}, @w{double @var{epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_step_size}})
@findex @r{root finding,} gsl_root_secant

Search for a zero of @code{f} using Secant Method, with @code{*guess}
and @code{*guess2} being the guesses.

arguments. @xref{Root Finder Error Handling}, for a discussion of possible
error codes.

@end deftypefun


@node Newtons Method
@subsection Newtons Method
@cindex Newton's Method algorithm for finding roots
@cindex root finding, Newton's Method algorithm

Newton's Method is a fast but somewhat fragile method of finding roots.
On single roots, it converges quadratically; however, on multiple roots
it converges linearly.

One begins the algorithm with one guess @math{g} for the value of the
root. Each iteration, Newton's Method draws a line tangent to @math{f}
(the function whose root you are searching for); the @math{x} position
where this line crosses the @math{x} axis becomes the new @math{g}. The
process is repeated until:

@equation
|g_n - g_@{n-1@}| \leq \varepsilon
@end equation

@strong{FIXME: talk about ways to break Newton.}

This algorithm is entirely unrelated to Newt Gingrich.

@c eps file "roots-newtons-method.eps"
@iftex
@tex
\input epsf
\medskip
\centerline{\epsfbox{roots-newtons-method.eps}}
@end tex
@quotation
Several iterations of Newton's Method, where @math{g_n} is the
@math{n}th guess.
@end quotation
@end iftex
@ifinfo
(Often, root finding algorithms are better explained geometrically. The
@TeX{} version of this documentation contains an image illustrating
Newton's Method.)
@end ifinfo

@deftypefun int gsl_root_newton (@w{double * @var{root}}, @w{void (* @var{fdf})(double *, double *, double, int, int)}, @w{double * @var{guess}}, @w{double @var{epsilon}}, @w{unsigned int @var{max_iterations}}, @w{double @var{max_step_size}})
@findex @r{root finding,} gsl_root_newton

Search for a zero of @code{f} using Newton's Method, with @code{*guess}
being the guess.

@xref{Root Finder Error Handling}, for a discussion of possible
error codes.

@end deftypefun
