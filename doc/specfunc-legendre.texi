@comment
@node Legendre Functions and Spherical Harmonics
@section Legendre Functions and Spherical Harmonics
@cindex Legendre functions
@cindex spherical harmonics
@cindex conical functions
@cindex hyperbolic space


@subsection Legendre Polynomials

@deftypefun double gsl_sf_legendre_P1 (double @var{x})
@deftypefunx double gsl_sf_legendre_P2 (double @var{x})
@deftypefunx double gsl_sf_legendre_P3 (double @var{x})
@deftypefunx int gsl_sf_legendre_P1_e (double @var{x}, gsl_sf_result * @var{result})
@deftypefunx int gsl_sf_legendre_P2_e (double @var{x}, gsl_sf_result * @var{result})
@deftypefunx int gsl_sf_legendre_P3_e (double @var{x}, gsl_sf_result * @var{result})
P_l(x), l=1,2,3
@comment Exceptional Return Values: none
@end deftypefun


@deftypefun double gsl_sf_legendre_Pl (int @var{l}, double @var{x})
@deftypefunx int gsl_sf_legendre_Pl_e (int @var{l}, double @var{x}, gsl_sf_result * @var{result})
P_l(x)   l >= 0; |x| <= 1
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun

@deftypefun int gsl_sf_legendre_Pl_array (int @var{lmax}, double @var{x}, double * @var{result_array})
P_l(x) for l=0,...,lmax; |x| <= 1
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun

@deftypefun double gsl_sf_legendre_Q0 (double @var{x})
@deftypefunx int gsl_sf_legendre_Q0_e (double @var{x}, gsl_sf_result * @var{result})
Q_0(x), x > -1, x != 1
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_legendre_Q1 (double @var{x})
@deftypefunx int gsl_sf_legendre_Q1_e (double @var{x}, gsl_sf_result * @var{result})
Q_1(x), x > -1, x != 1
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun

@deftypefun double gsl_sf_legendre_Ql (int @var{l}, double @var{x})
@deftypefunx int gsl_sf_legendre_Ql_e (int @var{l}, double @var{x}, gsl_sf_result * @var{result})
Q_l(x), x > -1, x != 1, l >= 0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@subsection Associated Legendre Polynomials and Spherical Harmonics

P_l^m(x)  m >= 0; l >= m; |x| <= 1.0

Note that this function grows combinatorially with l.
Therefore we can easily generate an overflow for l larger
than about 150.

There is no trouble for small m, but when m and l are both large,
then there will be trouble.  Rather than allow overflows, these
functions refuse to calculate when they can sense that l and m are
too big.

If you really want to calculate a spherical harmonic, then DO NOT
use this.  Instead use legendre_sphPlm() below, which  uses a similar
recursion, but with the normalized functions.

@deftypefun double gsl_sf_legendre_Plm (int @var{l}, int @var{m}, double @var{x})
@deftypefunx int gsl_sf_legendre_Plm_e (int @var{l}, int @var{m}, double @var{x}, gsl_sf_result * @var{result})
@comment Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW
@end deftypefun



@deftypefun int gsl_sf_legendre_Plm_array (int @var{lmax}, int @var{m}, double @var{x}, double * @var{result_array})
P_l^m(x)  m >= 0; l >= m; |x| <= 1.0
l=|m|,...,lmax
@comment Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW
@end deftypefun



@deftypefun double gsl_sf_legendre_sphPlm (int @var{l}, int @var{m}, double @var{x})
@deftypefunx int gsl_sf_legendre_sphPlm_e (int @var{l}, int @var{m}, double @var{x}, gsl_sf_result * @var{result})
P_l^m(x), normalized properly for use in spherical harmonics
m >= 0; l >= m; |x| <= 1.0

There is no overflow problem, as there is for the
standard normalization of P_l^m(x).

Specifically, it returns:

       sqrt((2l+1)/(4pi)) sqrt((l-m)!/(l+m)!) P_l^m(x)

@comment Exceptional Return Values: GSL_EDOM
@end deftypefun



@deftypefun int gsl_sf_legendre_sphPlm_array (int @var{lmax}, int @var{m}, double @var{x}, double * @var{result_array})
P_l^m(x), normalized properly for use in spherical harmonics
m >= 0; l >= m; |x| <= 1.0
l=|m|,...,lmax
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun



@deftypefun int gsl_sf_legendre_array_size (const int @var{lmax}, const int @var{m})
size of result_array[] needed for the array versions of Plm
(lmax - m + 1)
@comment Exceptional Return Values: none
@end deftypefun



@subsection Conical Functions

@deftypefun double gsl_sf_conicalP_half (double @var{lambda}, double @var{x})
@deftypefunx int gsl_sf_conicalP_half_e (double @var{lambda}, double @var{x}, gsl_sf_result * @var{result})
Irregular Spherical Conical Function
P^(1/2)_(-1/2 + I lambda)(x)

x > -1.0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_conicalP_mhalf (double @var{lambda}, double @var{x})
@deftypefunx int gsl_sf_conicalP_mhalf_e (double @var{lambda}, double @var{x}, gsl_sf_result * @var{result})
Regular Spherical Conical Function
P^(-1/2)_(-1/2 + I lambda)(x)

x > -1.0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_conicalP_0 (double @var{lambda}, double @var{x})
@deftypefunx int gsl_sf_conicalP_0_e (double @var{lambda}, double @var{x}, gsl_sf_result * @var{result})
Conical Function
P^(0)_(-1/2 + I lambda)(x)

x > -1.0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_conicalP_1 (double @var{lambda}, double @var{x})
@deftypefunx int gsl_sf_conicalP_1_e (double @var{lambda}, double @var{x}, gsl_sf_result * @var{result})
Conical Function
P^(1)_(-1/2 + I lambda)(x)

x > -1.0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_conicalP_sph_reg (int @var{l}, double @var{lambda}, double @var{x})
@deftypefunx int gsl_sf_conicalP_sph_reg_e (int @var{l}, double @var{lambda}, double @var{x}, gsl_sf_result * @var{result})
Regular Spherical Conical Function
P^(-1/2-l)_(-1/2 + I lambda)(x)

x > -1.0, l >= -1
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_conicalP_cyl_reg (int @var{m}, double @var{lambda}, double @var{x})
@deftypefunx int gsl_sf_conicalP_cyl_reg_e (int @var{m}, double @var{lambda}, double @var{x}, gsl_sf_result * @var{result})
Regular Cylindrical Conical Function
P^(-m)_(-1/2 + I lambda)(x)

x > -1.0, m >= -1
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun



@subsection Radial Functions for Hyperbolic Space

The following spherical functions are specializations
of Legendre functions which give the regular eigenfunctions
of the Laplacian on a 3-dimensional hyperbolic space.
Of particular interest is the flat limit, which is
Flat-Lim := (lambda->Inf, eta->0, lambda*eta fixed).

  
@deftypefun double gsl_sf_legendre_H3d_0 (double @var{lambda}, double @var{eta})
@deftypefunx int gsl_sf_legendre_H3d_0_e (double @var{lambda}, double @var{eta}, gsl_sf_result * @var{result})
Zeroth radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space.

legendre_H3d_0(lambda,eta) := sin(lambda*eta)/(lambda*sinh(eta))

Normalization:
Flat-Lim legendre_H3d_0(lambda,eta) = j_0(lambda*eta)

eta >= 0.0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_legendre_H3d_1 (double @var{lambda}, double @var{eta})
@deftypefunx int gsl_sf_legendre_H3d_1_e (double @var{lambda}, double @var{eta}, gsl_sf_result * @var{result})
First radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space.

legendre_H3d_1(lambda,eta) :=
   1/sqrt(lambda^2 + 1) sin(lam eta)/(lam sinh(eta))
   (coth(eta) - lambda cot(lambda*eta))

Normalization:
Flat-Lim legendre_H3d_1(lambda,eta) = j_1(lambda*eta)

eta >= 0.0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun


@deftypefun double gsl_sf_legendre_H3d (int @var{l}, double @var{lambda}, double @var{eta})
@deftypefunx int gsl_sf_legendre_H3d_e (int @var{l}, double @var{lambda}, double @var{eta}, gsl_sf_result * @var{result})
l'th radial eigenfunction of the Laplacian on the
3-dimensional hyperbolic space.

Normalization:
Flat-Lim legendre_H3d_l(l,lambda,eta) = j_l(lambda*eta)

eta >= 0.0, l >= 0
@comment Exceptional Return Values: GSL_EDOM
@end deftypefun

@deftypefun int gsl_sf_legendre_H3d_array (int @var{lmax}, double @var{lambda}, double @var{eta}, double * @var{result_array})
Array of H3d(ell),  0 <= ell <= lmax
@comment Exceptional Return Values:
@end deftypefun

