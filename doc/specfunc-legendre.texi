@comment
@node Legendre Functions and Spherical Harmonics
@section Legendre Functions and Spherical Harmonics
@cindex Legendre functions
@cindex spherical harmonics
@cindex conical functions
@cindex hyperbolic space


@subsection Legendre Polynomials


/* P_l(x), l=1,2,3
 *
@deftypefun  int gsl_sf_legendre_P1_impl(double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_P2_impl(double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_P3_impl(double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_P1_e(double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_P2_e(double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_P3_e(double x, gsl_sf_result * result)
Exceptional Return Values: none
@end deftypefun


/* P_l(x)   l >= 0; |x| <= 1
 *
@deftypefun  int gsl_sf_legendre_Pl_impl(int l, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_Pl_e(int l, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* P_l(x) for l=0,...,lmax; |x| <= 1
 *
@deftypefun  int gsl_sf_legendre_Pl_array_impl(int lmax, double x, double * result_array)
@deftypefunx int gsl_sf_legendre_Pl_array_e(int lmax, double x, double * result_array)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Q_0(x), x > -1, x != 1
 *
@deftypefun  int gsl_sf_legendre_Q0_impl(double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_Q0_e(double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Q_1(x), x > -1, x != 1
 *
@deftypefun  int gsl_sf_legendre_Q1_impl(double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_Q1_e(double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Q_l(x), x > -1, x != 1, l >= 0
 *
@deftypefun  int gsl_sf_legendre_Ql_impl(int l, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_Ql_e(int l, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


@subsection Associated Legendre Polynomials and Spherical Harmonics

/* P_l^m(x)  m >= 0; l >= m; |x| <= 1.0
 *
 * Note that this function grows combinatorially with l.
 * Therefore we can easily generate an overflow for l larger
 * than about 150.
 *
 * There is no trouble for small m, but when m and l are both large,
 * then there will be trouble. Rather than allow overflows, these
 * functions refuse to calculate when they can sense that l and m are
 * too big.
 *
 * If you really want to calculate a spherical harmonic, then DO NOT
 * use this. Instead use legendre_sphPlm() below, which  uses a similar
 * recursion, but with the normalized functions.
 *
@deftypefun  int gsl_sf_legendre_Plm_impl(int l, int m, double x, gsl_sf_result * result)
@deftypefunx int     gsl_sf_legendre_Plm_e(int l, int m, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW
@end deftypefun


/* P_l^m(x)  m >= 0; l >= m; |x| <= 1.0
 * l=|m|,...,lmax
 *
@deftypefun  int gsl_sf_legendre_Plm_array_impl(int lmax, int m, double x, double * result_array)
@deftypefunx int gsl_sf_legendre_Plm_array_e(int lmax, int m, double x, double * result_array)
Exceptional Return Values: GSL_EDOM, GSL_EOVRFLW
@end deftypefun


/* P_l^m(x), normalized properly for use in spherical harmonics
 * m >= 0; l >= m; |x| <= 1.0
 *
 * There is no overflow problem, as there is for the
 * standard normalization of P_l^m(x).
 *
 * Specifically, it returns:
 *
 *        sqrt((2l+1)/(4pi)) sqrt((l-m)!/(l+m)!) P_l^m(x)
 *
@deftypefun  int gsl_sf_legendre_sphPlm_impl(int l, int m, double x, gsl_sf_result * result)
@deftypefunx int     gsl_sf_legendre_sphPlm_e(int l, int m, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* P_l^m(x), normalized properly for use in spherical harmonics
 * m >= 0; l >= m; |x| <= 1.0
 * l=|m|,...,lmax
 *
@deftypefun  int gsl_sf_legendre_sphPlm_array_impl(int lmax, int m, double x, double * result_array)
@deftypefunx int gsl_sf_legendre_sphPlm_array_e(int lmax, int m, double x, double * result_array)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* size of result_array[] needed for the array versions of Plm
 * (lmax - m + 1)
 */
@deftypefun  int gsl_sf_legendre_array_size(const int lmax, const int m)
Exceptional Return Values: none
@end deftypefun



@subsection Conical Functions

/* Irregular Spherical Conical Function
 * P^(1/2)_(-1/2 + I lambda)(x)
 *
 * x > -1.0
@deftypefun  int gsl_sf_conicalP_half_impl(double lambda, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_conicalP_half_e(double lambda, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Regular Spherical Conical Function
 * P^(-1/2)_(-1/2 + I lambda)(x)
 *
 * x > -1.0
@deftypefun  int gsl_sf_conicalP_mhalf_impl(double lambda, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_conicalP_mhalf_e(double lambda, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Conical Function
 * P^(0)_(-1/2 + I lambda)(x)
 *
 * x > -1.0
@deftypefun  int gsl_sf_conicalP_0_impl(double lambda, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_conicalP_0_e(double lambda, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Conical Function
 * P^(1)_(-1/2 + I lambda)(x)
 *
 * x > -1.0
@deftypefun  int gsl_sf_conicalP_1_impl(double lambda, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_conicalP_1_e(double lambda, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Regular Spherical Conical Function
 * P^(-1/2-l)_(-1/2 + I lambda)(x)
 *
 * x > -1.0, l >= -1
@deftypefun  int gsl_sf_conicalP_sph_reg_impl(int l, double lambda, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_conicalP_sph_reg_e(int l, double lambda, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Regular Cylindrical Conical Function
 * P^(-m)_(-1/2 + I lambda)(x)
 *
 * x > -1.0, m >= -1
@deftypefun  int gsl_sf_conicalP_cyl_reg_impl(int m, double lambda, double x, gsl_sf_result * result)
@deftypefunx int gsl_sf_conicalP_cyl_reg_e(int m, double lambda, double x, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun



@subsection Radial Functions for Hyperbolic Space

/* The following spherical functions are specializations
 * of Legendre functions which give the regular eigenfunctions
 * of the Laplacian on a 3-dimensional hyperbolic space.
 * Of particular interest is the flat limit, which is
 * Flat-Lim := (lambda->Inf, eta->0, lambda*eta fixed).
 */
  
/* Zeroth radial eigenfunction of the Laplacian on the
 * 3-dimensional hyperbolic space.
 *
 * legendre_H3d_0(lambda,eta) := sin(lambda*eta)/(lambda*sinh(eta))
 * 
 * Normalization:
 * Flat-Lim legendre_H3d_0(lambda,eta) = j_0(lambda*eta)
 *
 * eta >= 0.0
@deftypefun  int gsl_sf_legendre_H3d_0_impl(double lambda, double eta, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_H3d_0_e(double lambda, double eta, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* First radial eigenfunction of the Laplacian on the
 * 3-dimensional hyperbolic space.
 *
 * legendre_H3d_1(lambda,eta) :=
 *    1/sqrt(lambda^2 + 1) sin(lam eta)/(lam sinh(eta))
 *    (coth(eta) - lambda cot(lambda*eta))
 * 
 * Normalization:
 * Flat-Lim legendre_H3d_1(lambda,eta) = j_1(lambda*eta)
 *
 * eta >= 0.0
@deftypefun  int gsl_sf_legendre_H3d_1_impl(double lambda, double eta, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_H3d_1_e(double lambda, double eta, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* l'th radial eigenfunction of the Laplacian on the
 * 3-dimensional hyperbolic space.
 *
 * Normalization:
 * Flat-Lim legendre_H3d_l(l,lambda,eta) = j_l(lambda*eta)
 *
 * eta >= 0.0, l >= 0
@deftypefun  int gsl_sf_legendre_H3d_impl(int l, double lambda, double eta, gsl_sf_result * result)
@deftypefunx int gsl_sf_legendre_H3d_e(int l, double lambda, double eta, gsl_sf_result * result)
Exceptional Return Values: GSL_EDOM
@end deftypefun


/* Array of H3d(ell),  0 <= ell <= lmax
 */
@deftypefun  int gsl_sf_legendre_H3d_array_impl(int lmax, double lambda, double eta, double * result_array)
@deftypefunx int gsl_sf_legendre_H3d_array_e(int lmax, double lambda, double eta, double * result_array)
Exceptional Return Values:
@end deftypefun

