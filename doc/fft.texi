@cindex FFT
@cindex Fast Fourier Transforms, see FFT
@cindex Fourier Transforms, see FFT
@cindex Discrete Fourier Transforms, see FFT
@cindex DFTs, see FFT

This chapter describes functions for performing Fast Fourier Transforms
(FFTs). The library includes radix-2 routines (for lengths which are a
power of two) and mixed-radix routines (which work for any length). For
efficiency there are separate versions of the routines for real data and
for complex data. The mixed-radix routines are a reimplementation of the
FFTPACK library by Paul Swarztrauber. Fortran code for FFTPACK is
available on Netlib (FFTPACK also includes some routines for sine and
cosine transforms but these are currently not available in GSL).  For
details and derivations of the underlying algorithms consult the
document @cite{GSL FFT Algorithms} (@pxref{FFT References and Further Reading})

Fast Fourier Transforms are efficient algorithms for
calculating the discrete fourier transform (DFT),

@equation
x_j = \sum_@{k=0@}^@{N-1@} z_k \exp(-2\pi i j k / N) 
@end equation

The DFT usually arises as an approximation to the continuous fourier
transform when functions are sampled at discrete intervals in space or
time. The naive evaluation of the discrete fourier transform is a
matrix-vector multiplication @math{W\vec@{z@}}. A general matrix-vector
multiplication takes @math{O(N^2)} operations for @math{N}
data-points. Fast fourier transform algorithms use a divide-and-conquer
strategy to factorize the matrix @math{W} into smaller sub-matrices,
corresponding to the integer factors of the length @math{N}.  If
@math{N} can be factorized into a product of integers @math{f_1 f_2
\ldots f_n} then the DFT can be computed in @math{O(N \sum f_i)}
operations. For a radix-2 FFT this gives an operation count of
@math{O(N\log_2 N)}.

@menu
* Mathematical Definitions::    
* FFTs of complex data::        
* FFTs of real data::           
* Test Signals::                
* FFT References and Further Reading::  
@end menu

@node Mathematical Definitions
@section Mathematical Definitions 
@cindex FFT mathematical definition

All the FFT functions offer three types of transform: forwards, inverse
and backwards, based on the same mathematical definitions. The
definition of the @dfn{forward fourier transform},
@math{x}=FFT(@math{z}), is,

@equation
x_j = \sum_@{k=0@}^@{N-1@} z_k \exp(-2\pi i j k / N) 
@end equation
@noindent
and the definition of the @dfn{inverse fourier transform},
@math{x}=IFFT(@math{z}), is,

@equation
z_j = @{1 \over N@} \sum_@{k=0@}^@{N-1@} x_k \exp(2\pi i j k / N).
@end equation
@noindent
The factor of @math{1/N} makes this a true inverse. For example, a call
to @code{gsl_fft_complex_forward} followed by a call to
@code{gsl_fft_complex_inverse} should return the original data (within
numerical errors).

In general there are two possible choices for the sign of the
exponential in the transform/ inverse-transform pair. GSL follows the
same convention as FFTPACK, using a negative exponential for the forward
transform. The advantage of this convention is that the inverse
transform recreates the original function with simple fourier
synthesis. Numerical Recipes uses the opposite convention, a positive
exponential in the forward transform.

The @dfn{backwards FFT} is simply our terminology for an unscaled
version of the inverse FFT,

@equation
z^@{backwards@}_j = \sum_@{k=0@}^@{N-1@} x_k \exp(2\pi i j k / N).
@end equation
@noindent
When the overall scale of the result is unimportant it is often
convenient to use the backwards FFT instead of the inverse to save
unnecessary divisions.

@node FFTs of complex data
@section FFTs of complex data
@cindex FFT of complex data

The inputs and outputs for the radix-2 and mixed-radix complex FFT
routines are simply vectors of complex elements. For example,

@example
complex data[128] ;
@end example
@noindent
The array indices are the same as those in the definition of the DFT ---
i.e. there are no index transformations or permutations of the data.
The @code{complex} type is defined as @code{struct @{double real ;
double imag@}}.

For physical applications it is important to remember that the index
appearing in the DFT does not correspond directly to a physical
frequency. If the time-step of the DFT is @math{\Delta} then the
frequency-domain includes both positive and negative frequencies,
ranging from @math{-1/(2\Delta)} through 0 to @math{+1/(2\Delta)}. The
positive frequencies are stored from the beginning of the array up to
the middle, and the negative frequencies are stored backwards from the
end of the array.

Here is a table which shows the layout of the array @var{data}, and the
correspondence between the time-domain data @math{z}, and the
frequency-domain data @math{x}.

@example
        index    z               x = FFT(z)

        0        z(t = 0)        x(f = 0)
        1        z(t = 1)        x(f = 1/(N Delta))
        2        z(t = 2)        x(f = 2/(N Delta))
        .        ........        ..................
        N/2      z(t = N/2)      x(f = +1/(2 Delta),-1/(2 Delta))
        .        ........        ..................
        N-3      z(t = N-3)      x(f = -3/(N Delta))
        N-2      z(t = N-2)      x(f = -2/(N Delta))
        N-1      z(t = N-1)      x(f = -1/(N Delta))
@end example
@noindent
When @math{N} is even the location @math{N/2} contains the most positive
and negative frequencies (@math{+1/(2 \Delta)},@math{-1/(2 \Delta)})
which are equivalent. If @math{N} is odd then general structure of the
table above still applies, but @math{N/2} does not appear.

@menu
* Radix-2 FFT routines for complex data::  
* Example of using radix-2 FFT routines for complex data::  
* Mixed-radix FFT routines for complex data::  
* Example of using mixed-radix FFT routines for complex data::  
@end menu

@node Radix-2 FFT routines for complex data
@subsection Radix-2 FFT routines for complex data
@cindex FFT of complex data, radix-2 algorithm
@cindex Radix-2 FFT for complex data

The radix-2 algorithms described in this section are simple and compact,
although not necessarily the most efficient. They use the Cooley-Tukey
algorithm to compute in-place complex FFTs for lengths which are a power
of 2 --- no additional storage is required.  The corresponding
self-sorting mixed-radix routines offer better performance at the
expense of requiring additional scratch space.

All these functions are declared in the header file @file{gsl_fft_complex.h}.

@deftypefun int gsl_fft_complex_radix2_forward (complex data[], const unsigned int n)

@deftypefunx int gsl_fft_complex_radix2_backward (complex data[], const unsigned int n)

@deftypefunx int gsl_fft_complex_radix2_inverse (complex data[], const unsigned int n)

These functions compute the forward, backward and inverse FFTs of
@var{data}, a complex array of length @var{n}, using an in-place radix-2
decimation-in-time algorithm. The length of the data @var{n} is
restricted to powers of two.

The functions return a value of @code{0} if no errors were detected, and
@code{-1} in the case of error. The following @code{gsl_errno}
condition is defined for these functions:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a power of two.
@end table

@end deftypefun


@deftypefun int gsl_fft_complex_radix2_dif_forward (complex data[], const unsigned int n)

@deftypefunx int gsl_fft_complex_radix2_dif_backward (complex data[], const unsigned int n)

@deftypefunx int gsl_fft_complex_radix2_dif_inverse (complex data[], const unsigned int n)

These are decimation-in-frequency versions of the radix-2 FFT functions.

@end deftypefun


@node Example of using radix-2 FFT routines for complex data
@subsection Example of using radix-2 FFT routines for complex data

Here is an example program which computes the FFT of a short pulse in a
sample of length 128. To make the resulting fourier transform real the
pulse is defined for equal positive and negative times (@math{-10}
@dots{} @math{10}) (the negative times wrap around the end of the
array).

@example
#include <stdio.h>
#include <math.h>
#include <gsl_errno.h>
#include <gsl_fft_complex.h>

int main ()
@{
  int i;
  complex data[128];

  for (i = 0; i < 128; i++)
    @{
       data[i].real = 0.0;
       data[i].imag = 0.0;
    @}

  data[0].real = 1.0;

  for (i = 1; i <= 10; i++)
    @{
       data[i].real = data[128-i].real = 1.0;
    @}

  for (i = 0; i < 128; i++)
    @{
      printf ("%d %e %e\n", i, data[i].real, data[i].imag);
    @}
  printf ("\n");

  gsl_fft_complex_radix2_forward (data, 128);

  for (i = 0; i < 128; i++)
    @{
      printf ("%d %e %e\n", i, data[i].real/sqrt(128), 
                               data[i].imag/sqrt(128));
    @}

@}
@end example
@noindent
Note that have assumed that the program is using the default @code{gsl}
error handler (which calls @code{abort} for any errors).  If you are not
using a safe error handler you would need to check the return status of
@code{gsl_fft_complex_radix2_forward}.
@tex
\input epsf
\medskip
\centerline{\epsfxsize=3.4in\epsfbox{fft-complex-radix2-t.eps}%
\epsfxsize=3.4in\epsfbox{fft-complex-radix2-f.eps}}
\medskip
%
\centerline{A pulse (left) and its discrete fourier transform (right),
output from the example program.}
%
\noindent The transformed data is rescaled by ${1/\sqrt{N}}$ so that it
fits on the same plot as the input. Only the real part is shown, by the
choice of the input data the imaginary part is zero. Allowing for the
wrap-around of negative times at $t=128$, and working in units of $k/N$,
the DFT approximates the continuum fourier transform of a modulated
$\sin$ function,
%
$$ 
\int_{-a}^{+a} e^{-2 \pi i k x} dx = {\sin(2\pi k a) \over\pi k} .
$$
\medskip
@end tex

@node Mixed-radix FFT routines for complex data
@subsection Mixed-radix FFT routines for complex data
@cindex FFT of complex data, mixed-radix algorithm
@cindex Mixed-radix FFT of complex data

This section describes mixed-radix FFT algorithms for complex data.  The
mixed-radix functions work for FFTs of any length. They are a
reimplementation of the Fortran FFTPACK library by Paul
Swarztrauber. The theory is explained in the review article
@cite{Self-sorting Mixed-radix FFTs} by Clive Temperton. The routines
here use the same indexing scheme and basic algorithms as FFTPACK.

The mixed-radix algorithm is based on sub-transform modules -- highly
optimized small length FFTs which are combined to create larger FFTs.
There are efficient modules for factors of 2, 3, 4, 5, 6 and 7. The
modules for the composite factors of 4 and 6 are faster than combining
the modules for @math{2*2} and @math{2*3}.

For factors which are not implemented as modules there is a fall-back to
a general length-@math{n} module which uses Singleton's method for
efficiently computing a DFT. This module is @math{O(n^2)}, and slower
than a dedicated module would be but works for any length @math{n}. Of
course, lengths which use the general length-@math{n} module will still
be factorized as much as possible. For example, a length of 143 will be
factorized into @math{11*13}. Large prime factors are the worst case
scenario, e.g. as found in @math{n=2*3*99991}, and should be avoided
because their @math{O(n^2)} scaling will dominate the run-time (consult
@cite{GSL FFT Algorithms} for possible ways around this problem).

The mixed-radix initialization function @code{gsl_fft_complex_init}
returns the list of factors chosen by the library for a given length
@math{N}. It can be used to check how well the length has been
factorized, and estimate the run-time. To a first approximation the
run-time scales as @math{N \sum f_i}, where the @math{f_i} are the
factors of @math{N}. For programs under user control you may wish to
issue a warning that the transform will be slow when the length is
poorly factorized. If you frequently encounter data lengths which cannot
be factorized using the existing small-prime modules consult @cite{GSL
FFT Algorithms} for details on adding support for other factors.

@c First, the space for the trigonometric lookup tables and scratch area is
@c allocated by a call to one of the @code{wavetable_alloc} functions. We
@c call the combination of factorization, scratch space and trigonometric
@c lookup arrays a @dfn{wavetable}. It contains the sine and cosine
@c waveforms for the all the frequencies that will be used in the FFT.

@c The wavetable is initialized by a call to the corresponding @code{init}
@c function. It factorizes the data length, using the implemented
@c subtransforms as preferred factors wherever possible. The trigonometric
@c lookup table for the chosen factorization is also computed.

@c An FFT is computed by a call to one of the @code{forward},
@c @code{backward} or @code{inverse} functions, with the data, length and
@c wavetable as arguments.

All these functions are declared in the header file @file{gsl_fft_complex.h}.

@deftypefun int gsl_fft_complex_wavetable_alloc (unsigned int @var{n}, gsl_fft_complex_wavetable * @var{wavetable});

This function allocates space for a scratch area and a trigonometric
lookup table, both of size @var{n} complex elements. The relevant
components of @var{wavetable} are modified to point to the newly
allocated memory.

The function returns a value of @code{0} if no errors were detected,
and @code{-1} in the case of error. The following @code{gsl_errno}
conditions are defined for this function:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n} is zero).

@item GSL_ENOMEM
The requested memory could not be allocated (@code{malloc} returned
a null pointer).
@end table

@end deftypefun

@deftypefun int gsl_fft_complex_init (const unsigned int @var{n}, gsl_fft_complex_wavetable * @var{wavetable});

This function initializes @var{wavetable}. It selects a factorization of
the length @var{n} into the implemented subtransforms, storing the
details of the factorization in @var{wavetable}. Using this
factorization it then prepares a trigonometric lookup table in the
memory previously allocated by @code{gsl_fft_complex_wavetable_alloc}.

The wavetable is computed using direct calls to @code{sin} and
@code{cos}, for accuracy. It could be computed faster using recursion
relations if necessary. If an application performs many FFTs of the same
length then computing the wavetable is a one-off overhead which does not
affect the final throughput.

The wavetable structure can be used repeatedly for any transform of the
same length. The table is not modified by calls to any of the other FFT
functions. The same wavetable can be used for both forward and backward
(or inverse) transforms of a given length.

The function returns a value of @code{0} if no errors were detected,
and @code{-1} in the case of error. The following @code{gsl_errno}
conditions are defined for this function:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n} is zero).

@item GSL_EFACTOR
The length @var{n} could not be factorized (this shouldn't happen).

@item GSL_EFAILED
A failure was detected in the wavetable generation. This could be caused
by an inconsistency in a user-supplied @var{wavetable} structure.
@end table

@end deftypefun

@deftypefun int gsl_fft_complex_wavetable_free (gsl_fft_complex_wavetable * @var{wavetable});

This function frees the blocks of memory previously allocated by
@code{gsl_fft_complex_wavetable_alloc} and pointed to by the components
of @var{wavetable}.

The wavetable should be freed if no further FFTs of the same length will
be needed.
@end deftypefun

The functions @code{gsl_fft_complex_init},
@code{gsl_fft_wavetable_alloc} and @code{gsl_fft_wavetable_free} all
operate on a structure @code{gsl_fft_complex_wavetable}. This structure
contains internal parameters for the FFT. 

It is not necessary to set any of the members directly except for
advanced usage.  However, it can useful to examine the wavetable
returned by @code{gsl_fft_complex_init}. For example, the factorization
chosen by @code{gsl_fft_complex_init} is given and can be used to
provide an estimate of the run-time or numerical error.

Here is the wavetable structure. It is declared in the header file
@file{gsl_fft_complex.h}.

@deftp {Data Type} {struct gsl_fft_complex_wavetable}

This is a structure that holds the factorization and pointers to the
scratch area and trigonometric lookup tables for the mixed radix fft
algorithm. It has the following members:

@table @code
@item unsigned int n
This is the number of complex data points

@item unsigned int nf
This is the number of factors that the length @code{n} was decomposed into.

@item unsigned int factor[64]
This is the array of factors. Only the first @code{nf} elements are
used. 

@comment (FIXME: This is a fixed length array and therefore probably in
@comment violation of the GNU Coding Standards).

@item complex * scratch
This is a pointer to a scratch area of @code{n} complex elements,
capable of holding intermediate copies of the original data set.

@item complex * trig
This is a pointer to a preallocated trigonometric lookup table of
@code{n} complex elements.

@item complex * twiddle[64]
This is an array of pointers into @code{trig}, giving the twiddle
factors for each pass.

@end table

@end deftp

@deftypefun int gsl_fft_complex_forward (complex @var{data}[], const unsigned int @var{n}, const gsl_fft_wavetable * @var{wavetable})
@deftypefunx int gsl_fft_complex_inverse (complex @var{data}[], const unsigned int @var{n}, const gsl_fft_complex_wavetable * @var{wavetable})
@deftypefunx int gsl_fft_complex_backward (complex @var{data}[], const unsigned int @var{n}, const gsl_fft_complex_wavetable * @var{wavetable})

These functions compute the forward, backward and inverse FFT of
@var{data}, a complex array of length @var{n}, using a mixed radix
decimation-in-frequency algorithm. 

The caller must supply a @var{wavetable} containing the chosen
factorization, trigonometric lookup tables and scratch area. The
wavetable can be easily prepared using the functions
@code{gsl_fft_complex_init} and @code{gsl_fft_complex_alloc}.

There is no restriction on the length @var{n}.  Efficient modules are
provided for subtransforms of length 2, 3, 4, 5, 6 and 7. Any remaining
factors are computed with a slow, @math{O(n^2)}, general-@math{n} module.

The functions return a value of @code{0} if no errors were detected,
and @code{-1} in the case of error. The following @code{gsl_errno}
conditions are defined for these functions:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n}
is zero).

@item GSL_EINVAL
The length of the data @var{n} and the length used to compute the given
@var{wavetable} do not match.
@end table
@end deftypefun

@node Example of using mixed-radix FFT routines for complex data
@subsection Example of using mixed-radix FFT routines for complex data

Here is an example program which computes the FFT of a short pulse in a
sample of length 630 (@math{=2*3*3*5*7}) using the mixed-radix
algorithm.

@example
#include <stdio.h>
#include <math.h>
#include <gsl_errno.h>
#include <gsl_fft_complex.h>

int main ()
@{
  int i;
  const int n = 630 ;
  complex data[n];

  gsl_fft_complex_wavetable wavetable;

  for (i = 0; i < n; i++)
    @{
      data[i].real = 0.0 ;
      data[i].imag = 0.0 ;
    @}

  data[0].real = 1.0 ;

  for (i = 1; i <= 10; i++)
    @{
      data[i].real = data[n-i].real = 1.0 ;
    @}

  for (i = 0; i < n; i++)
    @{
      printf ("%d: %e %e\n", i, data[i].real, data[i].imag);
    @}
  printf ("\n");

  gsl_fft_complex_wavetable_alloc (n, &wavetable);
  gsl_fft_complex_init (n, &wavetable);

  for (i = 0; i < wavetable.nf; i++)
    @{
       printf("# factor %d: %d\n", i, wavetable.factor[i]);
    @}

  gsl_fft_complex_forward (data, n, &wavetable);

  for (i = 0; i < n; i++)
    @{
      printf ("%d: %e %e\n", i, data[i].real, data[i].imag);
    @}

  gsl_fft_complex_wavetable_free (&wavetable);

@}
@end example
@noindent
Note that we have assumed that the program is using the default @code{gsl}
error handler (which calls @code{abort} for any errors).  If you are not
using a safe error handler you would need to check the return status of
of all the @code{gsl} routines.

@node FFTs of real data
@section FFTs of real data
@cindex FFT of real data
The functions for real data are similar to those for complex data.
However, there is an important difference between forward and inverse
transforms. The fourier transform of a real sequence is not real. It is
a complex sequence with a special symmetry:

@equation
z_k = z_@{N-k@}^*
@end equation
@noindent
A sequence with this symmetry is called @dfn{conjugate-complex} or
@dfn{half-complex}. This different structure requires different
storage-layouts for the forward transform (from real to half-complex)
and inverse transform (from half-complex back to real).  As a
consequence the routines are divided into two sets: functions in
@code{gsl_fft_real} which operate on real sequences and functions in
@code{gsl_fft_halfcomplex} which operate on half-complex sequences.

Functions in @code{gsl_fft_real} compute the frequency coefficients of a
real sequence. The half-complex coefficients @math{c} of a real sequence
@math{x} are given by fourier analysis,

@equation
c_k = \sum_@{j=0@}^@{N-1@} x_k \exp(-2 \pi i j k /N)
@end equation
@noindent
Functions in @code{gsl_fft_halfcomplex} compute inverse or backwards
transforms. They reconstruct real sequences by fourier synthesis from
their half-complex frequency coefficients, @math{c},

@equation
x_j = @{1 \over N@} \sum_@{k=0@}^@{N-1@} c_k \exp(2 \pi i j k /N)
@end equation
@noindent
The symmetry of the half-complex sequence implies that only half of the
complex numbers in the output need to be stored. The remaining half can
be reconstructed using the half-complex symmetry condition. (This works
for all lengths, even and odd. When the length is even the middle value,
where @math{k=N/2}, is also real). Thus only @var{N} real numbers are
required to store the half-complex sequence, and the transform of a real
sequence can be stored in the same size array as the original data.

The precise storage arrangements depend on the algorithm, and are
different for radix-2 and mixed-radix routines. The radix-2 function
operates in-place, which constrain the locations where each element can
be stored. The restriction forces real and imaginary parts to be stored
far apart. The mixed-radix algorithm does not have this restriction, and
it stores the real and imaginary parts of a given term in neighboring
locations. This is desirable for better locality of memory accesses.

@menu
* Radix-2 FFT routines for real data::  
* Mixed-radix FFT routines for real data::  
* Example of using mixed-radix FFT routines for real data::  
@end menu

@node Radix-2 FFT routines for real data
@subsection Radix-2 FFT routines for real data
@cindex FFT of real data, radix-2 algorithm
@cindex Radix-2 FFT for real data

This section describes radix-2 FFT algorithms for real data. They use
the Cooley-Tukey algorithm to compute in-place FFTs for lengths which
are a power of 2. 

The radix-2 FFT functions for real data are declared in the header files
@file{gsl_fft_real.h} 

@deftypefun int gsl_fft_real_radix2 (double data[], const unsigned int n)

This function computes an in-place radix-2 FFT of @var{data}, a real
array of length @var{n}. The output is a half-complex sequence, which is
stored in-place. The arrangement of the half-complex terms uses the
following scheme: for @math{k < N/2} the real part of the @math{k}-th
term is stored in location @math{k}, and the corresponding imaginary
part is stored in location @math{N-k}. Terms with @math{k > N/2} can be
reconstructed using the symmetry @math{z_k = z^*_@{N-k@}}. The terms for
@math{k=0} and @math{k=N/2} are both purely real, and count as a special
case. Their real parts are stored in locations @math{0} and @math{N/2}
respectively, while their imaginary parts which are zero are not stored.

The following table shows the correspondence between the output
@var{data} and the equivalent results obtained by considering the input
data as a complex sequence with zero imaginary part,

@example
complex[0].real    =    data[0] 
complex[0].imag    =    0 
complex[1].real    =    data[1] 
complex[1].imag    =    data[N-1]
...............         ................
complex[k].real    =    data[k]
complex[k].imag    =    data[N-k] 
...............         ................
complex[N/2].real  =    data[N/2]
complex[N/2].real  =    0
...............         ................
complex[k'].real   =    data[k]        k' = N - k
complex[k'].imag   =   -data[N-k] 
...............         ................
complex[N-1].real  =    data[1]
complex[N-1].imag  =   -data[N-1]
@end example

@end deftypefun
The radix-2 FFT functions for halfcomplex data are declared in the
header file @file{gsl_fft_halfcomplex.h}.

@deftypefun int gsl_fft_halfcomplex_radix2_inverse (double data[], const unsigned int n)
@deftypefunx int gsl_fft_halfcomplex_radix2_backwards (double data[], const unsigned int n)

These functions compute the inverse or backwards in-place radix-2 FFT of
the half-complex sequence @var{data}, a real of length @var{n} stored
according the output scheme used by @code{gsl_fft_real_radix2}. The
result is a real array stored in natural order.

@end deftypefun



@node Mixed-radix FFT routines for real data
@subsection Mixed-radix FFT routines for real data
@cindex FFT of real data, mixed-radix algorithm
@cindex Mixed-radix FFT for real data

This section describes mixed-radix FFT algorithms for real data. The
mixed-radix functions work for FFTs of any length. They are a
reimplementation of the real-FFT routines in the Fortran FFTPACK library
by Paul Swarztrauber. The theory behind the algorithm is explained in
the article @cite{Fast Mixed-Radix Real Fourier Transforms} by Clive
Temperton. The routines here use the same indexing scheme and basic
algorithms as FFTPACK.

The functions use the FFTPACK storage convention for half-complex
sequences. In this convention the half-complex transform of a real
sequence is stored in with frequencies in increasing order, starting at
zero, with the real and imaginary parts of each frequency in neighboring
locations. When a value is known to be real the imaginary part is not
stored. The imaginary part of the zero-frequency component is never
stored. It is known to be zero (since the zero frequency component is
simply the sum of the input data (all real)). For a sequence of even
length the imaginary part of the frequency @math{n/2} is not stored
either, since the symmetry @math{z_k = z_@{N-k@}^*} implies that this is
purely real too.

The storage scheme is best shown by some examples.  The table below
shows the output for an odd-length sequence, @math{n=5}. The two columns
give the correspondence between the 5 values in the half-complex
sequence returned by @code{gsl_fft_real}, @var{halfcomplex[]} and the
values @var{complex[]} that would be returned if the same real input
sequence were passed to @code{gsl_fft_complex_backward} as a complex
sequence (with imaginary parts set to @code{0}),

@example
complex[0].real  =  halfcomplex[0] 
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1] 
complex[1].imag  =  halfcomplex[2]
complex[2].real  =  halfcomplex[3]
complex[2].imag  =  halfcomplex[4]
complex[3].real  =  halfcomplex[3]
complex[3].imag  = -halfcomplex[4]
complex[4].real  =  halfcomplex[1]
complex[4].imag  = -halfcomplex[2]
@end example
@noindent
The upper elements of the @var{complex} array, @code{complex[3]} and
@code{complex[4]} are filled in using the symmetry condition.  The
imaginary part of the zero-frequency term @code{complex[0].imag} is
known to be zero by the symmetry.

The next table shows the output for an even-length sequence, @math{n=5}
In the even case both the there are two values which are purely real,

@example
complex[0].real  =  halfcomplex[0]
complex[0].imag  =  0
complex[1].real  =  halfcomplex[1] 
complex[1].imag  =  halfcomplex[2] 
complex[2].real  =  halfcomplex[3] 
complex[2].imag  =  halfcomplex[4] 
complex[3].real  =  halfcomplex[5] 
complex[3].imag  =  0 
complex[4].real  =  halfcomplex[3] 
complex[4].imag  = -halfcomplex[4]
complex[5].real  =  halfcomplex[1] 
complex[5].imag  = -halfcomplex[2] 
@end example
@noindent
The upper elements of the @var{complex} array, @code{complex[4]} and
@code{complex[5]} are be filled in using the symmetry condition. Both
@code{complex[0].imag} and @code{complex[3].imag} are known to be zero.

All these functions are declared in the header files
@file{gsl_fft_real.h} and @file{gsl_fft_halfcomplex.h}.

@deftypefun int gsl_fft_real_wavetable_alloc (unsigned int @var{n}, gsl_fft_real_wavetable * @var{wavetable});
@deftypefunx int gsl_fft_halfcomplex_wavetable_alloc (unsigned int @var{n}, gsl_fft_halfcomplex_wavetable * @var{wavetable});
These functions allocate space for a scratch area of size @var{n} real
elements and a trigonometric lookup table, of size @math{n/2} complex
elements. The relevant components of @var{wavetable} are modified to point
to the newly allocated memory.

These functions return a value of @code{0} if no errors were detected,
and @code{-1} in the case of error. The following @code{gsl_errno}
conditions are defined for these functions:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n}
is zero).

@item GSL_ENOMEM
The requested memory could not be allocated (@code{malloc} returned
a null pointer).
@end table

@end deftypefun


@deftypefun int gsl_fft_real_init (const unsigned int @var{n}, gsl_fft_real_wavetable * @var{wavetable});
@deftypefunx int gsl_fft_halfcomplex_init (const unsigned int @var{n}, gsl_fft_halfcomplex_wavetable * @var{wavetable});

These functions initialize @var{wavetable}.  They first select a
factorization of the length @var{n} into the implemented subtransforms,
storing the details of the factorization in @var{wavetable}.

Using this factorization they then prepare a trigonometric lookup table
in the memory previously allocated by
@code{gsl_fft_real_wavetable_alloc} or
@code{gsl_fft_halfcomplex_wavetable_alloc}. The wavetable is computed
using direct calls to @code{sin} and @code{cos}, for accuracy. It could
be computed faster using recursion relations if necessary. If an
application performs many FFTs of the same length then computing the
wavetable is a one-off overhead which does not affect the final
throughput.

The wavetable structure can be used repeatedly for any transform of the
same length. The table is not modified by calls to any of the other FFT
functions. The same wavetable can be used for both forward and backward
(or inverse) transforms of a given length.

The functions return a value of @code{0} if no errors were detected,
and @code{-1} in the case of error. The following @code{gsl_errno}
conditions are defined for these functions:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n}
is zero).

@item GSL_EFACTOR
The length @var{n} could not be factorized (this shouldn't happen).

@item GSL_EFAILED
A failure was detected in the wavetable generation. This could be caused
by an inconsistency in a user-supplied @var{wavetable} structure.
@end table

@end deftypefun

@deftypefun int gsl_fft_real_wavetable_free (gsl_fft_real_wavetable * @var{wavetable});
@deftypefunx int gsl_fft_halfcomplex_wavetable_free (gsl_fft_halfcomplex_wavetable * @var{wavetable});

These functions free the blocks of memory previously allocated by
@code{gsl_fft_real_wavetable_alloc} or
@code{gsl_fft_halfcomplex_wavetable_alloc} and pointed to by the
components of @var{wavetable}.

The wavetable should be freed if no further FFTs of the same length will
be needed.
@end deftypefun


@deftypefun int gsl_fft_real (double @var{data}[], const unsigned int @var{n}, const gsl_fft_real_wavetable * @var{wavetable})
@deftypefunx int gsl_fft_halfcomplex (double @var{data}[], const unsigned int @var{n}, const gsl_fft_halfcomplex_wavetable * @var{wavetable})

These functions compute the FFT of @var{data}, a real or half-complex
array of length @var{n}, using a mixed radix decimation-in-frequency
algorithm. For @code{gsl_fft_real} @var{data} is an array of
time-ordered real data.  For @code{gsl_fft_halfcomplex} @var{data}
contains fourier coefficients in the half-complex ordering described
above.

The caller must supply a @var{wavetable} containing the chosen
factorization, trigonometric lookup tables and scratch area. The
wavetable can be easily prepared using the functions
@code{gsl_fft_real_alloc} and @code{gsl_fft_real_init} or
@code{gsl_fft_halfcomplex_alloc} and @code{gsl_fft_halfcomplex_init}.

There is no restriction on the length @var{n}.  Efficient modules are
provided for subtransforms of length 2, 3, 4 and 5. Any remaining
factors are computed with a slow, @math{O(n^2)}, general-n module.

The functions return a value of @code{0} if no errors were detected,
and @code{-1} in the case of error. The following @code{gsl_errno}
conditions are defined for these functions:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n}
is zero).

@item GSL_EINVAL
The length of the data @var{n} and the length used to compute the given
@var{wavetable} do not match.
@end table
@end deftypefun


@deftypefun int gsl_fft_real_unpack (const double real_coefficient[], complex complex_coefficient[], const unsigned int n)

This function converts a single real array, @var{real_coefficient} into
an equivalent complex array, @var{complex_coefficient}, (with imaginary
part set to zero), suitable for @code{gsl_fft_complex} routines. The
algorithm for the conversion is simply,

@example
for (i = 0; i < n; i++)
    @{
      complex_coefficient[i].real = real_coefficient[i];
      complex_coefficient[i].imag = 0.0;
    @}
@end example

The function returns a value of @code{0} if no errors were detected, and
@code{-1} in the case of error. There is only one @code{gsl_errno}
condition defined for this function:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n}
is zero).
@end table
@end deftypefun

@deftypefun int gsl_fft_halfcomplex_unpack (const double halfcomplex_coefficient[], complex complex_coefficient[], const unsigned int n)

This function converts @var{halfcomplex_coefficient}, an array of
half-complex coefficients as returned by @code{gsl_fft_real}, into an
ordinary complex array, @var{complex_coefficient}. It fills in the
complex array using the symmetry @math{z_k = z_@{N-k@}^*} to reconstruct
the redundant elements. The algorithm for the conversion is,

@example  
complex_coefficient[0].real = halfcomplex_coefficient[0];
complex_coefficient[0].imag = 0.0;

for (i = 1; i < n - i; i++)
  @{
    const double hc_real = halfcomplex_coefficient[2 * i - 1];
    const double hc_imag = halfcomplex_coefficient[2 * i];
    complex_coefficient[i].real = hc_real;
    complex_coefficient[i].imag = hc_imag;
    complex_coefficient[n - i].real = hc_real;
    complex_coefficient[n - i].imag = -hc_imag;
  @}
 if (i == n - i)
  @{
    complex_coefficient[i].real = halfcomplex_coefficient[n - 1];
    complex_coefficient[i].imag = 0.0;
  @}
@end example

The function returns a value of @code{0} if no errors were detected, and
@code{-1} in the case of error. There is only one @code{gsl_errno}
condition defined for this function:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n}
is zero).
@end table
@end deftypefun

@node Example of using mixed-radix FFT routines for real data
@subsection Example of using mixed-radix FFT routines for real data

Here is an example program using @code{gsl_fft_real} and
@code{gsl_fft_halfcomplex}. It generates a real signal in the shape of a
square pulse. The pulse is fourier transformed to frequency space, and
all but the lowest ten frequency components are removed from the array
of fourier coefficients returned by @code{gsl_fft_real}.

The remaining fourier coefficients are transformed back to the
time-domain, to give a filtered version of the square pulse. Since
fourier coefficients are stored using the half-complex symmetry both
positive and negative frequencies are removed and the final filtered
signal is also real.

@example
#include <stdio.h>
#include <math.h>
#include <gsl_errno.h>
#include <gsl_fft_real.h>
#include <gsl_fft_halfcomplex.h>

int main ()
@{
  int i, n = 100;
  double data[n];

  gsl_fft_real_wavetable real_wavetable;
  gsl_fft_halfcomplex_wavetable halfcomplex_wavetable;

  for (i = 0; i < n; i++)
    @{
      data[i] = 0.0;
    @}

  for (i = n / 3; i < 2 * n / 3; i++)
    @{
      data[i] = 1.0;
    @}

  for (i = 0; i < n; i++)
    @{
      printf ("%d: %e\n", i, data[i]);
    @}
  printf ("\n");

  gsl_fft_real_wavetable_alloc (n, &real_wavetable);
  gsl_fft_real_init (n, &real_wavetable);
  gsl_fft_real (data, n, &real_wavetable);
  gsl_fft_real_wavetable_free (&real_wavetable);

  for (i = 11; i < n; i++)
    @{
      data[i] = 0;
    @}

  gsl_fft_halfcomplex_wavetable_alloc (n, &halfcomplex_wavetable);
  gsl_fft_halfcomplex_init (n, &halfcomplex_wavetable);
  gsl_fft_halfcomplex_inverse (data, n, &halfcomplex_wavetable);
  gsl_fft_halfcomplex_wavetable_free (&halfcomplex_wavetable);

  for (i = 0; i < n; i++)
    @{
      printf ("%d: %e\n", i, data[i]);
    @}
@}
@end example
@tex
\input epsf
\medskip
\centerline{\epsfbox{fft-real-mixedradix.eps}}
\medskip
%
\centerline{Low-pass filtered version of a real pulse, output from the example
program.}
%
%\noindent
%The fourier expansion of the square wave 
%$$
%f(x) = {4 \over \pi} (\cos x - {1 \over 3} \cos 3x + {1 \over 5} \cos
%5x - \dots)
%$$
\medskip
@end tex


@node Test Signals
@section Test Signals
@cindex FFT test signals

This section describes functions for generating simple test signals,
such as unit pulses, constant signals, complex exponentials (sine and
cosine waves) and pairs of complex exponentials with different
frequencies. The Fourier transforms for these signals can be calculated
analytically. Each function returns both the test signal and its Fourier
transform.

There are also some routines for generating white noise. In this case
the transform cannot be calculated analytically, and is computed using a
brute-force discrete Fourier transform. This may be slow but it is easy
to check and independent of all the other routines.

These functions are declared in the header file @file{gsl_fft_signals.h}.

@deftypefun int gsl_fft_signal_complex_pulse (const unsigned int t, const unsigned int n, const double z_real, const double z_imag, complex data[], complex fft[])

This function prepares a ``delta-function'' pulse of complex amplitude
(@var{z_real},@var{z_imag}) at time @var{t} in the complex array
@var{data} of length @var{n}. The pulse only occupies one array element.
All other elements of @var{data} are set to zero. The function also
returns the fourier transform of the pulse in the complex array
@var{fft}, also of length @var{n}.

Writing @math{z} as (@math{z_@{real@} + i z_@{imag@}}), the mathematical
definition of the pulse is,
@equation
z_k =  z \delta_@{kt@},
@end equation
@noindent
where @math{\delta_@{kt@}=1} if @math{k=t}, and 0 otherwise. The fourier
transform is,

@equation
x_j = \sum_@{k=0@}^@{n-1@} z \delta_@{kt@} \exp(-2\pi i j k/n)
    = z \exp(-2\pi i j t/n)
@end equation
@end deftypefun

@deftypefun int gsl_fft_signal_complex_constant (const unsigned int n, const double z_real, const double z_imag, complex data[], complex fft[])

This function prepares a constant complex signal of amplitude
(@var{z_real},@var{z_imag}) in the complex array @var{data} of length
@var{n}. The function also returns the fourier transform of the constant
in the complex array @var{fft}, also of length @var{n}.

The mathematical definition of the constant signal is, 

@equation
z_k = z
@end equation
@noindent
and the fourier transform is,

@equation
x_j = \sum_@{k=0@}^@{n-1@} z \exp(-2\pi i j k/n)
    = z n \delta_@{j0@}
@end equation
@end deftypefun

@deftypefun int gsl_fft_signal_complex_exp (const int f, const unsigned int n, const double z_real, const double z_imag, complex data[], complex fft[])

This function prepares a complex exponential signal of amplitude
(@var{z_real},@var{z_imag}) and frequency @var{f} in the complex array
@var{data} of length @var{n}. The function also returns the fourier
transform of the signal in the complex array @var{fft}, also of length
@var{n}.

The mathematical definition of the complex exponential signal is,

@equation
z_k = z \exp(2\pi i k f/n)
@end equation
@noindent

and the fourier transform is,

@equation
x_j = \sum_@{k=0@}^@{n-1@} z \exp(2\pi i k f/n) \exp(-2\pi i j k/n)
    = z n \delta_@{j,f@}
@end equation
@end deftypefun

@deftypefun int gsl_fft_signal_complex_exppair (const int f1, const int f2, const unsigned int n, const double z1_real, const double z1_imag, const double z2_real, const double z2_imag, complex data[], complex fft[])

This function prepares a pair of exponential signals of amplitude
(@var{z1_real},@var{z1_imag}) and (@var{z2_real},@var{z2_imag}) with
frequencies @var{f1} and @var{f2} in the complex array @var{data} of
length @var{n}. The function also returns the fourier transform of the
signal in the complex array @var{fft}, also of length @var{n}.

The mathematical definition of the pair of exponential signals is,

@equation
z_k = z_1 \exp(2\pi i k f_1/n) + z_2 \exp(2\pi i k f_2/n)
@end equation
@noindent
and the fourier transform is,

@equation
x_j =  z_1 n \delta_@{j,f_1@}  + z_2 n \delta_@{j,f_2@}
@end equation
@end deftypefun

@deftypefun int gsl_fft_signal_complex_noise (const unsigned int n, complex data[], complex fft[])

This function prepares a complex white-noise signal in the complex array
@var{data} of length @var{n}. The real and imaginary components of each
array element are independent uniform distributed random values in the
range [0,1] (computed using the system @code{rand} function). The
function also returns the fourier transform of the signal in the complex
array @var{fft}, also of length @var{n}. The fourier transform is
computed using the brute-force discrete fourier transform
@code{gsl_dft_complex_forward}. Note that the direct computation of the
discrete fourier transform has worse numerical stability than an FFT, so
the array @var{fft} is only useful in detecting large errors.

@end deftypefun

@deftypefun int gsl_fft_signal_real_noise (const unsigned int n, complex data[], complex fft[])

This function generates real white noise instead of complex white noise.
It is the same as @code{gsl_fft_signal_complex_noise} but with the
imaginary parts of @var{data} explicitly set to zero.

@end deftypefun

All these functions return a value of @code{0} if no errors were
detected, and @code{-1} in the case of error. There is only one
@code{gsl_errno} condition defined for these functions:

@table @code
@item GSL_EDOM
The length of the data @var{n} is not a positive integer (i.e. @var{n}
is zero).
@end table

@node FFT References and Further Reading
@section FFT References and Further Reading

@noindent
A good starting point for learning more about the FFT is the review
article @cite{Fast Fourier Transforms: A Tutorial Review and A State of
the Art} by Duhamel and Vetterli,

@itemize @asis
@item
P. Duhamel and M. Vetterli.
Fast fourier transforms: A tutorial review and a state of the art.
@cite{Signal Processing}, 19:259--299, 1990.
@end itemize
@noindent
To find out about the algorithms used in the GSL routines you may want
to consult the latex document @cite{GSL FFT Algorithms} (it is included
in GSL, as @file{doc/fftalgorithms.tex}). This has general information
on FFTs and explicit derivations of the implementation for each
routine. There are also references to the relevant literature. For
convenience some of the more important references are reproduced below.

There are several introductory books on the FFT with example programs,
such as @cite{The Fast Fourier Transform} by Brigham and @cite{DFT/FFT
and Convolution Algorithms} by Burrus and Parks,

@itemize @asis 
@item
E. Oran Brigham.
@cite{The Fast Fourier Transform}.
Prentice Hall, 1974.

@item
C. S. Burrus and T. W. Parks.
@cite{DFT/FFT and Convolution Algorithms}.
Wiley, 1984.
@end itemize
@noindent
Both these introductory books cover the radix-2 FFT in some detail.
The mixed-radix algorithm at the heart of the FFTPACK routines is
reviewed in Clive Temperton's paper,

@itemize @asis 
@item
Clive Temperton.
Self-sorting mixed-radix fast fourier transforms.
@cite{Journal of Computational Physics}, 52(1):1--23, 1983.
@end itemize
@noindent
The derivation of FFTs for real-valued data is explained in the
following two articles,

@itemize @asis
@item
Henrik V. Sorenson, Douglas L. Jones, Michael T. Heideman, and C. Sidney
Burrus.
Real-valued fast fourier transform algorithms.
@cite{IEEE Transactions on Acoustics, Speech, and Signal Processing},
ASSP-35(6):849--863, 1987.

@item
Clive Temperton.
Fast mixed-radix real fourier transforms.
@cite{Journal of Computational Physics}, 52:340--350, 1983.
@end itemize

@noindent
In 1979 the IEEE published a compendium of carefully-reviewed Fortran
FFT programs in @cite{Programs for Digital Signal Processing}. It is a
useful reference for implementations of many different FFT
algorithms,

@itemize @asis 
@item
Digital Signal Processing Committee and IEEE Acoustics, Speech, and Signal
Processing Committee, editors.
@cite{Programs for Digital Signal Processing}.
IEEE Press, 1979.
@end itemize
@noindent
There is also an annotated bibliography of papers on the FFT and related
topics by Burrus,

@itemize @asis 
@item C. S. Burrus. Notes on the FFT.
@end itemize
@noindent
The notes are available from @url{http://www-dsp.rice.edu/res/fft/fftnote.asc}.



