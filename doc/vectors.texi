 The functions described in this chapter provide a simple vector and
matrix interface to ordinary C arrays. By writing your functions in
terms of vectors and matrices you can pass a single structure containing
both data and dimensions without needing additional function arguments.


@menu
* The vector struct::           
* Vector allocation::           
* Accessing vector elements::   
* Reading and writing vectors::  
* Example programs for vectors::  
* The matrix struct::           
* Matrix allocation::           
* Accessing matrix elements::   
* Reading and writing matrices::  
* Example programs for matrices::  
@end menu

@node The vector struct
@section The vector struct

Vectors are defined by a @code{gsl_vector} structure which contains two
members, the size and a pointer to a block of memory where the elements
of the vector are stored. The @code{gsl_vector} structure is very simple
and looks like this,

@example
typedef struct
@{
  size_t size;
  double * data;
@} gsl_vector ;
@end example
@c
@noindent
The library also defines two other types of vectors, for
single-precision floating point numbers and for integers which have the
names @code{gsl_vector_float} and @code{gsl_vector_int}.

@node Vector allocation
@section Vector allocation

The functions for allocating memory to a vector follow the style of
@code{malloc} and @code{free}. In addition they also perform their own
error checking. If there is insufficient memory available to allocate a
vector then the functions call the GSL error handler (with an error
number of @code{GSL_ENOMEM}) in addition to returning a null
pointer. Thus if you use the library error handler to abort your program
then it isn't necessary to check every @code{alloc}.

@deftypefun {gsl_vector *} gsl_vector_alloc (size_t n)
This function allocates memory for a vector and its @var{n} elements,
returning a pointer to a newly initialized vector struct.  The elements
of the vector are not initialized and so their values are undefined. Use
the function @code{gsl_vector_calloc} if you want to ensure that all the
elements are initialized to zero.

A null pointer is returned if insufficient memory is available to store
the vector.
@end deftypefun

@deftypefun {gsl_vector *} gsl_vector_calloc (size_t n)
This function allocates memory for a vector and initialize all the
elements of the vector to zero.
@end deftypefun

@deftypefun void gsl_vector_free (gsl_vector * v)
This function frees the memory used by a vector @var{v} previously
allocated with @code{gsl_vector_alloc} or @code{gsl_vector_calloc}.
@end deftypefun
@c
@noindent
The following functions perform the same tasks as the functions above
for single-precision and integer vectors.

@deftypefun {gsl_vector_float *} gsl_vector_float_alloc (size_t n)
@deftypefunx {gsl_vector_float *} gsl_vector_float_calloc (size_t n)
@deftypefunx void gsl_vector_float_free (gsl_vector_float * v)
These functions perform memory management for single-precision floating
point vectors defined with the  struct @code{gsl_vector_float}.
@end deftypefun

@deftypefun {gsl_vector_int *} gsl_vector_int_alloc (size_t n)
@deftypefunx {gsl_vector_int *} gsl_vector_int_calloc (size_t n)
@deftypefunx void gsl_vector_int_free (gsl_vector_int * v)
These functions perform memory management for integer vectors defined
with the struct @code{gsl_vector_int}.
@end deftypefun

@node Accessing vector elements
@section Accessing vector elements

Unlike @sc{fortran}, the C language does not provide support for range
checking of vectors and matrices. However, the functions
@code{gsl_vector_get} and @code{gsl_vector_set} can perform range checking
for you and report an error if you attempt to access elements outside
the allowed range.

The functions for accessing the elements of a vector or matrix are
defined in @file{gsl_vector.h} and declared @code{extern inline} to
eliminate function-call overhead. If necessary you can turn off range
checking completely without modifying any source files by recompiling
your program with the preprocessor definition
@code{GSL_RANGE_CHECK_OFF}. Provided your compiler supports inline
functions the effect of turning off range checking is to replace calls
to @code{gsl_vector_get(v,i)} by @code{v->data[i]} and and calls to
@code{gsl_vector_set(v,i,x)} by @code{v->data[i] = x}. Thus there should
be no performance penalty at all for using the library functions when
range checking is turned off.

@deftypefun double gsl_vector_get (const gsl_vector * v, size_t i)
This function returns the @var{i}th element of a vector @var{v}. If
@var{i} lies outside the allowed range of 0 to @var{n-1} then the error
handler is invoked and 0 is returned.
@end deftypefun

@deftypefun void gsl_vector_set (gsl_vector * v, size_t i, double x)
This function sets the value of the @var{i}th element of a vector
@var{v} to @var{x}. If @var{i} lies outside the allowed range of 0 to
@var{n-1} then the error handler is invoked.
@end deftypefun
@c
@noindent
The following functions perform the same tasks for vectors of the type
@code{gsl_vector_float} and @code{gsl_vector_int}.

@deftypefun float gsl_vector_float_get (const gsl_vector_float * v, size_t i)
@deftypefunx void gsl_vector_float_set (gsl_vector_float * v, size_t i, float x)
These functions access the elements of a single-precision vector.
@end deftypefun

@deftypefun int gsl_vector_int_get (const gsl_vector_int * v, size_t i)
@deftypefunx void gsl_vector_int_set (gsl_vector_int * v, size_t i, int x)
These functions access the elements of an integer vector.
@end deftypefun

@node Reading and writing vectors
@section Reading and writing vectors

The library provides functions for reading and writing vectors to a file
as binary data or formatted text.

@deftypefun int gsl_vector_fwrite (FILE * stream, const gsl_vector * v)
This function writes the elements of the vector @var{v} to the stream
@var{stream} in binary format. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem writing to the file. Since the
data is written in the native binary format it may not be portable
between different architectures.
@end deftypefun

@deftypefun int gsl_vector_fread (FILE * stream, gsl_vector * v)
This function reads into the vector @var{v} from the open stream
@var{stream} in binary format. The vector @var{v} must be preallocated
with the correct length since the function uses the size of @var{v} to
determine how many bytes to read. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file. The
data is assumed to have been written in the native binary format on the
same architecture.
@end deftypefun

@deftypefun int gsl_vector_fprintf (FILE * stream, const gsl_vector * v, const char * format)
This function writes the elements of the vector @var{v} line-by-line to
the stream @var{stream} using the format specifier @var{format}, which
should be one of the @code{%g}, @code{%e} or @code{%f} formats for
floating point numbers and @code{%d} for integers. The function returns
0 for success and @code{GSL_EFAILED} if there was a problem writing to
the file.
@end deftypefun

@deftypefun int gsl_vector_fscanf (FILE * stream, gsl_vector * v)
This function reads formatted data from the stream @var{stream} into the
vector @var{v}. The vector @var{v} must be preallocated with the correct
length since the function uses the size of @var{v} to determine how many
numbers to read.  The function returns 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file.
@end deftypefun
@c
@noindent
The following functions read and write single-precision and integer
vectors with the types @code{gsl_vector_float} and
@code{gsl_vector_int}.

@deftypefun int gsl_vector_float_fwrite (FILE * stream, const gsl_vector_float * v)
@deftypefunx int gsl_vector_float_fread (FILE * stream, gsl_vector_float * v)
@deftypefunx int gsl_vector_float_fprintf (FILE * stream, const gsl_vector_float * v, const char * format)
@deftypefunx int gsl_vector_float_fscanf (FILE * stream, gsl_vector_float * v)
These functions read and write single-precision vectors as binary data
or formatted text.
@end deftypefun

@deftypefun int gsl_vector_int_fwrite (FILE * stream, const gsl_vector_int * v)
@deftypefunx int gsl_vector_int_fread (FILE * stream, gsl_vector_int * v)
@deftypefunx int gsl_vector_int_fprintf (FILE * stream, const gsl_vector_int * v, const char * format)
@deftypefunx int gsl_vector_int_fscanf (FILE * stream, gsl_vector_int * v)
These functions read and write integer vectors as binary data or
formatted text.
@end deftypefun

@node Example programs for vectors
@section Example programs for vectors

This program shows how to allocate, initialize and read from a vector
using the functions @code{gsl_vector_alloc}, @code{gsl_vector_set} and
@code{gsl_vector_get}.

@example
#include <stdio.h>
#include <gsl_vector.h>

int main ()
@{
  int i; 
  gsl_vector * v = gsl_vector_alloc (3) ;
  
  for (i = 0; i < 3; i++)
    @{
      gsl_vector_set (v, i, 1.23 + i);
    @}
  
  for (i = 0; i < 100; i++)
    @{
      printf("v_%d = %g\n", i, gsl_vector_get (v, i));
    @}
@}
@end example
@c
@noindent
Here is the output from the program. The final loop attempts to read
outside the range of the vector @code{v}, and the error is trapped by
the range-checking code in @code{gsl_vector_get}.

@example
v_0 = 1.23
v_1 = 2.23
v_2 = 3.23
gsl: vector_source.c:12: ERROR: index out of range
IOT trap/Abort (core dumped)
@end example
@c
@noindent
The next program shows how to write a vector to a file.

@example
#include <stdio.h>
#include <gsl_vector.h>

int main ()
@{
  int i; 
  gsl_vector * v = gsl_vector_calloc (100) ;
  
  for (i = 0; i < 100; i++)
    @{
      gsl_vector_set (v, i, 1.23 + i);
    @}

  @{  
     FILE * f = fopen("test.dat", "w") ;
     gsl_vector_fprintf (f, v, "%.5g");
     fclose (f);
  @}
@}
@end example
@c
@noindent
After running this program the file @file{test.dat} should contain the
elements of @code{v}, written using the format specifier
@code{%.5g}. The vector could then be read back in using the function
@code{gsl_vector_fscanf (f, v)}.

@node The matrix struct
@section The matrix struct

Matrices are defined by a @code{gsl_matrix} structure which contains
three members, the two dimensions of the matrix and a pointer to a block
of memory where the elements of the matrix are stored. The
@code{gsl_matrix} structure is very simple and looks like this,

@example
typedef struct
@{
  size_t size1;
  size_t size2;
  double * data;
@} gsl_matrix ;
@end example
@c
@noindent
The library also defines two other types of matrices, for
single-precision floating point numbers and integers which have the
names @code{gsl_matrix_float} and @code{gsl_matrix_int}.

@node Matrix allocation
@section Matrix allocation

The functions for allocating memory to a matrix follow the style of
@code{malloc} and @code{free}.  They also perform their own error
checking. If there is insufficient memory available to allocate a vector
then the functions call the GSL error handler (with an error number of
@code{GSL_ENOMEM}) in addition to returning a null pointer. Thus if you
use the library error handler to abort your program then it isn't
necessary to check every @code{alloc}.

@deftypefun {gsl_matrix *} gsl_matrix_alloc (size_t n1, size_t n2)
These functions allocate memory for a matrix and its @var{n1} @var{n2}
elements, returning a pointer to a newly initialized matrix struct.  The
elements of the matrix are not initialized and so their values are
undefined. Use the function @code{gsl_matrix_calloc} if you want to
ensure that all the elements are initialized to zero.

A null pointer is returned if insufficient memory is available to store
the matrix.
@end deftypefun

@deftypefun {gsl_matrix *} gsl_matrix_calloc (size_t n1, size_t n2)
These functions allocate memory for a matrix and initialize all the
elements of the matrix to zero.
@end deftypefun

@deftypefun void gsl_matrix_free (gsl_matrix * m)
These functions free a matrix @var{m} previously allocated with
@code{gsl_matrix_alloc} or @code{gsl_matrix_calloc}.
@end deftypefun

@c
@noindent
The following functions perform the same tasks as the functions above
for single-precision and integer matrices.

@deftypefun {gsl_matrix_float *} gsl_matrix_float_alloc (size_t n1, size_t n2)
@deftypefunx {gsl_matrix_float *} gsl_matrix_float_calloc (size_t n1, size_t n2)
@deftypefunx void gsl_matrix_float_free (gsl_matrix_float * m)
These functions perform memory management for single-precision floating
point matrices defined with the  struct @code{gsl_matrix_float}.
@end deftypefun

@deftypefun {gsl_matrix_int *} gsl_matrix_int_alloc (size_t n1, size_t n2)
@deftypefunx {gsl_matrix_int *} gsl_matrix_int_calloc (size_t n1, size_t n2)
@deftypefunx void gsl_matrix_int_free (gsl_matrix_int * m)
These functions perform memory management for integer matrices defined
with the struct @code{gsl_matrix_int}.
@end deftypefun

@node Accessing matrix elements
@section Accessing matrix elements

The functions for accessing the elements of a matrix use the same range
checking system as vectors. You turn off range checking by recompiling
your program with the preprocessor definition
@code{GSL_RANGE_CHECK_OFF}.

The elements of the matrix are stored in "C-order", where the second
index moves continuously through memory. More precisely, the element
accessed by the function @code{gsl_matrix_get(m,i,j)} and
@code{gsl_matrix_set(m,i,j,x)} is 

@example
m->data[i * n2 + j]
@end example
@c 
@noindent
where @var{n2} is the second dimension of the matrix.

@deftypefun double gsl_matrix_get (const gsl_matrix * m, size_t i, size_t j)
These functions return the (@var{i},@var{j})th element of a matrix
@var{m}. If @var{i} or @var{j} lie outside the allowed range of 0 to
@var{n1-1} and 0 to @var{n2-1} then the error handler is invoked and 0
is returned.
@end deftypefun

@deftypefun void gsl_matrix_set (gsl_matrix * m, size_t i, size_t j, double x)
These functions set the value of the (@var{i},@var{j})th element of a
matrix @var{m} to @var{x}. If @var{i} or @var{j} lies outside the
allowed range of 0 to @var{n1-1} and 0 to @var{n2-1} then the error
handler is invoked.
@end deftypefun
@c
@noindent
The following functions perform the same tasks for matrices of the type
@code{gsl_matrix_float} and @code{gsl_matrix_int}.

@deftypefun float gsl_matrix_float_get (const gsl_matrix_float * m, size_t i, size_t j)
@deftypefunx void gsl_matrix_float_set (gsl_matrix_float * m, size_t i, size_t j, float x)
These functions access the elements of a single-precision matrix.
@end deftypefun

@deftypefun int gsl_matrix_int_get (const gsl_matrix_int * m, size_t i, size_t j)
@deftypefunx void gsl_matrix_int_set (gsl_matrix_int * m, size_t i, size_t j, int x)
These functions access the elements of an integer matrix.
@end deftypefun

@node Reading and writing matrices
@section Reading and writing matrices

The library provides functions for reading and writing matrices to a file
as binary data or formatted text.

@deftypefun int gsl_matrix_fwrite (FILE * stream, const gsl_matrix * m)
This function writes the elements of the matrix @var{m} to the stream
@var{stream} in binary format. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem writing to the file. Since the
data is written in the native binary format it may not be portable
between different architectures.
@end deftypefun

@deftypefun int gsl_matrix_fread (FILE * stream, gsl_matrix * m)
This function reads into the matrix @var{m} from the open stream
@var{stream} in binary format. The matrix @var{m} must be preallocated
with the correct length since the function uses the size of @var{m} to
determine how many bytes to read. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file. The
data is assumed to have been written in the native binary format on the
same architecture.
@end deftypefun

@deftypefun int gsl_matrix_fprintf (FILE * stream, const gsl_matrix * m, const char * format)
This function writes the elements of the matrix @var{m} line-by-line to
the stream @var{stream} using the format specifier @var{format}, which
should be one of the @code{%g}, @code{%e} or @code{%f} formats for
floating point numbers and @code{%d} for integers. The function returns
0 for success and @code{GSL_EFAILED} if there was a problem writing to
the file.
@end deftypefun

@deftypefun int gsl_matrix_fscanf (FILE * stream, gsl_matrix * m)
This function reads formatted data from the stream @var{stream} into the
matrix @var{m}. The matrix @var{m} must be preallocated with the correct
length since the function uses the size of @var{m} to determine how many
numbers to read.  The function returns 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file.
@end deftypefun
@c
@noindent
The following functions read and write single-precision and integer
matrices with the types @code{gsl_matrix_float} and
@code{gsl_matrix_int}.

@deftypefun int gsl_matrix_float_fwrite (FILE * stream, const gsl_matrix_float * m)
@deftypefunx int gsl_matrix_float_fread (FILE * stream, gsl_matrix_float * m)
@deftypefunx int gsl_matrix_float_fprintf (FILE * stream, const gsl_matrix_float * m, const char * format)
@deftypefunx int gsl_matrix_float_fscanf (FILE * stream, gsl_matrix_float * m)
These functions read and write single-precision matrices as binary data
or formatted text.
@end deftypefun

@deftypefun int gsl_matrix_int_fwrite (FILE * stream, const gsl_matrix_int * m)
@deftypefunx int gsl_matrix_int_fread (FILE * stream, gsl_matrix_int * m)
@deftypefunx int gsl_matrix_int_fprintf (FILE * stream, const gsl_matrix_int * m, const char * format)
@deftypefunx int gsl_matrix_int_fscanf (FILE * stream, gsl_matrix_int * m)
These functions read and write integer matrices as binary data or
formatted text.
@end deftypefun

@node Example programs for matrices
@section Example programs for matrices

This program shows how to allocate, initialize and read from a matrix
using the functions @code{gsl_matrix_alloc}, @code{gsl_matrix_set} and
@code{gsl_matrix_get}.

@example
#include <stdio.h>
#include <gsl_matrix.h>

int main ()
@{
  int i, j; 
  gsl_matrix * m = gsl_matrix_alloc (10,3) ;
  
  for (i = 0; i < 10; i++)
    for (j = 0; j < 3; j++)
      gsl_matrix_set (m, i, j, 0.23 + 100*i + j);
  
  for (i = 0; i < 100; i++)
    for (j = 0; j < 3; j++)
      printf("m_(%d,%d) = %g\n", i, j, gsl_matrix_get (m, i, j));
@}
@end example
@c
@noindent
Here is the output from the program. The final loop attempts to read
outside the range of the matrix @code{m}, and the error is trapped by
the range-checking code in @code{gsl_matrix_get}.

@example
m_(0,0) = 0.23
m_(0,1) = 1.23
m_(0,2) = 2.23
m_(1,0) = 100.23
m_(1,1) = 101.23
m_(1,2) = 102.23
...
m_(9,2) = 902.23
gsl: matrix_source.c:13: ERROR: first index out of range
IOT trap/Abort (core dumped)
@end example
@c
@noindent
The next program shows how to write a matrix to a file.

@example
#include <stdio.h>
#include <gsl_matrix.h>

int main ()
@{
  int i, j, differences = 0; 
  gsl_matrix * m = gsl_matrix_calloc (100,100) ;
  gsl_matrix * a = gsl_matrix_calloc (100,100) ;
  
  for (i = 0; i < 100; i++)
    for (j = 0 ; j < 100; j++)
      gsl_matrix_set (m, i, j, 0.23 + i + j);

  @{  
     FILE * f = fopen("test.dat", "w") ;
     gsl_matrix_fwrite (f, m);
     fclose (f);
  @}

  @{  
     FILE * f = fopen("test.dat", "r") ;
     gsl_matrix_fread (f, a);
     fclose (f);
  @}

  for (i = 0; i < 100; i++)
    for (j = 0 ; j < 100; j++)
        if (gsl_matrix_get(m, i, j) != gsl_matrix_get(a, i, j))
           differences ++ ;

  printf("differences = %d\n", differences) ;

@}
@end example
@c
@noindent
After running this program the file @file{test.dat} should contain the
elements of @code{m}, written in binary format. The matrix which is read
back in using the function @code{gsl_matrix_fread} should be exactly
equal to the original matrix.
