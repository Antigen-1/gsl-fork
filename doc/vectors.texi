 The functions described in this chapter provide a simple vector and
matrix interface to ordinary C arrays. By writing your functions in
terms of vectors and matrices you can pass a single structure containing
both their data and dimensions without needing additional function
arguments.

@section The vector @code{struct}

Vectors are defined by a @code{gsl_vector} structure which contains two
members, the size and a pointer to a block of memory where the elements
of the vector are stored. The @code{gsl_vector} structure is very simple
and looks like this,

@example
typedef struct
@{
  size_t size;
  double * data;
@} gsl_vector ;
@end example
@c
@noindent
The library also defines two other types of vectors, for @code{floats}
and @code{ints} which have the names @code{gsl_vector_float} and
@code{gsl_vector_int}.

@section Vector allocation

@deftypefun {gsl_vector *} gsl_vector_alloc (size_t n)
@deftypefunx {gsl_vector_float *} gsl_vector_float_alloc (size_t n)
@deftypefunx {gsl_vector_int *} gsl_vector_int_alloc (size_t n)
These functions allocate memory for a vector and its @var{n} elements,
returning a pointer to a newly initialized vector struct.  The elements
of the vector are not initialized and so their values are undefined. Use
the function @code{gsl_vector_calloc} if you want to ensure that all the
elements are initialized to zero.

A null pointer is returned if insufficient memory is available to store
a vector of size @var{n}.

@end deftypefun

@deftypefun {gsl_vector *} gsl_vector_calloc (size_t n)
@deftypefunx {gsl_vector_float *} gsl_vector_float_calloc (size_t n)
@deftypefunx {gsl_vector_int *} gsl_vector_int_calloc (size_t n)
These functions allocate memory for a vector and initialize all the
elements of the vector to zero.
@end deftypefun

@deftypefun void gsl_vector_free (gsl_vector * v)
@deftypefunx void gsl_vector_float_free (gsl_vector_float * v)
@deftypefunx void gsl_vector_int_free (gsl_vector_int * v)
These functions free a vector previously allocated with
@code{gsl_vector_alloc} or @code{gsl_vector_calloc}.
@end deftypefun

@section Accessing vector elements

Unlike @sc{fortran}, the C language does not provide support for vectors
or matrices with range checking.  However, the functions
@code{gsl_vector_get} and @code{gsl_vector_set} can perform this check
for you and report an error if you attempt to access elements outside
the allowed range.

The functions for accessing the elements of a vector or matrix are
defined in @file{gsl_vector.h} and declared @code{extern inline} to
eliminate function-call overhead. If necessary you can turn off range
checking completely without modifying any source files by recompiling
your program with the preprocessor definition
@code{GSL_RANGE_CHECK_OFF}.

@deftypefun double gsl_vector_get (const gsl_vector * v, size_t i)
@deftypefunx float gsl_vector_float_get (const gsl_vector_float * v, size_t i)
@deftypefunx int gsl_vector_int_get (const gsl_vector_int * v, size_t i)
@end deftypefun

@deftypefun void gsl_vector_set (gsl_vector * v, size_t i, double x)
@deftypefunx void gsl_vector_float_set (gsl_vector_float * v, size_t i, float x)
@deftypefunx void gsl_vector_int_set (gsl_vector_int * v, size_t i, int x)
@end deftypefun

@section Examples


@example
#include <stdio.h>
#include <gsl_vector.h>

int main ()
@{
  int i; 
  gsl_vector * v;
  
  v = gsl_vector_alloc (3) ;
  
  for (i = 0; i < 3; i++)
    @{
      gsl_vector_set (v, i, 1.23 + i);
    @}
  
  for (i = 0; i < 100; i++)
    @{
      printf("v_%d = %g\n", i, gsl_vector_get (v, i));
    @}
@}
@end example

@example
v_0 = 1.23
v_1 = 2.23
v_2 = 3.23
gsl: vector_source.c:12: ERROR: index out of range
IOT trap/Abort (core dumped)
@end example

