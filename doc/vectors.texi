 The functions described in this chapter provide a simple vector and
matrix interface to ordinary C arrays. By writing your functions in
terms of vectors and matrices you can pass a single structure containing
both their data and dimensions without needing additional function
arguments.

@menu
* The vector struct::    
* Vector allocation::           
* Accessing vector elements::   
* Reading and writing vectors::  
* Examples of vectors::         
@end menu

@node The vector struct
@section The vector struct

Vectors are defined by a @code{gsl_vector} structure which contains two
members, the size and a pointer to a block of memory where the elements
of the vector are stored. The @code{gsl_vector} structure is very simple
and looks like this,

@example
typedef struct
@{
  size_t size;
  double * data;
@} gsl_vector ;
@end example
@c
@noindent
The library also defines two other types of vectors, for @code{floats}
and @code{ints} which have the names @code{gsl_vector_float} and
@code{gsl_vector_int}.

@node Vector allocation
@section Vector allocation

@deftypefun {gsl_vector *} gsl_vector_alloc (size_t n)
@deftypefunx {gsl_vector_float *} gsl_vector_float_alloc (size_t n)
@deftypefunx {gsl_vector_int *} gsl_vector_int_alloc (size_t n)
These functions allocate memory for a vector and its @var{n} elements,
returning a pointer to a newly initialized vector struct.  The elements
of the vector are not initialized and so their values are undefined. Use
the function @code{gsl_vector_calloc} if you want to ensure that all the
elements are initialized to zero.

A null pointer is returned if insufficient memory is available to store
a vector of size @var{n}.

@end deftypefun

@deftypefun {gsl_vector *} gsl_vector_calloc (size_t n)
@deftypefunx {gsl_vector_float *} gsl_vector_float_calloc (size_t n)
@deftypefunx {gsl_vector_int *} gsl_vector_int_calloc (size_t n)
These functions allocate memory for a vector and initialize all the
elements of the vector to zero.
@end deftypefun

@deftypefun void gsl_vector_free (gsl_vector * v)
@deftypefunx void gsl_vector_float_free (gsl_vector_float * v)
@deftypefunx void gsl_vector_int_free (gsl_vector_int * v)
These functions free a vector previously allocated with
@code{gsl_vector_alloc} or @code{gsl_vector_calloc}.
@end deftypefun

@node Accessing vector elements
@section Accessing vector elements

Unlike @sc{fortran}, the C language does not provide support for range
checking of vectors and matrices. However, the functions
@code{gsl_vector_get} and @code{gsl_vector_set} can perform this check
for you and report an error if you attempt to access elements outside
the allowed range.

The functions for accessing the elements of a vector or matrix are
defined in @file{gsl_vector.h} and declared @code{extern inline} to
eliminate function-call overhead. If necessary you can turn off range
checking completely without modifying any source files by recompiling
your program with the preprocessor definition
@code{GSL_RANGE_CHECK_OFF}.

@deftypefun double gsl_vector_get (const gsl_vector * v, size_t i)
@deftypefunx float gsl_vector_float_get (const gsl_vector_float * v, size_t i)
@deftypefunx int gsl_vector_int_get (const gsl_vector_int * v, size_t i)
These functions return the @var{i}th element of a vector @var{v}. If
@var{i} lies outside the allowed range of 0 to @var{n-1} then the error
handler is invoked and 0 is returned.
@end deftypefun

@deftypefun void gsl_vector_set (gsl_vector * v, size_t i, double x)
@deftypefunx void gsl_vector_float_set (gsl_vector_float * v, size_t i, float x)
@deftypefunx void gsl_vector_int_set (gsl_vector_int * v, size_t i, int x)
These functions set the value of the @var{i}th element of a vector
@var{v} to @var{x}. If @var{i} lies outside the allowed range of 0 to
@var{n-1} then the error handler is invoked.
@end deftypefun

@node Reading and writing vectors
@section  Reading and writing vectors

@deftypefun int gsl_vector_fread (FILE * stream, gsl_vector * v)
This function reads from the open file @var{stream}. The vector @var{v}
must be preallocated with the correct length. The function uses the size
of @var{v} to determine how many bytes to read. The function returns 0
for success and @code{GSL_EFAILED} to indicate that there was a problem
reading from the file.
@end deftypefun

@deftypefun int gsl_vector_fwrite (FILE * stream, const gsl_vector * v)
This function writes the elements of the vector @var{v} on 
@end deftypefun

@node Examples of vectors
@section Examples of vectors

@example
#include <stdio.h>
#include <gsl_vector.h>

int main ()
@{
  int i; 
  gsl_vector * v;
  
  v = gsl_vector_alloc (3) ;
  
  for (i = 0; i < 3; i++)
    @{
      gsl_vector_set (v, i, 1.23 + i);
    @}
  
  for (i = 0; i < 100; i++)
    @{
      printf("v_%d = %g\n", i, gsl_vector_get (v, i));
    @}
@}
@end example

@example
v_0 = 1.23
v_1 = 2.23
v_2 = 3.23
gsl: vector_source.c:12: ERROR: index out of range
IOT trap/Abort (core dumped)
@end example

