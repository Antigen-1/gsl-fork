@cindex vectors

The functions described in this chapter provide a simple vector and
matrix interface to ordinary C arrays. By writing your functions in
terms of vectors and matrices you can pass a single structure containing
both data and dimensions without needing additional function arguments.
The structures are compatible with the vector and matrix formats used by
BLAS routines.

@menu
* The block struct::            
* Block allocation::            
* Reading and writing blocks::  
* Example programs for blocks::  
* The vector struct::           
* Vector allocation::           
* Accessing vector elements::   
* Reading and writing vectors::  
* Copying vectors::             
* Example programs for vectors::  
* The matrix struct::           
* Matrix allocation::           
* Accessing matrix elements::   
* Reading and writing matrices::  
* Slicing rows and columns::    
* Copying rows and columns::    
* Example programs for matrices::  
@end menu

@node The block struct
@section The block struct

For consistency all memory is allocated through a @code{gsl_block}
structure. The structure contains two members, the size of an area of
memory and a pointer to the memory. The @code{gsl_block} structure looks
like this,

@example
typedef struct
@{
  size_t size;
  double * data;
@} gsl_block ;
@end example
@comment
@noindent
Vectors and matrices are made by @dfn{slicing} an underlying block.  The
memory is always ``owned'' by the block, so there is no ambiguity about
when it will be deallocated. The memory can only be deallocated by
freeing the block itself.

The functions for allocating and deallocating blocks are defined in
@file{gsl_block.h}

@node Block allocation
@section Block allocation

The functions for allocating memory to a block follow the style of
@code{malloc} and @code{free}. In addition they also perform their own
error checking. If there is insufficient memory available to allocate a
block then the functions call the GSL error handler (with an error
number of @code{GSL_ENOMEM}) in addition to returning a null
pointer. Thus if you use the library error handler to abort your program
then it isn't necessary to check every @code{alloc}.

@deftypefun {gsl_block *} gsl_block_alloc (size_t @var{n})
This function allocates memory for a block of @var{n} elements,
returning a pointer to the block struct.  The block is not initialized
and so the values of its elements are undefined. Use the function
@code{gsl_block_calloc} if you want to ensure that all the elements are
initialized to zero.

A null pointer is returned if insufficient memory is available to create
the block.
@end deftypefun

@deftypefun {gsl_block *} gsl_block_calloc (size_t @var{n})
This function allocates memory for a block and initializes all the
elements of the block to zero.
@end deftypefun

@deftypefun void gsl_block_free (gsl_block * @var{b})
This function frees the memory used by a block @var{b} previously
allocated with @code{gsl_block_alloc} or @code{gsl_block_calloc}.
@end deftypefun

@node Reading and writing blocks
@section Reading and writing blocks

The library provides functions for reading and writing blocks to a file
as binary data or formatted text.

@deftypefun int gsl_block_fwrite (FILE * @var{stream}, const gsl_block * @var{b})
This function writes the elements of the block @var{b} to the stream
@var{stream} in binary format. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem writing to the file. Since the
data is written in the native binary format it may not be portable
between different architectures.
@end deftypefun

@deftypefun int gsl_block_fread (FILE * @var{stream}, gsl_block * @var{b})
This function reads into the block @var{b} from the open stream
@var{stream} in binary format. The block @var{b} must be preallocated
with the correct length since the function uses the size of @var{b} to
determine how many bytes to read. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file. The
data is assumed to have been written in the native binary format on the
same architecture.
@end deftypefun

@deftypefun int gsl_block_fprintf (FILE * @var{stream}, const gsl_block * @var{b}, const char * @var{format})
This function writes the elements of the block @var{b} line-by-line to
the stream @var{stream} using the format specifier @var{format}, which
should be one of the @code{%g}, @code{%e} or @code{%f} formats for
floating point numbers and @code{%d} for integers. The function returns
0 for success and @code{GSL_EFAILED} if there was a problem writing to
the file.
@end deftypefun

@deftypefun int gsl_block_fscanf (FILE * @var{stream}, gsl_block * @var{b})
This function reads formatted data from the stream @var{stream} into the
block @var{b}. The block @var{b} must be preallocated with the correct
length since the function uses the size of @var{b} to determine how many
numbers to read.  The function returns 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file.
@end deftypefun
@comment

@node Example programs for blocks
@section Example programs for blocks

The following program shows how to allocate a block,

@example
#include <stdio.h>
#include <gsl_block.h>

int main ()
@{
  gsl_block * b = gsl_block_alloc (100) ;
  
  printf("length of block = %u\n", b->size);
  printf("block data address = %#x\n", b->data);

  gsl_block_free (b);
@}
@end example
@comment
@noindent
Here is the output from the program,

@example
length of block = 100
block data address = 0x804b0d8
@end example
@comment

@node The vector struct
@section The vector struct

Vectors are defined by a @code{gsl_vector} structure which describes a
slice of a block. A vector represents a @dfn{view} of an area of memory,
and different vectors can be created which point to the same block. For
example, it is possible to make two vectors which point to the even and
odd elements of a third vector, or to make vectors which correspond to
the rows and columns of a matrix.

The @code{gsl_vector} structure contains three members, the @dfn{size},
the @dfn{stride} and a pointer to a block of memory where the elements
are stored. The structure is very simple and looks like this,

@example
typedef struct
@{
  size_t size;
  size_t stride;
  double * data;
@} gsl_vector ;
@end example
@comment
@noindent
The @var{size} is simply the number of vector elements. The range of
valid indices runs from 0 to @code{size-1}.  The @var{stride} is the
step-size from one element to the next.

The functions for allocating and accessing vectors are defined in
@file{gsl_vector.h}

@node Vector allocation
@section Vector allocation

The functions for allocating memory to a vector follow the style of
@code{malloc} and @code{free}. In addition they also perform their own
error checking. If there is insufficient memory available to allocate a
vector then the functions call the GSL error handler (with an error
number of @code{GSL_ENOMEM}) in addition to returning a null
pointer. Thus if you use the library error handler to abort your program
then it isn't necessary to check every @code{alloc}.

@deftypefun {gsl_vector *} gsl_vector_alloc (gsl_block * @var{b}, size_t @var{offset}, size_t @var{n}, size_t @var{stride})
This function creates a vector as a slice of the block @var{b},
returning a pointer to a newly initialized vector struct. The start of
the vector is offset by @var{offset} elements from the start of the
block. The vector has @var{n} elements, with a step-size of @var{stride}
from one element to the next.  Mathematically, the @var{i}-th element of
the vector is given by,

@example
v(i) = b->data[offset + i*stride]
@end example
@noindent
where the index @var{i} runs from 0 to @code{n-1}.

A null pointer is returned if the combined parameters
(@var{offset},@var{n},@var{stride}) overrun the end of the block or if
insufficient memory is available to store the vector.
@end deftypefun

@deftypefun {gsl_vector *} gsl_vector_alloc_from_vector (gsl_vector * @var{v}, size_t @var{offset}, size_t @var{n}, size_t @var{stride})
This function creates a vector as a slice of another vector @var{v},
returning a pointer to a newly initialized vector struct. The start of
the new vector is offset by @var{offset} elements from the start of the
original vector. The new vector has @var{n} elements, with a step-size
of @var{stride} from one element to the next in the original vector.
Mathematically, the @var{i}-th element of the new vector @var{v'} is
given by,

@example
v'(i) = v->data[(offset + i*stride)*v->stride]
@end example
@noindent
where the index @var{i} runs from 0 to @code{n-1}.

A null pointer is returned if the combined parameters
(@var{offset},@var{n},@var{stride}) overrun the end of the original
vector or if insufficient memory is available store the new vector.
@end deftypefun


@deftypefun void gsl_vector_free (gsl_vector * @var{v})
This function frees a vector @var{v} previously allocated with
@code{gsl_vector_alloc} or @code{gsl_vector_alloc_from_vector}. The
block underlying the vector must be deallocated separately.
@end deftypefun

@node Accessing vector elements
@section Accessing vector elements
@cindex vectors, range-checking
@cindex range-checking for vectors

Unlike @sc{fortran} compilers, C compilers do not usually provide
support for range checking of vectors and matrices. However, the
functions @code{gsl_vector_get} and @code{gsl_vector_set} can perform
range checking for you and report an error if you attempt to access
elements outside the allowed range.

The functions for accessing the elements of a vector or matrix are
defined in @file{gsl_vector.h} and declared @code{extern inline} to
eliminate function-call overhead. If necessary you can turn off range
checking completely without modifying any source files by recompiling
your program with the preprocessor definition
@code{GSL_RANGE_CHECK_OFF}. Provided your compiler supports inline
functions the effect of turning off range checking is to replace calls
to @code{gsl_vector_get(v,i)} by @code{v->data[i*v->stride]} and and
calls to @code{gsl_vector_set(v,i,x)} by @code{v->data[i*v->stride]=x}.
Thus there should be no performance penalty for using the range checking
functions when range checking is turned off.

@deftypefun double gsl_vector_get (const gsl_vector * @var{v}, size_t @var{i})
This function returns the @var{i}-th element of a vector @var{v}. If
@var{i} lies outside the allowed range of 0 to @var{n-1} then the error
handler is invoked and 0 is returned.
@end deftypefun

@deftypefun void gsl_vector_set (gsl_vector * @var{v}, size_t @var{i}, double @var{x})
This function sets the value of the @var{i}-th element of a vector
@var{v} to @var{x}. If @var{i} lies outside the allowed range of 0 to
@var{n-1} then the error handler is invoked.
@end deftypefun

@node Reading and writing vectors
@section Reading and writing vectors

The library provides functions for reading and writing vectors to a file
as binary data or formatted text.

@deftypefun int gsl_vector_fwrite (FILE * @var{stream}, const gsl_vector * @var{v})
This function writes the elements of the vector @var{v} to the stream
@var{stream} in binary format. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem writing to the file. Since the
data is written in the native binary format it may not be portable
between different architectures.
@end deftypefun

@deftypefun int gsl_vector_fread (FILE * @var{stream}, gsl_vector * @var{v})
This function reads into the vector @var{v} from the open stream
@var{stream} in binary format. The vector @var{v} must be preallocated
with the correct length since the function uses the size of @var{v} to
determine how many bytes to read. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file. The
data is assumed to have been written in the native binary format on the
same architecture.
@end deftypefun

@deftypefun int gsl_vector_fprintf (FILE * @var{stream}, const gsl_vector * @var{v}, const char * @var{format})
This function writes the elements of the vector @var{v} line-by-line to
the stream @var{stream} using the format specifier @var{format}, which
should be one of the @code{%g}, @code{%e} or @code{%f} formats for
floating point numbers and @code{%d} for integers. The function returns
0 for success and @code{GSL_EFAILED} if there was a problem writing to
the file.
@end deftypefun

@deftypefun int gsl_vector_fscanf (FILE * @var{stream}, gsl_vector * @var{v})
This function reads formatted data from the stream @var{stream} into the
vector @var{v}. The vector @var{v} must be preallocated with the correct
length since the function uses the size of @var{v} to determine how many
numbers to read.  The function returns 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file.
@end deftypefun

@node Copying vectors
@section Copying vectors

@deftypefun int gsl_vector_copy (gsl_vector_float * @var{dest}, const gsl_vector * @var{src})
This function copies the elements of the vector @var{src} into the
vector @var{dest}. The two vectors must be the same length.
@end deftypefun

@node Example programs for vectors
@section Example programs for vectors

This program shows how to allocate, initialize and read from a vector
using the functions @code{gsl_vector_alloc}, @code{gsl_vector_set} and
@code{gsl_vector_get}.

@example
#include <stdio.h>
#include <gsl_vector.h>

int main ()
@{
  int i;
  gsl_block * b = gsl_block_alloc (3) ; 
  gsl_vector * v = gsl_vector_alloc (b, 0, 3, 1) ;  /* stride = 1 */
  
  for (i = 0; i < 3; i++)
    @{
      gsl_vector_set (v, i, 1.23 + i);
    @}
  
  for (i = 0; i < 100; i++)
    @{
      printf("v_%d = %g\n", i, gsl_vector_get (v, i));
    @}
@}
@end example
@comment
@noindent
Here is the output from the program. The final loop attempts to read
outside the range of the vector @code{v}, and the error is trapped by
the range-checking code in @code{gsl_vector_get}.

@example
v_0 = 1.23
v_1 = 2.23
v_2 = 3.23
gsl: vector_source.c:12: ERROR: index out of range
IOT trap/Abort (core dumped)
@end example
@comment
@noindent
The next program shows how to write a vector to a file.

@example
#include <stdio.h>
#include <gsl_vector.h>

int main ()
@{
  int i; 
  gsl_block * b = gsl_block_calloc (100);
  gsl_vector * v = gsl_vector_alloc (b, 0, 100, 1) ;
  
  for (i = 0; i < 100; i++)
    @{
      gsl_vector_set (v, i, 1.23 + i);
    @}

  @{  
     FILE * f = fopen("test.dat", "w") ;
     gsl_vector_fprintf (f, v, "%.5g");
     fclose (f);
  @}
@}
@end example
@comment
@noindent
After running this program the file @file{test.dat} should contain the
elements of @code{v}, written using the format specifier
@code{%.5g}. The vector could then be read back in using the function
@code{gsl_vector_fscanf (f, v)}.

@node The matrix struct
@section The matrix struct
@cindex matrices

Matrices are defined by a @code{gsl_matrix} structure which describes a
generalized slice of a block. Like a vector it represents a @dfn{view}
of an area of memory, but uses two indices instead of one.

The @code{gsl_matrix} structure contains four members, the two
dimensions of the matrix, a physical dimension (which determines the
memory layout and can differ from the matrix dimension to allow the use
of submatrices), and a pointer to a block of memory where the elements
of the matrix are stored. The @code{gsl_matrix} structure is very simple
and looks like this,

@example
typedef struct
@{
  size_t size1;
  size_t size2;
  size_t dim2;
  double * data;
@} gsl_matrix ;
@end example
@comment
@noindent
Matrices are assumed to be stored in row-major order, meaning that each
row of elements forms a contiguous block in memory.  The number of rows
is @var{size1}. The range of valid row indices runs from 0 to
@code{size1-1}. Similarly @var{size2} is simply the number of
columns. The range of valid column indices runs from 0 to
@code{size2-1}. The physical row dimension @var{dim2} specifies the size
of a row of the matrix as laid out in memory.

For example, in the following matrix @var{size1} is 3, @var{size2} is 4,
and @var{dim2} is 8.  The physical memory layout of the matrix begins in
the top left hand-corner and proceeds from left to right along each row
in turn.

@example
00 01 02 03 .. .. .. ..
10 11 12 13 .. .. .. ..
20 21 22 23 .. .. .. ..
@end example

The functions for allocating and accessing matrices are defined in
@file{gsl_matrix.h}

@node Matrix allocation
@section Matrix allocation

The functions for allocating memory to a matrix follow the style of
@code{malloc} and @code{free}.  They also perform their own error
checking. If there is insufficient memory available to allocate a vector
then the functions call the GSL error handler (with an error number of
@code{GSL_ENOMEM}) in addition to returning a null pointer. Thus if you
use the library error handler to abort your program then it isn't
necessary to check every @code{alloc}.

@deftypefun {gsl_matrix *} gsl_matrix_alloc (gsl_block * @var{b}, size_t @var{offset}, size_t @var{n1}, size_t @var{n2}, size_t @var{dim2})

This function creates a matrix as a slice of the block @var{b},
returning a pointer to a newly initialized matrix struct. The start of
the matrix is offset by @var{offset} elements from the start of the
block. The matrix has @var{n1} rows and @var{n2} columns, with the
physical number of columns in memory given by @var{dim2}.
Mathematically, the (@var{i},@var{j})-th element of the matrix is given by,

@example
m(i,j) = b->data[offset + i*dim2 + j]
@end example
@noindent
where the index @var{i} runs from 0 to @code{n1-1} and the index @var{j}
runs from 0 to @code{n2-1}.

A null pointer is returned if the combined parameters
(@var{offset},@var{n1},@var{n2},@var{dim2}) overrun the end of the block
or if insufficient memory is available to store the matrix.
@end deftypefun

@deftypefun {gsl_matrix *} gsl_matrix_alloc_from_matrix (gsl_matrix * @var{m}, size_t @var{k1}, size_t @var{k2}, size_t @var{n1}, size_t @var{n2})

This function creates a matrix as a submatrix of the matrix @var{m},
returning a pointer to a newly initialized matrix struct. The upper-left
element of the submatrix is the element (@var{k1},@var{k2}) of the
original matrix. The submatrix has @var{n1} rows and @var{n2} columns.
The physical number of columns in memory given by @var{dim2} is
unchanged.  Mathematically, the (@var{i},@var{j})-th element of the
new matrix is given by,

@example
m'(i,j) = m->data[(k1*m->dim2 + k2) + i*m->dim2 + j]
@end example
@noindent
where the index @var{i} runs from 0 to @code{n1-1} and the index @var{j}
runs from 0 to @code{n2-1}.

A null pointer is returned if the combined parameters
(@var{k1},@var{k2},@var{n1},@var{n2},@var{dim2}) overrun the end of the
original matrix or if insufficient memory is available to store the matrix.
@end deftypefun

@deftypefun void gsl_matrix_free (gsl_matrix * @var{m})
This function frees a matrix @var{m} previously allocated with
@code{gsl_matrix_alloc} or @code{gsl_matrix_alloc_from_matrix}. The
block underlying the matrix must be deallocated separately.
@end deftypefun

@node Accessing matrix elements
@section Accessing matrix elements
@cindex matrices, range-checking
@cindex range-checking for matrices

The functions for accessing the elements of a matrix use the same range
checking system as vectors. You turn off range checking by recompiling
your program with the preprocessor definition
@code{GSL_RANGE_CHECK_OFF}.

The elements of the matrix are stored in "C-order", where the second
index moves continuously through memory. More precisely, the element
accessed by the function @code{gsl_matrix_get(m,i,j)} and
@code{gsl_matrix_set(m,i,j,x)} is 

@example
m->data[i * m->dim2 + j]
@end example
@comment 
@noindent
where @var{dim2} is the physical row-length of the matrix.

@deftypefun double gsl_matrix_get (const gsl_matrix * @var{m}, size_t @var{i}, size_t @var{j})
These functions return the (@var{i},@var{j})th element of a matrix
@var{m}. If @var{i} or @var{j} lie outside the allowed range of 0 to
@var{n1-1} and 0 to @var{n2-1} then the error handler is invoked and 0
is returned.
@end deftypefun

@deftypefun void gsl_matrix_set (gsl_matrix * @var{m}, size_t @var{i}, size_t @var{j}, double @var{x})
These functions set the value of the (@var{i},@var{j})th element of a
matrix @var{m} to @var{x}. If @var{i} or @var{j} lies outside the
allowed range of 0 to @var{n1-1} and 0 to @var{n2-1} then the error
handler is invoked.
@end deftypefun

@node Reading and writing matrices
@section Reading and writing matrices

The library provides functions for reading and writing matrices to a file
as binary data or formatted text.

@deftypefun int gsl_matrix_fwrite (FILE * @var{stream}, const gsl_matrix * @var{m})
This function writes the elements of the matrix @var{m} to the stream
@var{stream} in binary format. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem writing to the file. Since the
data is written in the native binary format it may not be portable
between different architectures.
@end deftypefun

@deftypefun int gsl_matrix_fread (FILE * @var{stream}, gsl_matrix * @var{m})
This function reads into the matrix @var{m} from the open stream
@var{stream} in binary format. The matrix @var{m} must be preallocated
with the correct length since the function uses the size of @var{m} to
determine how many bytes to read. The return value is 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file. The
data is assumed to have been written in the native binary format on the
same architecture.
@end deftypefun

@deftypefun int gsl_matrix_fprintf (FILE * @var{stream}, const gsl_matrix * @var{m}, const char * @var{format})
This function writes the elements of the matrix @var{m} line-by-line to
the stream @var{stream} using the format specifier @var{format}, which
should be one of the @code{%g}, @code{%e} or @code{%f} formats for
floating point numbers and @code{%d} for integers. The function returns
0 for success and @code{GSL_EFAILED} if there was a problem writing to
the file.
@end deftypefun

@deftypefun int gsl_matrix_fscanf (FILE * @var{stream}, gsl_matrix * @var{m})
This function reads formatted data from the stream @var{stream} into the
matrix @var{m}. The matrix @var{m} must be preallocated with the correct
length since the function uses the size of @var{m} to determine how many
numbers to read.  The function returns 0 for success and
@code{GSL_EFAILED} if there was a problem reading from the file.
@end deftypefun

@node Slicing rows and columns
@section Slicing rows and columns

In general there are two ways to access an object, by reference or by
copying. The functions described in this section create vectors which
allow access to a row or column of a matrix by reference. Modifying
elements of the vector is equivalent to modifying the matrix, since both
the vector and the matrix point to the same memory block.

@deftypefun {gsl_vector *} gsl_vector_alloc_row_from_matrix (gsl_matrix * @var{m}, size_t @var{i})
This function allocates a new @code{gsl_vector} struct which points to
the @var{i}-th row of the matrix @var{m}.
@end deftypefun

@deftypefun {gsl_vector *} gsl_vector_alloc_col_from_matrix (gsl_matrix * @var{m}, size_t @var{j})
This function allocates a new @code{gsl_vector} struct which points to
the @var{j}-th column of the matrix @var{m}.
@end deftypefun

@node Copying rows and columns
@section Copying rows and columns

The functions described in this section copy a row or column of a matrix
into a vector. This allows the elements of the vector and the matrix to
be modified independently. Note that if the matrix and the vector point
to overlapping regions of memory then the results of the copying are
undefined.

@deftypefun int gsl_matrix_copy_row (gsl_vector * @var{v}, const gsl_matrix * @var{m}, size_t @var{i})
This function copies the elements of the @var{i}-th row of the matrix
@var{m} into the vector @var{v}. The length of the vector must be the
same as the length of the row.
@end deftypefun

@deftypefun int gsl_matrix_copy_col (gsl_vector * @var{v}, const gsl_matrix * @var{m}, size_t @var{j})
This function copies the elements of the @var{i}-th column of the matrix
@var{m} into the vector @var{v}. The length of the vector must be the
same as the length of the column.
@end deftypefun

@deftypefun int gsl_matrix_set_row (gsl_matrix * @var{m}, size_t @var{i}, const gsl_vector * @var{v})
This function copies the elements of the vector @var{v} into the
@var{i}-th row of the matrix @var{m}. The length of the vector must be
the same as the length of the row.
@end deftypefun

@deftypefun int gsl_matrix_set_col (gsl_matrix * @var{m}, size_t @var{j}, const gsl_vector * @var{v})
This function copies the elements of the vector @var{v} into the
@var{i}-th column of the matrix @var{m}. The length of the vector must be
the same as the length of the column.
@end deftypefun

@node Example programs for matrices
@section Example programs for matrices

This program shows how to allocate, initialize and read from a matrix
using the functions @code{gsl_matrix_alloc}, @code{gsl_matrix_set} and
@code{gsl_matrix_get}.

@example
#include <stdio.h>
#include <gsl_matrix.h>

int main ()
@{
  int i, j; 
  gsl_block * b = gsl_block_alloc (10*3);
  gsl_matrix * m = gsl_matrix_alloc (b, 0, 10, 3, 3) ;
  
  for (i = 0; i < 10; i++)
    for (j = 0; j < 3; j++)
      gsl_matrix_set (m, i, j, 0.23 + 100*i + j);
  
  for (i = 0; i < 100; i++)
    for (j = 0; j < 3; j++)
      printf("m(%d,%d) = %g\n", i, j, gsl_matrix_get (m, i, j));
@}
@end example
@comment
@noindent
Here is the output from the program. The final loop attempts to read
outside the range of the matrix @code{m}, and the error is trapped by
the range-checking code in @code{gsl_matrix_get}.

@example
m(0,0) = 0.23
m(0,1) = 1.23
m(0,2) = 2.23
m(1,0) = 100.23
m(1,1) = 101.23
m(1,2) = 102.23
...
m(9,2) = 902.23
gsl: matrix_source.c:13: ERROR: first index out of range
IOT trap/Abort (core dumped)
@end example
@comment
@noindent
The next program shows how to write a matrix to a file.

@example
#include <stdio.h>
#include <gsl_matrix.h>

int main ()
@{
  int i, j, differences = 0; 
  gsl_block * bm = gsl_block_calloc (100*100);
  gsl_block * ba = gsl_block_calloc (100*100);
  gsl_matrix * m = gsl_matrix_alloc (bm, 0, 100, 100, 100) ;
  gsl_matrix * a = gsl_matrix_alloc (ba, 0, 100, 100, 100) ;
  
  for (i = 0; i < 100; i++)
    for (j = 0 ; j < 100; j++)
      gsl_matrix_set (m, i, j, 0.23 + i + j);

  @{  
     FILE * f = fopen("test.dat", "w") ;
     gsl_matrix_fwrite (f, m);
     fclose (f);
  @}

  @{  
     FILE * f = fopen("test.dat", "r") ;
     gsl_matrix_fread (f, a);
     fclose (f);
  @}

  for (i = 0; i < 100; i++)
    for (j = 0 ; j < 100; j++)
        if (gsl_matrix_get(m, i, j) != gsl_matrix_get(a, i, j))
           differences ++ ;

  printf("differences = %d (should be zero)\n", differences) ;

@}
@end example
@comment
@noindent
After running this program the file @file{test.dat} should contain the
elements of @code{m}, written in binary format. The matrix which is read
back in using the function @code{gsl_matrix_fread} should be exactly
equal to the original matrix.
