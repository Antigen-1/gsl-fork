\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename gsl-design.info
@settitle GNU Scientific Library
@finalout
@c -@setchapternewpage odd
@c %**end of header

@dircategory Scientific software
@direntry
* GSL-design: (GSL-design).             GNU Scientific Library -- Design
@end direntry

@comment @include version-design.texi
@set GSL @emph{GNU Scientific Library}

@ifinfo
This file documents the @value{GSL}.

Copyright (C) 1996 The GSL Project.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end ifinfo

@titlepage
@title GNU Scientific Library -- Design document
@subtitle Edition @value{EDITION}, for gsl Version @value{VERSION}
@subtitle @value{UPDATED}
@author Mark Galassi @footnote{Cygnus Solutions and Los Alamos National Laboratory}
@author @email{rosalia@@lanl.gov}
@author
@author James Theiler @footnote{Astrophysics and Radiation Measurements group, Los Alamos National Laboratory}
@author @email{jt@@nis.lanl.gov}
@author
@author Brian Gough @footnote{Network Theory Limited}
@author @email{bjg@@network-theory.co.uk}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1996,1997 The GSL Project.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Foundation.
@end titlepage

@node Top, Motivation, (dir), (dir)
@top GSL

@ifinfo
This file documents the the @value{GSL}, a collection
of numerical routines for scientific computing.
@end ifinfo

@menu
* Motivation::                  
* Design::                      
* Copying::                     
* Function Index::              
* Variable Index::              
* Type Index::                  
@end menu

@node Motivation
@chapter Motivation
@cindex numerical analysis
@cindex free software

There is a need for scientists and engineers to have a numerical
analysis library that:
@itemize @bullet
@item
is free (in the sense of freedom, not in the sense of gratis; see the
GNU General Public License), so that people can use that library,
redistribute it, modify it @dots{}
@item
is written in C using modern coding conventions, calling conventions,
scoping @dots{}
@item
is clearly and pedagogically documented; preferably with TeXinfo, so as
to allow online info, WWW and TeX output.
@item
uses top quality state-of-the-art algorithms.
@item
is portable and configurable using @emph{autoconf} and @emph{automake}.
@item
basically, is GNUlitically correct.
@item
whatever...
@end itemize

There are strengths and weaknesses with existing libraries:

@emph{Netlib} (http://www.netlib.org/) is probably the most advanced set
of numerical algorithms available on the net, maintained by AT&T.
Unfortunately most of the software is written in Fortran, with strange
calling conventions in many places.  It is also not very well collected,
so it is a lot of work to get started with netlib.

@emph{GAMS} (http://gams.nist.gov/) is an extremely well organized set
of pointers to scientific software, but like netlib, the individual
routines vary in their quality and their level of documentation.

@emph{Numerical Recipies} (http://www.nr.com,
http://cfata2.harvard.edu/nr/) is an excellent book: it explains the
algorithms in a very clear way.  Unfortunately the authors released the
source code under a license which allows you to use it, but prevents you
from re-distributing it.  Thus Numerical Recipes is not @emph{free} in
the sense of @emph{freedom}.  On top of that, the implementation suffers
from @emph{fortranitis} and other
limitations. [http://www.lysator.liu.se/c/num-recipes-in-c.html]

@menu
* jt section::                  
@end menu

@node jt section
@section jt section

[written by James Theiler, and not incorporated into the above
motivation]

@value{GSL} is a library of scientific subroutines.  It aims to provide
a convenient interface to ``black box'' routines that do standard (and
not so standard) tasks that arise in scientific research.  More than
that, it also provides the source code.  Users are welcome to alter,
adjust, modify, and improve the interfaces and/or implementations of
whichever routines might be needed for a particular purpose.  We are
starting small, with random number generators and special functions, but
hope to expand to include linear algebra, Fourier analysis, etc.

@c The secret name of this package is GNUmerical Recipes.

@c As much as we might grumble about them, we have great admiration for the
@c Numerical Recipes series.  This is perhaps the cheapest ($80 buys you
@c the book and a single-screen license) and most comprehensive collection
@c of good numerical software available.  We know of very few working
@c scientists who do not have a copy of one of the Numerical Recipes books
@c on their shelf.  
@c 
@c The software is not always the latest and greatest, and complaints about
@c this have appeared from time to time, but it has several noteworthy strengths
@c which we think accounts for its incredible success over the last decade.
@c 
@c Most noteworthy is the book itself.  Each routine is preceeded by a
@c readable, lively (if somewhat condescending) discussion of the issues at
@c hand.  The issues include: why one might want to use such a routine in
@c the first place, what tradeoffs in terms of accuracy or efficiency have
@c to be made in the implementation, etc.  And the book covers a remarkable
@c range of topics, from linear algebra to nonlinear optimization.  
@c 
@c Almost as remarkable is that the authors included the source code.
@c Indeed, the source code is enshrined (well, typeset) in the text of the
@c Numerical Recipes book.  Users are invited to modify the code to fit
@c their needs, to pick and choose which routines (or which parts of
@c routines) to use or adapt for their particular applications.  Though the
@c routines can be (and usually are) used as black boxes, it makes
@c scientists happy and more comfortable to be able to look under the hood.
@c 
@c The main problem with Numerical Recipes is that the code is not free.
@c It may seem petty to complain about this.  People don't complain that
@c IMSL isn't free.  Part of the problem is the unusual (bizarre)
@c per-screen license.  But the main problem is that source code is
@c provided, and so it is essentially impossible to enforce the license,
@c except by intimidation.  Numerical Recipes is probably the most pirated
@c software (well... pirating Microsoft doesn't count) available.  To the
@c authors' credit, Numerical Recipes software is inexpensive and easily
@c obtainable.  It is easy to incorporate into your own applications.  But
@c as long as it contains NR subroutines, you cannot legally exchange your
@c code with your colleagues.  You can try to be careful and isolate the
@c NR subroutines, and then distribute an NR-less version, but in that case
@c you have to use the NR routines exactly as they are, which destroys the
@c advantage of having source code that you could modify.
@c 
@c The approach taken by Larry Wall, Donald Libes, John Ousterhout, and the
@c O'Reilly and Associates publishing company is to provide free software,
@c let the community debug, beta-test, and improve the code (often in
@c directions completely unanticipated by the original authors), and then
@c to write a book describing the freely-available software.  Oddly, the
@c authors of Numerical Recipes have taken precisely the opposite approach.
@c The book can be downloaded from the official Numerical Recipes web site,
@c but the software must be licensed.

@menu
* Goals::                       
@end menu

@node Goals
@subsection Goals

@c The short-term aim of GSL is to emulate, possibly even clone, Numerical
@c Recipes software and documentation.  The goal will be to provide a
@c somewhat coherent package of somewhat independent subroutines.  We
@c hereby promise not to use any actual NR code, but we paid for the book,
@c and we are not going to take it off of our shelves or pretend not to
@c read it.  We also plan to provide drop-in substitutes for NR
@c subroutines, usually as wrappers to our own preferred interfaces.

And we furthermore promise to try as hard as possible to document
the software: this will ideally involve discussion of why you might want
to use it, what precisely it does, how precisely to invoke it, 
how more-or-less it works, and where we learned about the algorithm,
and (unless we wrote it from scratch) where we got the code.
We do not plan to write this entire package from scratch, but to cannibalize
existing mathematical freeware, just as we expect our own software to
be cannibalized.

The long-term goal will be to provide a framework to which the real
numerical experts (or their graduate students) will contribute.  Such
contributors will have to contribute copylefted software and they cannot
mind that evil profit-making companies (such as those which sell
"environments") might use this software as part of their packages.



@node Design
@chapter Design

@menu
* Language for implementation::  
* Interface to other languages::  
* What routines are implemented::  
* Standards and conventions::   
* Namespace::                   
* Header files::                
* Target system::               
* Function Names::              
* Object-orientation::          
* Minimal structs::             
* Algorithm decomposition::     
* Memory allocation and ownership::  
* Memory layout::               
* Exceptions and Error handling::  
* Persistence::                 
* Datatype widths::             
* size_t::                      
* Constness::                   
* Pseudo-templates::            
* Test programs::               
* Compilation::                 
* Thread-safety::               
* Test suites::                 
* Legal issues::                
* Non-UNIX portability::        
* Compatibility with other libraries::  
* Parallelism::                 
@end menu

@node Language for implementation
@section Language for implementation

Issues:

@strong{One language only (C)}

Advantages: simpler, compiler available and quite universal.

Disadvantages: excludes large body of old fortran code.  (Is that really
a disadvantage?)

@strong{More than one language}

Must be parsed by gcc (C++, objective C, fortran 77).

Routines must be trivially callable by C, without having to write
wrappers.

@strong{If we do it in C}

How do we protect name space, and keep global vars from being annoying?
Make recommendations to implementors to help with these issues.


@node Interface to other languages
@section Interface to other languages

We should propose a format for writing wrappers for other languages.

Wrapper packages are supplied as "extra" packages; not as part of the
"core".

The wrapper packages can be organized either @emph{by language} or
@emph{by numerical subsystem}.

What languages should be supported?
@itemize @bullet
@item
C++ (pay much attention to the design)
@item
scheme/guile
@item
sather
@item
IDL
@item
whatever
@end itemize




@node What routines are implemented
@section What routines are implemented


For more guidance we might look at the Forth Scientific Library [see the
URL http://www.taygeta.com/fsl/sciforth.html].


@subsection Random number generators

Includes both random number generators and routines to give various
interesting distributions.

@subsection Statistics

@subsection Special Functions

What I (jt) envision for this section is a collection of routines for
reliable and accurate (but not necessarily fast or efficient) estimation
of values for special functions, explicitly using Taylor series, asymptotic 
expansions, continued fraction expansions, etc.  As well as these routines,
fast approximations will also be provided, primarily based on Chebyshev
polynomials and ratios of polynomials.  In this vision, the approximations
will be the "standard" routines for the users, and the exact (so-called)
routines will be used for verification of the approximations.  It may also
be useful to provide various identity-checking routines as part of the
verification suite.

Currently, the only available functions are: @code{gsl_sf_erf()} and 
@code{gsl_sf_erfc()}

@subsection Curve fitting

polynomial

special functions

spline

@subsection Ordinary differential equations

@subsection Partial differential equations

@subsection Fourier Analysis

@subsection Wavelets

@subsection Matrix operations: linear equations

@subsection Matrix operations: eigenvalues and spectral analysis

@subsection Matrix operations: any others?

@subsection Direct integration

@subsection Monte carlo methods

@subsection Simulated annealing

@subsection Genetic algorithms

We need to think about what kinds of algorithms are basic generally
useful numerical algorithms, and which ones are special purpose
research projects.  We should concentrate on supplying the former.

@subsection Cellular automata

@subsection Parallel libraries



@node Standards and conventions
@section Standards and conventions

The people who kick off this project should set the coding standards and
conventions.  Some standards that should be set are:

@itemize @bullet
@item
Targets for make.  We of course follow the GNU coding standards and use
automake, so all the standard GNU targets are present.  In @ref{Test
suites} we discuss the possibility of a @code{make check} target which
will run a verification suite for the given subsystem.
@item
Function arguments and abstraction levels.
@item
Sub-package function name prefixes
@item
Documentation: the project leaders should give examples of how things
are to be documented.  High quality documentation is absolutely
mandatory, so documentation should introduce the topic, and give careful
reference for the provided functions.

I (-jt) recommend using gsl_xxx_functionName() for functions that
we supply, where xxx is the 'category'.  Categories are 'ran' (random
number generators), 'sf' (special functions), 'stat' (statistics), etc.


@end itemize


@node Namespace
@section Namespace

Use @code{gsl_} as a prefix for all exported functions and variables.

Use @code{GSL_} as a prefix for all exported macros.

All exported header files should have a filename with the prefix @code{gsl_}.

All installed libraries should have a name like libgslhistogram.a

Any installed executables (utility programs etc) should have the prefix
@code{gsl-} (with a hyphen, not an underscore).

@node Header files
@section Header files

Installed header files should be idempotent, i.e. surround them by the
preprocessor conditionals like the following,

@example
#ifndef __GSL_HISTOGRAM_H__
#define __GSL_HISTOGRAM_H__
...
#endif /* __GSL_HISTOGRAM_H__ */
@end example

@node Target system
@section Target system

The target system is ANSI C, with a full Standard C Library, and IEEE
arithmetic.

@node Function Names
@section Function Names

Each module has a name, which prefixes any function names in that module,
e.g. the module gsl_fft has function names like gsl_fft_init

@node Object-orientation
@section Object-orientation

The algorithms should be object oriented, but only to the extent that is
easy in portable ANSI C.  The use of casting or other tricks to simulate
inheritance is not desirable, and the user should not have to be aware
of anything like that.  This means many types of patterns are ruled
out.  However, this is not considered a problem -- they are too
complicated for the library.  

Note: it is possible to define an abstract base class easily in C, using
function pointers.  See the rng directory for an example. 

@node Minimal structs
@section Minimal structs

We prefer to make structs which are minimal.  For example, if a certain
type of problem can be solved by several classes of algorithm (e.g. with
and without derivative information) it is better to make separate types
of struct to handle those cases.  i.e. run time type identification is
not desirable.

@node Algorithm decomposition
@section Algorithm decomposition

Iterative algorithms should be decomposed into an INITIALIZE, ITERATE,
TEST form, so that the user can control the progress of the iteration.

@node Memory allocation and ownership
@section Memory allocation and ownership

Functions which allocate memory on the heap should end in _alloc
(e.g. gsl_foo_alloc) and be deallocated by a corresponding _free function
(gsl_foo_free).

Be sure to free any memory allocated by your function if you have to
return an error in a partially initialized object.

@node Memory layout
@section Memory layout

We use flat blocks of memory to store matrices and vectors, not C-style
pointer-to-pointer arrays.  The matrices are stored in row-major order
-- i.e. the column index moves continuously through memory. 

@node Exceptions and Error handling
@section Exceptions and Error handling

The basic error handling procedure is the return code (see gsl_errno.h
for a list of allowed values).  Use the GSL_ERROR macro to mark an
error.  The current definition of this macro is not ideal but it can be
changed at compile time. 

Be sure to free any memory allocated by your function if you return an
error (in particular for errors in partially initialized objects).

@node Persistence
@section Persistence

If you make an object foo which uses blocks of memory (e.g. vector,
matrix, histogram) you can provide functions for reading and writing
those blocks,

@example
int gsl_foo_fread (FILE * stream, gsl_foo * v);
int gsl_foo_fwrite (FILE * stream, const gsl_foo * v);
int gsl_foo_fscanf (FILE * stream, gsl_foo * v);
int gsl_foo_fprintf (FILE * stream, const gsl_foo * v, const char *format);
@end example
@noindent
Only dump out the blocks of memory, not any associated parameters such
as lengths.  The idea is for the user to build higher level input/output
facilities using the functions the library provides.  Use the functions

@example
int gsl_block_fread (FILE * stream, gsl_block * b);
int gsl_block_fwrite (FILE * stream, const gsl_block * b);
int gsl_block_fscanf (FILE * stream, gsl_block * b);
int gsl_block_fprintf (FILE * stream, const gsl_block * b, const char *format);
@end example
@noindent
or

@example
int gsl_block_raw_fread (FILE * stream, double * b, size_t n, size_t stride);
int gsl_block_raw_fwrite (FILE * stream, const double * b, size_t n, size_t stri
de);
int gsl_block_raw_fscanf (FILE * stream, double * b, size_t n, size_t stride);
int gsl_block_raw_fprintf (FILE * stream, const double * b, size_t n, size_t str
ide, const char *format);
@end example
@noindent
to do the actual reading and writing.

@node Datatype widths
@section Datatype widths

Be aware that in ANSI C the type @code{int} is only guaranteed to
provide 16-bits (or more).  Therefore if you require 32 bits you must use
@code{long int}, which will have 32 bits (or more).  Of course, on many
platforms the type @code{int} does have 32 bits instead of 16 bits but
we have to code to the ANSI standard rather than a specific platform.

@node size_t
@section size_t

All objects (blocks of memory, etc) should be measured in terms of a
@code{size_t} type.  Therefore any iterations (e.g. @code{for(i=0; i<N;
i++)}) should also use an index of type @code{size_t}.  If you need to
write a descending loop you have to be careful because @code{size_t} is
unsigned, so instead of

@example
for (i = N - 1; i >= 0 ; i--) @{ ... @}
@end example
@noindent
use something like

@example
for (i = 0; i < N; i++) @{ j = N - i ; ... @}
@end example
@noindent
to avoid problems with wrap-around at @code{i=0}.

@node Constness
@section Constness

Use @code{const} in function prototypes wherever an object pointed to by
a pointer is constant (obviously).  For variables which are meaningfully
constant within a function/scope use @code{const} also.  This prevents
you from accidentally modifying a variable which should be constant
(e.g. length of an array, etc).  It can also help the compiler do
optimization.  These comments also apply to arguments passed by value
which should be made @code{const} when that is meaningful.

@node Pseudo-templates
@section Pseudo-templates

There are some pseudo-template macros available in @file{templates_on.h}
and @file{templates_off.h}.  See a directory link @file{block} for
details on how to use them.  Use sparingly, they are a bit of a
nightmare, but unavoidable in places.

In particular, the convention is: templates are used for operations on
"data" only (vectors, matrices, statistics, sorting).  This is intended
to cover the case where the program must interface with an external
datasource which produces a fixed type. e.g. a big array of char's
produced by an 8-bit counter.

All other functions can use double, for floating point, or the
appropriate integer type for integers (e.g. unsigned long int for random
numbers).  It is not the intention to provide a fully templated version
of the library. 

That would be "putting a quart into a pint pot". To summarise, almost
everything should be in a "natural type" which is appropriate for
typical usage, and templates are there to handle a few cases where it is
unavoidable that other datatypes will be encountered.

For floating point work "double" is considered a "natural type".  This
sort of idea is a part of the C language.

@node Test programs
@section Test programs

Provide one test program per directory which aims for 100% path coverage
of the code.  Obviously it would be a lot of work to really achieve this,
so prioritise testing on the critical parts and use inspection for the
rest.  Test all the error conditions by explicitly provoking them,
because we consider it a serious defect if the function does not return
an error for an invalid parameter. N.B. Don't bother to test for null
pointers -- it's sufficient for the library to segfault if the user
provides an invalid pointer.

The tests should be deterministic.  Use the @code{gsl_test} functions
provided to perform separate tests for each feature with a separate
output PASS/FAIL line, so that any failure can be uniquely identified.

@node Compilation
@section Compilation

Make sure everything compiles cleanly.  Use the strict compilation
options for extra checking.

@example
make CFLAGS="-ansi -pedantic -Werror -W -Wall -Wtraditional -Wconversion 
  -Wshadow -Wpointer-arith -Wcast-qual -Wcast-align -Wwrite-strings 
  -Wstrict-prototypes -fshort-enums -fno-common -Wmissing-prototypes 
  -Wnested-externs -Dinline= -g -O4"
@end example
@noindent
Also use checkergcc to check for memory problems on the stack and the
heap.  It's the best memory checking tool.  If checkergcc isn't available
then Electric Fence will check the heap, which is better than nothing.

Make sure that the library will also compile with C++ compilers
(g++).  This should not be too much of a problem if you have been writing
in ANSI C.

@node Thread-safety
@section Thread-safety

The library should be useable in thread-safe programs.  All the
functions should be thread-safe.

We don't require everything to be completely thread safe, but any thing
that isn't should be obvious, and not a function.  For example, some
global variables are used to control the overall behavior of the library
(range-checking on/off, function to call on fatal error, etc).  Since
these are accessed directly by the user they obviously aren't thread
specific.

@node Test suites
@section Test suites

The implementor of each library should provide a reasonable test suite
for that library.

The test suite should be a program that uses the library and checks the
result against known results, or invokes the library several times and
does a statistical analysis on the results (for example in the case of
random number generators).

We should add the target @code{make check} to the Makefile.am files,
and that should automatically execute the verification suite for the
given library.

@node Legal issues
@section Legal issues

@itemize @bullet
@item
Each contributor must make sure her code is under the GNU General Public
License (GPL).
@item
We must understand ownership of existing code and algorithms.
@itemize @minus
@item
Obviously: don't reference non-free code (such as numerical recipes).
@item
I @strong{think} one can reference algorithms from classic books on
numerical analysis.
@end itemize

@end itemize

@node Non-UNIX portability
@section Non-UNIX portability

There is good reason to make this library work on non-UNIX systems.  It
is probably safe to ignore DOS and only worry about windows95/windowsNT
portability (so filenames can be long, I think).

On the other hand, nobody should be forced to use non-UNIX systems for
development.

The best solution is probably to issue guidelines for portability, like
saying "don't use XYZ unless you absolutely have to".  Then the Windows
people will be able to do their porting.

We should also read up on what Cygnus is doing for their win32
portability.



@node Compatibility with other libraries
@section Compatibility with other libraries


Other libraries, such as Netlib and Numerical Recipes, are widely used.
It would be good to allow drop-in replacement of these libraries, as
long as that does not compromise the quality of our routines.

Compatibility should be provided by a set of wrappers, shipped as an
auxiliary package.

There are probably no legal issues on this front.





@node Parallelism
@section Parallelism

An extra sub-package with parallel libraries would be nice.  These
should use standard libraries such as PVM or MPI.  (It appears that PVM
ships with MPI, and vice-versa; we should figure out which is the
recommended platform.)


@node Copying
@unnumbered Copying

   The subroutines and source code in the @value{GSL} package are "free";
this means that everyone is free to use them and free to redistribute
them on a free basis.  The @value{GSL}-related programs are not in the
public domain; they are copyrighted and there are restrictions on their
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of these
programs that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the programs that relate to @value{GSL}, that you receive
source code or else can get it if you want it, that you can change these
programs or use pieces of them in new free programs, and that you know
you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the @value{GSL}-related code, you must give the recipients all
the rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for the programs that relate to
@value{GSL}.  If these programs are modified by someone else and passed
on, we want their recipients to know that what they have is not what we
distributed, so that any problems introduced by others will not reflect
on our reputation.

   The precise conditions of the licenses for the programs currently
being distributed that relate to @value{GSL} are found in the General
Public Licenses that accompany them.

@printindex cp

@node Function Index
@unnumbered Function Index

@printindex fn

@node Variable Index
@unnumbered Variable Index

@printindex vr

@node Type Index
@unnumbered Type Index

@printindex tp

@c -@shortcontents
@contents
@bye
