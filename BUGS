This file is the GSL bug tracking system.  The CVS version of this
file should be kept up-to-date.

----------------------------------------------------------------------
BUG#1 -- gsl_sf_hyperg_2F1_e fails for some arguments 

From: keith.briggs@bt.com
Subject: gsl_sf_hyperg_2F1 bug report
Date: Thu, 31 Jan 2002 12:30:04 -0000

gsl_sf_hyperg_2F1_e fails with arguments (1,13,14,0.999227196008978,&r).
It should return 53.4645... .

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (1,13,14,0.999227196008978,&r);
  printf("r = %g %g\n", r.val, r.err);
}

NOTES: The program overflows the maximum number of iterations in
gsl_sf_hyperg_2F1, due to the presence of a nearby singularity at
(c=a+b,x=1) so the sum is slowly convergent.

The exact result is 53.46451441879150950530608621 as calculated by
gp-pari using sumpos(k=0,gamma(a+k)*gamma(b+k)*gamma(c)*gamma(1)/
(gamma(c+k)*gamma(1+k)*gamma(a)*gamma(b))*x^k)

The code needs to be extended to handle the case c=a+b. This is the
main problem. The case c=a+b is special and needs to be computed
differently.  There is a special formula given for it in Abramowitz &
Stegun 15.3.10

As reported by Lee Warren <warren@atom.chem.utk.edu> another set of
arguments which fail are:

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (-1, -1, -0.5, 1.5, &r);
  printf("r = %g %g\n", r.val, r.err);
}

The correct value is -2.
----------------------------------------------------------------------
BUG#20 -- underflow in gsl_sf_legendre_sphPlm functions

The functions gsl_sf_legendre_sphPlm and gsl_sf_legendre_sphPlm_array
have underflows for large l,m.  Also the error can be significant in
these cases (even though the computed value is reasonable).

  gsl_sf_legendre_sphPlm_e(200, 1, -0.5,&y) -- large error
  gsl_sf_legendre_sphPlm_e(140,135,1,&y); -- underflow
  gsl_sf_legendre_sphPlm_e(140,135,0.99998689456491752,&y);

----------------------------------------------------------------------
BUG#41 -- improve constness in multifit

Not really a bug but worth fixing.  There are a few others like this
lurking out there.

From: Jari Häkkinen <jari@chiralcomp.com>
To: bug-gsl@gnu.org
Subject: [Bug-gsl] 'const'ness of function arguments
Date: Tue, 16 Aug 2005 20:37:13 +0200
Precedence: list
Envelope-to: bjg@network-theory.co.uk

Hi all,
I've noticed two fitting functions that probably should have a 'const' 
qualifier on the third argument. The 'x' parameter in fdfsolver.c:

int
gsl_multifit_fdfsolver_set (gsl_multifit_fdfsolver * s,
                              gsl_multifit_function_fdf * f,
                              gsl_vector * x)

and in fsolver.c:

int
gsl_multifit_fsolver_set (gsl_multifit_fsolver * s,
                           gsl_multifit_function * f,
                           gsl_vector * x)

can safely be set to 'const' since these are only used for 
initialization of another gsl_vector.

----------------------------------------------------------------------
BUG#42 -- gsl_sf_expint_E2 fails for x=0

The implementation for gsl_sf_expint_E2 uses a term "x*E1(x)" but
E1(x) is infinite at x=0, so there is an error.  E2 needs a 
separate implementation to handle this.  Also the error term

  else if(x < 100.0) {
    const double ex = ( scale ? 1.0 : exp(-x) );
    gsl_sf_result result_E1;
    int stat_E1 = expint_E1_impl(x, &result_E1, scale);
    result->val  = ex - x*result_E1.val;
    result->err  = fabs(x) * (GSL_DBL_EPSILON*ex + result_E1.err);
    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);
    return stat_E1;
  }

should probably be 

    result->err  = GSL_DBL_EPSILON*ex + fabs(x) * result_E1.err;

----------------------------------------------------------------------
Last assigned bug number = 42
