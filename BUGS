This file is the GSL bug tracking system.  The CVS version of this
file should be kept up-to-date.

----------------------------------------------------------------------
BUG#1 -- gsl_sf_hyperg_2F1_e fails for some arguments 

From: keith.briggs@bt.com
Subject: gsl_sf_hyperg_2F1 bug report
Date: Thu, 31 Jan 2002 12:30:04 -0000

gsl_sf_hyperg_2F1_e fails with arguments (1,13,14,0.999227196008978,&r).
It should return 53.4645... .

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (1,13,14,0.999227196008978,&r);
  printf("r = %g %g\n", r.val, r.err);
}

NOTES: The program overflows the maximum number of iterations in
gsl_sf_hyperg_2F1, due to the presence of a nearby singularity at
(c=a+b,x=1) so the sum is slowly convergent.

The exact result is 53.46451441879150950530608621 as calculated by
gp-pari using sumpos(k=0,gamma(a+k)*gamma(b+k)*gamma(c)*gamma(1)/
(gamma(c+k)*gamma(1+k)*gamma(a)*gamma(b))*x^k)

The code needs to be extended to handle the case c=a+b. This is the
main problem. The case c=a+b is special and needs to be computed
differently.  There is a special formula given for it in Abramowitz &
Stegun 15.3.10

As reported by Lee Warren <warren@atom.chem.utk.edu> another set of
arguments which fail are:

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (-1, -1, -0.5, 1.5, &r);
  printf("r = %g %g\n", r.val, r.err);
}

The correct value is -2.

----------------------------------------------------------------------
BUG#10 -- gsl_sf_fermi_dirac_int error estimates 

Some of the error estimates on gsl_sf_fermi_dirac_int are much too
large.  The value itself is pretty accurate.

In the test_sf_result you need to work in something like

  if(r.err > 1.0e5 * (fabs(r.val - val) + GSL_DBL_EPSILON * fabs(val)))
        s |= TEST_SF_INCONS;   /* error estimate too large */

in addition to the existing

   if(fabs(val - r.val) > 2.0*r.err) s |= TEST_SF_INCONS;

to catch those.  

#include<stdio.h>
#include<gsl/gsl_errno.h>
#include<gsl/gsl_sf.h>

int main() {
  gsl_sf_result r;
  int status;

  status = gsl_sf_fermi_dirac_int_e (9, 500.0, &r);
  printf("FD_9(500) = %.18e +- %.18e\n", r.val, r.err);
}

result,

FD_9(500) = 2.692738498426942915e+20 +- 2.629627439870118259e+47

Exact     = 2.692738498...e+20
----------------------------------------------------------------------
BUG#20 -- underflow in gsl_sf_legendre_sphPlm functions

The functions gsl_sf_legendre_sphPlm and gsl_sf_legendre_sphPlm_array
have underflows for large l,m.  Also the error can be significant in
these cases (even though the computed value is reasonable).

  gsl_sf_legendre_sphPlm_e(200, 1, -0.5,&y) -- large error
  gsl_sf_legendre_sphPlm_e(140,135,1,&y); -- underflow
  gsl_sf_legendre_sphPlm_e(140,135,0.99998689456491752,&y);

----------------------------------------------------------------------
BUG#30 - incorrect result from gsl_sf_elljac_e

The function gsl_sf_elljac_e returns an incorrect result in the first
case below, due propagated inaccuracies from cancellation error.  The
correct result should be dn(3K)=sqrt(2) but the returned result is
1.0.

#include <stdio.h>
#include <math.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_sf_ellint.h>
     
int main (void)
{
  double m = 0.5;
  double phi = M_PI_2;
  double sn;
  double cn;
  double dn1,dn2;
  double K;
  int ignore;
  
  K = gsl_sf_ellint_F(M_PI_2,sqrt(m), GSL_PREC_DOUBLE);
  ignore = gsl_sf_elljac_e(3*K, m, &sn, &cn, &dn1);
  ignore = gsl_sf_elljac_e(3*K+0.00000001, m, &sn, &cn, &dn2);
  
  printf("%.18e\n", dn1);
  printf("%.18e\n", dn2);
  return 0;
}
----------------------------------------------------------------------
Last assigned bug number = 39
