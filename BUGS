This file is the GSL bug tracking system.  The CVS version of this
file should be kept up-to-date.

----------------------------------------------------------------------
BUG#1 -- gsl_sf_hyperg_2F1_e fails for some arguments 

From: keith.briggs@bt.com
Subject: gsl_sf_hyperg_2F1 bug report
Date: Thu, 31 Jan 2002 12:30:04 -0000

gsl_sf_hyperg_2F1_e fails with arguments (1,13,14,0.999227196008978,&r).
It should return 53.4645... .

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (1,13,14,0.999227196008978,&r);
  printf("r = %g %g\n", r.val, r.err);
}

NOTES: The program overflows the maximum number of iterations in
gsl_sf_hyperg_2F1, due to the presence of a nearby singularity at
(c=a+b,x=1) so the sum is slowly convergent.

The exact result is 53.46451441879150950530608621 as calculated by
gp-pari using sumpos(k=0,gamma(a+k)*gamma(b+k)*gamma(c)*gamma(1)/
(gamma(c+k)*gamma(1+k)*gamma(a)*gamma(b))*x^k)

The code needs to be extended to handle the case c=a+b. This is the
main problem. The case c=a+b is special and needs to be computed
differently.  There is a special formula given for it in Abramowitz &
Stegun 15.3.10

As reported by Lee Warren <warren@atom.chem.utk.edu> another set of
arguments which fail are:

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (-1, -1, -0.5, 1.5, &r);
  printf("r = %g %g\n", r.val, r.err);
}

The correct value is -2.
----------------------------------------------------------------------
BUG#20 -- underflow in gsl_sf_legendre_sphPlm functions

The functions gsl_sf_legendre_sphPlm and gsl_sf_legendre_sphPlm_array
have underflows for large l,m.  Also the error can be significant in
these cases (even though the computed value is reasonable).

  gsl_sf_legendre_sphPlm_e(200, 1, -0.5,&y) -- large error
  gsl_sf_legendre_sphPlm_e(140,135,1,&y); -- underflow
  gsl_sf_legendre_sphPlm_e(140,135,0.99998689456491752,&y);

----------------------------------------------------------------------
BUG#41 -- improve constness in multifit

Not really a bug but worth fixing.  There are a few others like this
lurking out there.

From: Jari Häkkinen <jari@chiralcomp.com>
To: bug-gsl@gnu.org
Subject: [Bug-gsl] 'const'ness of function arguments
Date: Tue, 16 Aug 2005 20:37:13 +0200
Precedence: list
Envelope-to: bjg@network-theory.co.uk

Hi all,
I've noticed two fitting functions that probably should have a 'const' 
qualifier on the third argument. The 'x' parameter in fdfsolver.c:

int
gsl_multifit_fdfsolver_set (gsl_multifit_fdfsolver * s,
                              gsl_multifit_function_fdf * f,
                              gsl_vector * x)

and in fsolver.c:

int
gsl_multifit_fsolver_set (gsl_multifit_fsolver * s,
                           gsl_multifit_function * f,
                           gsl_vector * x)

can safely be set to 'const' since these are only used for 
initialization of another gsl_vector.

----------------------------------------------------------------------
BUG#42 -- gsl_sf_expint_E2 fails for x=0

The implementation for gsl_sf_expint_E2 uses a term "x*E1(x)" but
E1(x) is infinite at x=0, so there is an error.  E2 needs a 
separate implementation to handle this.  Also the error term

  else if(x < 100.0) {
    const double ex = ( scale ? 1.0 : exp(-x) );
    gsl_sf_result result_E1;
    int stat_E1 = expint_E1_impl(x, &result_E1, scale);
    result->val  = ex - x*result_E1.val;
    result->err  = fabs(x) * (GSL_DBL_EPSILON*ex + result_E1.err);
    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);
    return stat_E1;
  }

should probably be 

    result->err  = GSL_DBL_EPSILON*ex + fabs(x) * result_E1.err;

----------------------------------------------------------------------
BUG#43 -- knuthran is out of date

From: "Charles Karney" <ckarney@sarnoff.com>
To: James Theiler <jt@lanl.gov>
Cc: Charles Karney <ckarney@sarnoff.com>,
	gsl-discuss <gsl-discuss@sources.redhat.com>
Subject: Re: GSL 1.6 random numbers (gauss.c and rng.c)

One final remark.  knuthran.c is out of date!  See

    http://www-cs-faculty.stanford.edu/~knuth/news02.html#rng
    http://www-cs-faculty.stanford.edu/~knuth/programs/rng.c

There are two significant changes:

(1) The generator is "warmed up" more thoroughly.  (This avoids problems
    with correlations between random streams with adjacent seeds.)

(2) Only 100 out of every 1009 random numbers are used.  (This is needed
    so that the "birthday test" is satisfied.)

-- 
Charles Karney <ckarney@sarnoff.com>
Sarnoff Corporation, Princeton, NJ 08543-5300

URL: http://charles.karney.info
Tel: +1 609 734 2312
Fax: +1 609 734 2323

----------------------------------------------------------------------
BUG#44 -- gamma_inc_P and gamma_inc_Q only satisfy P+Q=1 within errors

The sum of gamma_inc_P and gamma_inc_Q doesn't always satisfy the
identity P+Q=1 exactly (although it is correct within errors), due the
slightly different branch conditions for the series and continued
fraction expansions.  These could be made identical so that P+Q=1 exactly.

#include <stdio.h>
#include <gsl/gsl_sf_gamma.h>

int
main (void)
{
  gsl_sf_result r1, r2;
  double a = 0.3, x = 1.0;
  gsl_sf_gamma_inc_P_e (a, x, &r1);
  gsl_sf_gamma_inc_Q_e (a, x, &r2);
  printf("%.18e\n", r1.val);
  printf("%.18e\n", r2.val);
  printf("%.18e\n", r1.val + r2.val);
}

$ ./a.out
9.156741562411074842e-01
8.432584375889111417e-02
9.999999999999985567e-01

======================================================================
Last assigned bug number = 43
