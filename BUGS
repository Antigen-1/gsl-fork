This file is the GSL bug tracking system.  The CVS version of this
file should be kept up-to-date.

----------------------------------------------------------------------
BUG#1 -- gsl_sf_hyperg_2F1_e fails for some arguments 

From: keith.briggs@bt.com
Subject: gsl_sf_hyperg_2F1 bug report
Date: Thu, 31 Jan 2002 12:30:04 -0000

gsl_sf_hyperg_2F1_e fails with arguments (1,13,14,0.999227196008978,&r).
It should return 53.4645... .

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (1,13,14,0.999227196008978,&r);
  printf("r = %g %g\n", r.val, r.err);
}

NOTES: The program overflows the maximum number of iterations in
gsl_sf_hyperg_2F1, due to the presence of a nearby singularity at
(c=a+b,x=1) so the sum is slowly convergent.

The exact result is 53.46451441879150950530608621 as calculated by
gp-pari using sumpos(k=0,gamma(a+k)*gamma(b+k)*gamma(c)*gamma(1)/
(gamma(c+k)*gamma(1+k)*gamma(a)*gamma(b))*x^k)

The code needs to be extended to handle the case c=a+b. This is the
main problem. The case c=a+b is special and needs to be computed
differently.  There is a special formula given for it in Abramowitz &
Stegun 15.3.10

As reported by Lee Warren <warren@atom.chem.utk.edu> another set of
arguments which fail are:

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (-1, -1, -0.5, 1.5, &r);
  printf("r = %g %g\n", r.val, r.err);
}

The correct value is -2.

----------------------------------------------------------------------
BUG#10 -- gsl_sf_fermi_dirac_int error estimates 

Some of the error estimates on gsl_sf_fermi_dirac_int are much too
large.  The value itself is pretty accurate.

In the test_sf_result you need to work in something like

  if(r.err > 1.0e5 * (fabs(r.val - val) + GSL_DBL_EPSILON * fabs(val)))
        s |= TEST_SF_INCONS;   /* error estimate too large */

in addition to the existing

   if(fabs(val - r.val) > 2.0*r.err) s |= TEST_SF_INCONS;

to catch those.  

#include<stdio.h>
#include<gsl/gsl_errno.h>
#include<gsl/gsl_sf.h>

int main() {
  gsl_sf_result r;
  int status;

  status = gsl_sf_fermi_dirac_int_e (9, 500.0, &r);
  printf("FD_9(500) = %.18e +- %.18e\n", r.val, r.err);
}

result,

FD_9(500) = 2.692738498426942915e+20 +- 2.629627439870118259e+47

Exact     = 2.692738498...e+20
----------------------------------------------------------------------
BUG#20 -- underflow in gsl_sf_legendre_sphPlm functions

The functions gsl_sf_legendre_sphPlm and gsl_sf_legendre_sphPlm_array
have underflows for large l,m.  Also the error can be significant in
these cases (even though the computed value is reasonable).

  gsl_sf_legendre_sphPlm_e(200, 1, -0.5,&y) -- large error
  gsl_sf_legendre_sphPlm_e(140,135,1,&y); -- underflow
  gsl_sf_legendre_sphPlm_e(140,135,0.99998689456491752,&y);

----------------------------------------------------------------------
BUG#27 - handling of zero leading coefficients in poly/*solve routines

The poly/solve_ and poly/zsolve_ routines should handle the case of
leading coefficients being zero more gracefully.  Currently the
leading coefficient is assumed to be non-zero.

----------------------------------------------------------------------
BUG#30 - incorrect result from gsl_sf_elljac_e

The function gsl_sf_elljac_e returns an incorrect result in the first
case below, due propagated inaccuracies from cancellation error.  The
correct result should be dn(3K)=sqrt(2) but the returned result is
1.0.

#include <stdio.h>
#include <math.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_sf_ellint.h>
     
int main (void)
{
  double m = 0.5;
  double phi = M_PI_2;
  double sn;
  double cn;
  double dn1,dn2;
  double K;
  int ignore;
  
  K = gsl_sf_ellint_F(M_PI_2,sqrt(m), GSL_PREC_DOUBLE);
  ignore = gsl_sf_elljac_e(3*K, m, &sn, &cn, &dn1);
  ignore = gsl_sf_elljac_e(3*K+0.00000001, m, &sn, &cn, &dn2);
  
  printf("%.18e\n", dn1);
  printf("%.18e\n", dn2);
  return 0;
}
----------------------------------------------------------------------
BUG#37 -- improve handling of zero singular values in multifit linear

[The handling of zero singular values could be improved by taking a
user-specified tolerance or splitting this function in two to expose
the intermediate results - BJG].

From: Richard Mott <rmott@well.ox.ac.uk>
To: bug-gsl@gnu.org,  rmott@well.ox.ac.uk
Subject: [Bug-gsl] bug in gsl_multifit_wlinear
Date: Fri, 20 May 2005 14:19:27 +0100

There is a bug in gsl_multifit_wlinear (and presumably in 
gsl_multifit_linear too). The problem manifests itself when the design 
matrix X is not of full rank. The documentation says that this case is 
handled correctly in the singular value decompostion by setting the tiny 
SVD components to 0. In fact his doesn't happen. Instead the function 
returns a huge and non-sensical chisq value. The block of code in 
question is

for (j = 0; j < p; j++)
        {
          gsl_vector_view column = gsl_matrix_column (QSI, j);
          double alpha = gsl_vector_get (S, j);
          if (alpha != 0)
            alpha = 1.0 / alpha;
          gsl_vector_scale (&column.vector, alpha);
        }

and needs to be changed to something like

int rank = 0;
for (j = 0; j < p; j++)
        {
          gsl_vector_view column = gsl_matrix_column (QSI, j);
          double alpha = gsl_vector_get (S, j);
          if (alpha >1.0e-7) {
                rank ++;
                alpha = 1.0 / alpha;
        else {
          alpha = 0.0;
          gsl_vector_set(S,j,0.0);
        }
          gsl_vector_scale (&column.vector, alpha);
        }

Finally, in the case of when the rank of the design matric is not full, 
it is useful to return the true rank (given by the number of SVD 
components that exceed the test >1.0e-7)

My choice of a cutoff of 1.0e-7 is farily arbitrary, but seems to work
----------------------------------------------------------------------
Last assigned bug number = 39
