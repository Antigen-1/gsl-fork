This file is the GSL bug tracking system.  The CVS version of this
file should be kept up-to-date.

----------------------------------------------------------------------
BUG#1 -- gsl_sf_hyperg_2F1_e fails for some arguments 

From: keith.briggs@bt.com
Subject: gsl_sf_hyperg_2F1 bug report
Date: Thu, 31 Jan 2002 12:30:04 -0000

gsl_sf_hyperg_2F1_e fails with arguments (1,13,14,0.999227196008978,&r).
It should return 53.4645... .

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (1,13,14,0.999227196008978,&r);
  printf("r = %g %g\n", r.val, r.err);
}

NOTES: The program overflows the maximum number of iterations in
gsl_sf_hyperg_2F1, due to the presence of a nearby singularity at
(c=a+b,x=1) so the sum is slowly convergent.

The exact result is 53.46451441879150950530608621 as calculated by
gp-pari using sumpos(k=0,gamma(a+k)*gamma(b+k)*gamma(c)*gamma(1)/
(gamma(c+k)*gamma(1+k)*gamma(a)*gamma(b))*x^k)

The code needs to be extended to handle the case c=a+b. This is the
main problem. The case c=a+b is special and needs to be computed
differently.  There is a special formula given for it in Abramowitz &
Stegun 15.3.10

As reported by Lee Warren <warren@atom.chem.utk.edu> another set of
arguments which fail are:

#include <gsl/gsl_sf.h>
#include <stdio.h>

int main (void)
{
  gsl_sf_result r;
  gsl_sf_hyperg_2F1_e (-1, -1, -0.5, 1.5, &r);
  printf("r = %g %g\n", r.val, r.err);
}

The correct value is -2.
----------------------------------------------------------------------
BUG#20 -- underflow in gsl_sf_legendre_sphPlm functions

The functions gsl_sf_legendre_sphPlm and gsl_sf_legendre_sphPlm_array
have underflows for large l,m.  Also the error can be significant in
these cases (even though the computed value is reasonable).

  gsl_sf_legendre_sphPlm_e(200, 1, -0.5,&y) -- large error
  gsl_sf_legendre_sphPlm_e(140,135,1,&y); -- underflow
  gsl_sf_legendre_sphPlm_e(140,135,0.99998689456491752,&y);

----------------------------------------------------------------------
BUG#30 - incorrect result from gsl_sf_elljac_e

The function gsl_sf_elljac_e returns an incorrect result in the first
case below, due propagated inaccuracies from cancellation error.  The
correct result should be dn(3K)=sqrt(2) but the returned result is
1.0.

#include <stdio.h>
#include <math.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_sf_ellint.h>
     
int main (void)
{
  double m = 0.5;
  double phi = M_PI_2;
  double sn;
  double cn;
  double dn1,dn2;
  double K;
  int ignore;
  
  K = gsl_sf_ellint_F(M_PI_2,sqrt(m), GSL_PREC_DOUBLE);
  ignore = gsl_sf_elljac_e(3*K, m, &sn, &cn, &dn1);
  ignore = gsl_sf_elljac_e(3*K+0.00000001, m, &sn, &cn, &dn2);
  
  printf("%.18e\n", dn1);
  printf("%.18e\n", dn2);
  return 0;
}
----------------------------------------------------------------------
BUG#39 - problem with gsl_sf_gamma_inc_Q

there is a problem with gsl_sf_gamma_inc_Q returning negative values
for large a,x, appears to be floating-point issue since it works on non-x86.

#include <gsl/gsl_randist.h>
#include <gsl/gsl_cdf.h>
#include <stdio.h>

int
main(int argc, char * argv[])
{
    double a, b, x, r, p, q;
    a=5670; b=0.00240449;
    x=11;
    printf("a=%g,b=%g\n", a, b);
    p = gsl_cdf_gamma_P(x, a, b);
    q = gsl_cdf_gamma_Q(x, a, b);
    printf("%lg: P = %lg, Q = %lg\n", x, p, q);
}

hp$ ./a.out 
a=5670,b=0.00240449
11: P = 3.69123e-55, Q = -3.69123e-55

----------------------------------------------------------------------
Last assigned bug number = 40
