#!perl -w
# -*- Mode: perl; indent-tabs-mode: nil -*-
#
# os2makefiles.pl: Creates config.mk, rules.mk and a set of Makefile.os2's for building GSL.
#                  Must be run from the toplevel objdir, which must be a subdir of the toplevel srcdir.
#
# (c) Henry Sobotka <sobotka@axess.com>, 2001
# include GNU GPL
#
use strict;

##################################################################################
# Variable hash for config.mk
#
my %config = (COMMENTS  => ['User configuration', 'ID', 'File extensions', 'Tools',
                            'Compilation/linkage flags', 'Files', 'String gymnastics for rules',
                            'Miscellaneous'],
              OPTFLAGS  => '-O6 -funroll-loops -mpentiumpro',
              EXEEXT    => '.exe',
              OBJEXT    => ['obj', 'o'],
              LIBEXT    => ['.lib', '.a'],
              IMPLIB    => 'emximp',
              AR        => ['emxomfar -p64 r', 'ar rs'],
              FILTER    => 'emxexp -o',
              CFLAGS    => '-mieee-fp -Zmtd',
              OMFFLAG   => ['-Zomf', ''],
              DBGCFLAGS => '-g -Wall',
              OPTCFLAGS => '$(OPTFLAGS) -s',
              INCLUDES  => '-I. -I$(srcdir) -I../gsl -I$(top_builddir)',
              DEFS      => '-DHAVE_CONFIG_H -D__ST_MT_ERRNO__',
              LDFLAGS   => '-Zcrtdll -Zmap',
              DLLFLAGS  => '-Zdll $(LDFLAGS)',
              EXEFLAGS  => '$(LDFLAGS) -Zlinker /PM:VIO -Zlinker /ST:0x100000',
              OPTEXE    => '-s -Zlinker /E:2 -Zlinker /A:4',
              OSOURCES  => '$(filter-out %.h,$(SOURCES))',
              OBJECTS   => '$(OSOURCES:%.c=$(CDIR)_%.o)',
              TARGETS   => '$(noinst_LTLIBRARIES) $(lib_LTLIBRARIES)',
              BINPROGS	=> '$(addsuffix $(EXEEXT),$(bin_PROGRAMS))',
              TSOURCES  => '$(addprefix $(srcdir)/,$(filter-out %.h,$(test_SOURCES)))',
              TOBJECTS  => '$(subst $(srcdir)/,,$(TSOURCES:.c=.o))',
              TESTPROGS => '$(addsuffix $(EXEEXT),$(check_PROGRAMS))',
              OBJLIBS   => '$(addprefix ../,$(libgsl_la_DEPENDENCIES))',
              GSLLIBS  => '-L../build -lgsl $(LIBCBLAS)');

###################################################################################
# rules.mk
#
my $GSLRULES=<<END;
# Don't loop past errors
FAIL_ON_ERR := set -e;

ifdef SUBDIRS
DO_SUBDIRS = \\
    \@\$(FAIL_ON_ERR) \\
    for d in \$(SUBDIRS); do \\
        \$(MAKE) -C \$\$d \$\@; \\
    done
endif

# XXXX Only runs "test.exe" tests
RUN_TESTS = \\
    for d in \$(SUBDIRS); do \\
        \$\$d/test; \\
    done

all: \$(TARGETS)
	\$(DO_SUBDIRS)

.SUFFIXES:
.SUFFIXES: .c .o .obj .s

\$(CDIR)_%.o: %.c
	\$(COMPILE) -o \$\@ -c \$<

ifdef MULTITEST
%.o: %.c
	\$(COMPILE) -o \$\@ -c \$<

test\$(EXEEXT): \$(TOBJECTS)
	\$(LINK) \$(DEFS) \$(INCLUDES) -o \$\@ \$(TOBJECTS) \$(GSLLIBS) \$(EXEFLAGS)
else
%\$(EXEEXT): %.c
	\$(LINK) \$(DEFS) \$(INCLUDES) -o \$\@ \$< \$(GSLLIBS) \$(EXEFLAGS)
endif

\$(TARGETS): \$(OBJECTS)
	\$(AR) \$\@ \$(OBJECTS)

# XXX NEED RULES FOR bin_PROGRAMS in histogram and randist
tests:  \$(TARGETS) \$(TESTPROGS)
	\$(DO_SUBDIRS)

check:
	\$(RUN_TESTS)

install:
	\@echo XXXXX FIX ME!!! XXXXX

clean:
	-rm \$(TRASH)
	+\$(DO_SUBDIRS)

showvals:
	\@echo sources = \$(OSOURCES)
	\@echo headers = \$(HEADERS)
	\@echo objects = \$(OBJECTS)
	\@echo targets = \$(TARGETS)
	\@echo tests   = \$(TESTPROGS)
	\@echo testsrc = \$(TSOURCES)
	\@echo compile = \$(COMPILE)
	\@echo link    = \$(LINK)
	+\$(DO_SUBDIRS)
END
;

###################################################################################
# Special rule for cblas test
#
my $CBLASRULE=<<END;
# To prevent "virtual memory exhausted" compilation failure
\$(NO_UNROLL_TESTS): %.o: %.c
	\$(filter-out -funroll-loops,\$(COMPILE)) -o \$@ -c \$<
END
;

###################################################################################
# General header
#
my $HEADER=<<END;
# OS/2 EMX makefile for GSL VERSION generated by $0
END
;

###################################################################################
# Subroutines:
#
#   load_file                 Reads file into array
#   write_rules               Writes rules.mk
#   roll_if                   Writes conditional blocks
#   read_cond_hash            Strings out a hashed conditional branch
#   write_config              Writes config.mk
#   hash_makefile             Reads original top-level Makefile into %config hash
#   write_makefile            Writes makefiles
#   write_build_makefile      Writes build/Makefile.
#   write_dllblock            Writes DLL-creation rules
#   make_makefiles            Main sequence

# Filereading utility
#
sub load_file {
    my $file = shift;
    my @lines = ();
    open MKF, "<$file" or die "Can't open $file: $!\n";

    while (defined (my $line = <MKF>)) {

        # Roll up lines with continuation backslashes
        while ($line =~ /\\$/) {
            $line .= <MKF>;
        }
        push @lines, $line;
    }
    close MKF;
    return \@lines;
}

# Write rules.mk
#
sub write_rules {
    my $rules = "rules.mk";

    print "Writing $rules\n";

    open RULES, ">$rules" or die "Can't open $rules: $!\n";
    print RULES $HEADER;
    foreach my $line (@{$config{'LICENSE'}}) { print RULES "$line\n"; }
    print RULES "\n\n";
    print RULES $GSLRULES;
    close RULES;
}

# Create simple conditional block
#
sub roll_if {
    my ($cond, $def, $varh) = @_;
    $cond .= " ".$def."\n";
    $cond .= read_cond_hash($varh, 0);
    $cond .= "else\n";
    $cond .= read_cond_hash($varh, 1);
    $cond .= "endif\n\n";
    return $cond;
}

sub read_cond_hash {
    my ($varh, $block) = @_;
    my %varh = %$varh;
    my $cstr = '';

    foreach my $k (keys %varh) {
        my $tabs = length $k > 7 ? "\t" : "\t\t";
        my $op = $k eq "CFLAGS" ? '+=' : '=';
        my $val = $varh{$k}[$block];
        $cstr .= $k.$tabs.$op." $val\n" unless $val eq '';
    }
    return $cstr;
}

# Write a pretty config.mk
#
sub write_config {

    my $conf = "config.mk";
    my @done = ();
    print "Creating $conf\n";
    open CONFIG, ">$conf" or die "Can't open $conf: $!\n";

    print CONFIG "$HEADER\n";
    foreach my $line (@{$config{'LICENSE'}}) { print CONFIG "$line\n"; }
    push @done, 'LICENSE';
    print CONFIG "\n";

    # User switches
    my $i = 0;
    print CONFIG "# ".@{$config{'COMMENTS'}}[$i++]."\n";
    my $uroot = (exists $ENV{'UNIXROOT'}) ? '1' : '';
    print CONFIG "HAVE_UNIXROOT\t= $uroot\n";
    foreach my $var (qw/GSL_DEBUG OMFBUILD OPTFLAGS LIBCBLAS SHELL/) {
        my $val = $config{$var};
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG $var.$tabs."= ".$val."\n";
        print CONFIG "\n" if $var eq 'LIBCBLAS';
        push @done, $var;
    }

    # ID
    print CONFIG "\n# ".@{$config{'COMMENTS'}}[$i++]."\n";
    foreach my $var (qw/PACKAGE VERSION host_alias host_triplet/) {
        my $val = $config{$var};
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG "\n" if $var eq 'host_alias';
        print CONFIG $var.$tabs."= ".$val."\n";
        push @done, $var;
    }

    # File extensions
    print CONFIG "\n# ".@{$config{'COMMENTS'}}[$i++]."\n";
    foreach my $var (qw/EXEEXT OBJEXT/) {
        my $val = $config{$var};
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG $var.$tabs."= ".$val."\n";
        push @done, $var;
    }

    # Tools
    print CONFIG "\n# ".@{$config{'COMMENTS'}}[$i++]."\n";
    foreach my $var (qw/CC CCLD CPP FILTER IMPLIB RANLIB/) {
        my $val = $config{$var};
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG $var.$tabs."= ".$val."\n";
        push @done, $var;
    }

    # Compilation/linkage flags
    print CONFIG "\n# ".@{$config{'COMMENTS'}}[$i++]."\n";
    my $gvar = 'CFLAGS';
    print CONFIG "CFLAGS\t\t=".$config{$gvar}."\n";

    # Conditional blocks
    # XXXXX Why not use the array addresses in the hash?????
    my %omfb = (CFLAGS => [@{$config{'OMFFLAG'}}],
                LIBEXT => [@{$config{'LIBEXT'}}],
                AR     => [@{$config{'AR'}}]);
    print CONFIG roll_if("\nifdef", "OMFBUILD", \%omfb);

    my %dbgb = (CFLAGS => [$config{'DBGCFLAGS'}, $config{'OPTCFLAGS'}],
                OPTEXE => ['', $config{'OPTEXE'}]);
    print CONFIG roll_if("ifdef", "GSL_DEBUG", \%dbgb);
    push @done, $gvar;
    push @done, qw/OMFFLAG LIBEXT AR DBGCFLAGS OPTCFLAGS OPTEXE/;

    foreach my $var (qw/LDFLAGS DLLFLAGS EXEFLAGS GSLLIBS LIBS DEFS INCLUDES COMPILE LINK/) {
        my $val = $config{$var};
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG $var.$tabs."= ".$val."\n";
        print CONFIG "\n" if ($var =~ /(EXEFLAGS|LIBS|INCLUDES)/);
        push @done, $var;
    }

    # Files
    my $c = 0;
    print CONFIG "\n# ".@{$config{'COMMENTS'}}[$i++]."\n";
    foreach my $var (qw/CONFIG_HEADER CONFIG_CLEAN_FILES SCRIPTS bin_SCRIPTS
                     GSL_CFLAGS GSL_LIBS libgsl_la_DEPENDENCIES/) {
        my $val = $config{$var};
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG $var.$tabs."= ".$val."\n";
        print CONFIG "\n" unless ++$c % 3;
        push @done, $var;
    }

    # String gymnastics
    print CONFIG "\n# ".@{$config{'COMMENTS'}}[$i++]."\n";
    foreach my $var (qw/SOURCES OSOURCES OBJECTS TARGETS BINPROGS TESTPROGS TSOURCES TOBJECTS OBJLIBS/) {
        my $val = $config{$var};
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG $var.$tabs."= ".$val."\n";
        push @done, $var;
    }

    # Tag on the rest because the header-copying macro in /gsl fails without them,
    # but remove those neither we nor the macro need
    push @done, qw/SUBDIRS SUBLIBS libgsl_la_OBJECTS libgsl_la_SOURCES lib_LTLIBRARIES STRIP COMMENTS/;

    print CONFIG "\n# ".@{$config{'COMMENTS'}}[$i++]."\n";
    foreach my $var (sort {lc($a) cmp lc($b)} keys %config) {
        next if (grep /$var/, @done);
        my $val = $config{$var};
        my $space = ($val =~ /^:/) ? '' : ' ';
        my $tabs = length $var > 7 ? "\t" : "\t\t";
        print CONFIG $var.$tabs."=".$space.$val."\n";
    }
    close CONFIG;
}

# Load %config with variables from top-level configure-generated Makefile
#
sub hash_makefile {
    my $infile = "Makefile.original";
    $infile = (-e $infile) ? $infile : "Makefile";
    my $lines = load_file($infile);

    # Assumes "all:" marks the beginning of the rules
    #
    for (my $i = 0; $i < scalar @$lines; $i++) {

        my $line = @$lines[$i];

        # Don't want path settings in config.mk
	last if $line =~ /^all:/;
        next if $line =~ /^$/;
        next if $line =~ /^srcdir/;
        next if $line =~ /^top_srcdir/;
        next if $line =~ /^top_builddir/;
        next if $line =~ /^VPATH/;

        # Grab license to write to other files
	if ($line =~ /^\# Copyright/) {
            my $add = '';
            do {
                $add = @$lines[++$i];
                $add =~ s/Makefile\.in/makefile/;
                $line .= $add;
            } until ($add =~ /^\# PARTICULAR/);

            push @{$config{'LICENSE'}}, $line;
            next;
        }
        next if $line =~ /^\#/;
        next unless $line =~ /=/;

        chomp $line;

        # Variablize extensions and zap libtool evil
	$line =~ s/\.la/\$\(LIBEXT\)/g;
	$line =~ s/\.lo/\.\$\(OBJEXT\)/g;
	$line =~ s/\$\(LIBTOOL.+(compile|link)\s(\$.+)$/$2/;

        my ($var, $val) = split /\s?=\s?/, $line;
        $config{$var} = $val unless exists $config{$var};
    }
    $HEADER =~ s/ VERSION/ $config{'VERSION'}/;
    &write_config;
    &write_rules;

    return $config{'SUBDIRS'};
}

# Create Makefile from Makefile.am
#
sub write_makefile {
    my $inpath = shift;
    my $infile = ($inpath eq '') ? "../Makefile.am" : $inpath."/Makefile.am";
    open IFILE, "<$infile" or die "Can't open $infile: $!\n";
    my @lines = <IFILE>;
    close IFILE;

    # Relative path settings
    my $vpath = ($inpath eq '') ? ".." : "../".$inpath;
    my $topsrc =  ($inpath eq '') ? ".." : "../..";
    my $topbuild =  ($inpath eq '') ? "." : "..";
    my $depth = ($inpath eq '') ? '' : "../";

    $inpath =~ s/^\.\.\///;

    my $outfile = ($inpath eq '') ? "Makefile" : $inpath."/Makefile";

    if ($inpath eq '') {
        my $backup = "Makefile.original";
        rename $outfile, $backup unless -e $backup;
    }

    mkdir $inpath, 0777 unless (-e $inpath || $inpath eq '');
    open OFILE, ">$outfile" or die "Can't open $outfile: $!\n";

    print OFILE $HEADER;
    foreach my $line (@{$config{'LICENSE'}}) { print OFILE "$line\n"; }
    print OFILE "\n\n";
    print OFILE "\nsrcdir = $vpath\n";
    print OFILE "top_srcdir = $topsrc\n";
    print OFILE "top_builddir = $topbuild\n";
    print OFILE "VPATH = $vpath\n\n";
    print OFILE "CDIR = $inpath\n\n" unless $inpath eq '';
    print OFILE "include ".$depth."config.mk\n\n";

    my @multitest = qw/cblas fft integration min multimin roots multiroots specfunc/;
    print OFILE "MULTITEST = 1\n\n" if ((grep /\b$inpath\b/, @multitest) && $inpath ne '');

    my $mtests = '';
    foreach my $i (@lines) {
	next if ($i =~ /^\#/);
	next if ($i =~ /(SOURCES|lib_LTLIBRARIES|SUBLIBS)/ && $inpath eq '');

        chomp $i;
 	$i .= " build" if ($i =~ /^SUBDIRS/ && $inpath eq '');
	$i =~ s/\.la/\$\(LIBEXT\)/g;
        $i =~ s/INCLUDES\s?=/INCLUDES +=/;
	$i =~ s/^.+SOURCES/SOURCES/ unless $i =~ /^(test|gsl_randist|rng_dump|benchmark)/;
        $i =~ s/(all|clean|distclean)\-am// if $inpath eq "gsl";

        if ($inpath eq "histogram" && $i =~ /^test.+SOURCES/) {

            unless ($i =~ /^test2d_trap/) {
                $mtests .= substr $i, (index $i, '=') + 1;
                next;
            }
            $i = "test_SOURCES = ".$mtests;
        }
	print OFILE "$i\n";
    }
    print OFILE "\n\ninclude ".$depth."rules.mk\n";

    my $dllrules = write_dllblock("gslcblas", "\$(OBJECTS)",'','') if $inpath eq "cblas";
    print OFILE "\n\n$dllrules\n" if defined $dllrules;
    print OFILE $CBLASRULE if $inpath eq "cblas";
    close OFILE;
}

# Create Makefile for build subdirectory
#
sub write_build_makefile {
    mkdir "build", 0777 unless -e "build";
    my $mkfile = "build/Makefile";
    open BMKF, ">$mkfile" or die "Can't open $mkfile: $!\n";
    print BMKF $HEADER;
    foreach my $line (@{$config{'LICENSE'}}) { print BMKF "$line\n"; }
    print BMKF "\n\n";
    print BMKF "top_srcdir = ../..\n";
    print BMKF "top_builddir = ..\n";
    print BMKF "VPATH = ..\n\n";
    print BMKF "include ../config.mk\n\n";

    (my $objds = $config{'SUBDIRS'}) =~ s/(gsl|const|cblas|doc|build)//g;
    print BMKF "OBJDIRS = $objds\n\n";
    print BMKF "STATOBJS = \$(addprefix ../,\$(addsuffix /*.o,\$(OBJDIRS)))\n\n";

    print BMKF "include ../rules.mk\n\n";
    my $dllrules = write_dllblock("gsl", "\$(OBJLIBS)", "\$(LIBCBLAS)", "version.o");
    print BMKF "\n\n$dllrules\n";
    close BMKF;
}

# String together DLL-creation rules for Makefiles in cblas and build
#
sub write_dllblock {
    my ($name, $objs, $libs, $add) = @_;
    my $sublib = ($name eq 'gslcblas') ? 'CBLAS' : '';

    my $dllrules = "ifndef OMFBUILD\n";
    $dllrules .= "all: $name\_s\$(LIBEXT)\n\n";
    $dllrules .= "else\n";
    $dllrules .= "all: $name\.dll $name\$(LIBEXT) $name\_s\$(LIBEXT)\n\n";

    $dllrules .= "$name\.dll: $objs $name\.def\n";
    $dllrules .= "\t\$(LINK) \$(DLLFLAGS) $objs $add $name\.def $libs\n\n";

    $dllrules .= "$name\.def: $objs $add\n";
    $dllrules .= "\t\@cmd /C \"echo LIBRARY $name INITINSTANCE TERMINSTANCE >\$\@\"\n";
    $dllrules .= "\t\@cmd /C \"echo DESCRIPTION \\\"GNU Scientific Library $config{'VERSION'} $sublib\\\" >>\$@\"\n";
    $dllrules .= "\t\@cmd /C \"echo PROTMODE >>\$\@\"\n";
    $dllrules .= "\t\@cmd /C \"echo CODE    LOADONCALL MOVEABLE DISCARDABLE >>\$\@\"\n";
    $dllrules .= "\t\@cmd /C \"echo DATA    PRELOAD MOVEABLE MULTIPLE NONSHARED >>\$\@\"\n";
    $dllrules .= "\t\@cmd /C \"echo EXPORTS >>\$\@\"\n";
    $dllrules .= "\t\$(FILTER) $objs $add >> \$\@\n\n";

    $dllrules .= "$name\$(LIBEXT): $name\.def\n";
    $dllrules .= "\t\$(IMPLIB) -o \$\@ \$<\n";
    $dllrules .= "endif\n\n";

    $dllrules .= "$name\_s\$(LIBEXT): $objs\n";
    $dllrules .= "\t\$(AR) \$\@ \$(STATOBJS) $add\n\n";

    if ($name eq "gsl") {
	$dllrules .= "version.o: \$(top_srcdir)/version.c\n";
	$dllrules .= "\t\$(COMPILE) -o \$\@ -c \$<\n\n";
    }
    return $dllrules;
}

# Engine
#
sub make_makefiles {
    my $subdirs = hash_makefile;

    print "Generating OS/2 Makefiles\n";

    my $depth = '';
    write_makefile($depth);

    $depth = '../';
    foreach my $d (split ' ', $subdirs) {
	write_makefile($depth.$d) unless $d eq "build";
    }
    &write_build_makefile;

    print "Done!\nNow run gmake to build GSL ".$config{'VERSION'}.".\n";
}

# Ignition
#
&make_makefiles;
exit(0);


